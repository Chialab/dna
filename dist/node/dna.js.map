{
  "version": 3,
  "sources": ["../../src/window.ts", "../../src/helpers.ts", "../../src/property.ts", "../../src/DOM.ts", "../../src/events.ts", "../../node_modules/htm/dist/htm.module.js", "../../src/Thenable.ts", "../../src/Observable.ts", "../../src/css.ts", "../../src/render.ts", "../../src/Component.ts", "../../src/CustomElementRegistry.ts", "../../src/directives.ts"],
  "sourcesContent": ["import jsdom from 'jsdom';\n\nlet namespace: Window & typeof globalThis;\nif (typeof window !== 'undefined') {\n    namespace = window;\n} else {\n    namespace = new jsdom.JSDOM().window as unknown as Window & typeof globalThis;\n}\n\nexport { namespace as window };\n", "import type { IterableNodeList } from './types';\nimport type { ComponentInstance } from './Component';\nimport { window } from './window';\n\nlet symbols = 0;\n\n/**\n * Create a symbolic key.\n * When native Symbol is not defined, compute an unique string key.\n * @return An unique key.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const createSymbol = (description?: string | number): any => {\n    /* c8 ignore start */\n    if (typeof Symbol !== 'undefined') {\n        return Symbol(description);\n    }\n    return `__dna${symbols++}`;\n    /* c8 ignore stop */\n};\n\nexport const { Node, HTMLElement, Event, CustomEvent, document } = window;\nexport const { DOCUMENT_NODE, TEXT_NODE, COMMENT_NODE, ELEMENT_NODE } = Node;\n\n/**\n * Alias to Array.isArray.\n */\nexport const isArray = Array.isArray;\n\n/**\n * Alias Array.prototype.indexOf.\n */\nexport const indexOf = Array.prototype.indexOf;\n\n/**\n * Alias to Object.getOwnPropertyDescriptor.\n */\nexport const getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n/**\n * Alias to Object.setPrototypeOf.\n */\nexport const getPrototypeOf = Object.getPrototypeOf;\n\n/**\n * Alias to Object.setPrototypeOf.\n */\nexport const setPrototypeOf = Object.setPrototypeOf || ((obj, proto) => { obj.__proto__ = proto; });\n\n/**\n * Alias to Object.prototype.toString.\n */\nexport const toString = Object.prototype.toString;\n\n/**\n * Alias to Object.prototype.hasOwnProperty.\n */\nexport const hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Alias to Object.defineProperty.\n */\nexport const defineProperty = Object.defineProperty;\n\n/**\n * Alias to Node.prototype.appendChild.\n */\nexport const appendChildImpl = Node.prototype.appendChild;\n\n/**\n * Alias to Node.prototype.removeChild.\n */\nexport const removeChildImpl = Node.prototype.removeChild;\n\n/**\n * Alias to Node.prototype.insertBefore.\n */\nexport const insertBeforeImpl = Node.prototype.insertBefore;\n\n/**\n * Alias to Node.prototype.replaceChild.\n */\nexport const replaceChildImpl = Node.prototype.replaceChild;\n\n/**\n * Alias to HTMLElement.prototype.insertAdjacentElement.\n */\nexport const insertAdjacentElementImpl = HTMLElement.prototype.insertAdjacentElement;\n\n/**\n * Alias to Node.prototype.isConnected.\n */\nexport const isConnectedImpl = getOwnPropertyDescriptor(Node.prototype, 'isConnected');\n\n/**\n * Alias to HTMLElement.prototype.getAttribute.\n */\nexport const getAttributeImpl = HTMLElement.prototype.getAttribute;\n\n/**\n * Alias to HTMLElement.prototype.hasAttribute.\n */\nexport const hasAttributeImpl = HTMLElement.prototype.hasAttribute;\n\n/**\n * Alias to HTMLElement.prototype.setAttribute.\n */\nexport const setAttributeImpl = HTMLElement.prototype.setAttribute;\n\n/**\n * Alias to HTMLElement.prototype.removeAttribute.\n */\nexport const removeAttributeImpl = HTMLElement.prototype.removeAttribute;\n\n/**\n * Alias to HTMLElement.prototype.matches.\n */\nexport const matchesImpl = HTMLElement.prototype.matches ||\n    HTMLElement.prototype.webkitMatchesSelector ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (HTMLElement.prototype as any).msMatchesSelector;\n\n/**\n * Alias to document.createDocumentFragment.\n */\nexport const createDocumentFragmentImpl = document.createDocumentFragment.bind(document);\n\n/**\n * Alias to document.createElement.\n */\nexport const createElementImpl = document.createElement.bind(document);\n\n/**\n * Alias to document.createElementNS.\n */\nexport const createElementNSImpl = document.createElementNS.bind(document);\n\n/**\n * Alias to document.createTextNode.\n */\nexport const createTextNodeImpl = document.createTextNode.bind(document);\n\n/**\n * Alias to document.createComment.\n */\nexport const createCommentImpl = document.createComment.bind(document);\n\n/**\n * Create a Custom Event.\n * @param typeArg The name of the event.\n * @param eventInitDict The options of the event.\n * @return The constructed Custom Event.\n */\nexport const createEventImpl = (typeArg: string, eventInitDict: CustomEventInit<unknown> = {}): CustomEvent<unknown> => {\n    let event;\n    try {\n        event = new CustomEvent(typeArg, eventInitDict);\n    } catch {\n        event = document.createEvent('CustomEvent');\n        event.initCustomEvent(typeArg, eventInitDict.bubbles || false, eventInitDict.cancelable || false, eventInitDict.detail);\n    }\n    return event;\n};\n\n/**\n * Check if the target is a Node instance.\n * @param target The target to check.\n * @return The target is a Node instance.\n */\nexport const isNode = (target: unknown): target is Node => target instanceof Node;\n\n/**\n * Check if a node is a Document instance.\n * @param node The node to check.\n * @return The node is a Document instance.\n */\nexport const isDocument = (node: Node): node is Document => node && node.nodeType === DOCUMENT_NODE;\n\n/**\n * Check if a node is a Text instance.\n * @param node The node to check.\n * @return The node is a Text instance.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isText = (node: any): node is Text => node && node.nodeType === TEXT_NODE;\n\n/**\n * Check if a node is an Element instance.\n * @param node The node to check.\n * @return The node is an Element instance.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isElement = <T extends Element>(node: any): node is T => node && node.nodeType === ELEMENT_NODE;\n\n/**\n * Check if an object is an Event instance.\n * @param node The node to check.\n * @return The object is an Event instance.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isEvent = (event: any): event is Event => event instanceof Event;\n\n/**\n * Check if a Node is connected.\n *\n * @return A truthy value for connected targets.\n */\nexport const isConnected: (this: Node) => boolean = isConnectedImpl ?\n    (isConnectedImpl.get as (this: Node) => boolean) :\n    function(this: Node): boolean {\n        if (isElement(this) || isText(this)) {\n            const parent = this.parentNode;\n            if (!parent) {\n                return false;\n            }\n            return isConnected.call(parent);\n        }\n        if (isDocument(this)) {\n            return true;\n        }\n\n        return false;\n    };\n\n/**\n * A symbol which identify emulated components.\n */\nconst EMULATE_LIFECYCLE_SYMBOL: unique symbol = createSymbol();\n\ntype WithEmulatedLifecycle<T extends Element> = T & {\n    [EMULATE_LIFECYCLE_SYMBOL]?: boolean;\n};\n\n/**\n * Check if a node require emulated life cycle.\n * @param node The node to check.\n */\nexport const shouldEmulateLifeCycle = (node: WithEmulatedLifecycle<Element>) => !!node[EMULATE_LIFECYCLE_SYMBOL];\n\n/**\n * Invoke `connectedCallback` method of a Node (and its descendents).\n * It does nothing if life cycle is disabled.\n *\n * @param node The connected node.\n */\nexport const connect = (node: Node) => {\n    if (!isElement(node)) {\n        return;\n    }\n    if (shouldEmulateLifeCycle(node)) {\n        (node as ComponentInstance<HTMLElement>).connectedCallback();\n    }\n    const children = cloneChildNodes(node.childNodes);\n    for (let i = 0, len = children.length; i < len; i++) {\n        connect(children[i]);\n    }\n};\n\n/**\n * Invoke `disconnectedCallback` method of a Node (and its descendents).\n * It does nothing if life cycle is disabled.\n *\n * @param node The disconnected node.\n */\nexport const disconnect = (node: Node) => {\n    if (!isElement(node)) {\n        return;\n    }\n    if (shouldEmulateLifeCycle(node)) {\n        (node as ComponentInstance<HTMLElement>).disconnectedCallback();\n    }\n    const children = cloneChildNodes(node.childNodes);\n    for (let i = 0, len = children.length; i < len; i++) {\n        disconnect(children[i]);\n    }\n};\n\n/**\n * Should emulate life cycle.\n */\nlet lifeCycleEmulation = typeof window.customElements === 'undefined';\n\n/**\n * Flag the element for life cycle emulation.\n */\nexport const emulateLifeCycle = (node: WithEmulatedLifecycle<HTMLElement>) => {\n    lifeCycleEmulation = true;\n    node[EMULATE_LIFECYCLE_SYMBOL] = true;\n};\n\n/**\n * Life cycle emulation status.\n */\nexport const emulatingLifeCycle = () => lifeCycleEmulation;\n\n/**\n * Clone an array like instance.\n * @param arr The array to convert.\n * @return A shallow clone of the array.\n */\nexport const cloneChildNodes = (arr: NodeList|IterableNodeList) => {\n    const result = [] as unknown as IterableNodeList;\n    result.item = (index) => result[index];\n    for (let i = arr.length; i--; result.unshift(arr.item(i) as Node));\n    return result;\n};\n", "import type { ClassElement, Constructor, MethodsOf, Replace } from './types';\nimport type { ComponentInstance, ComponentConstructor } from './Component';\nimport { createSymbol, HTMLElement, isArray, defineProperty as _defineProperty, getOwnPropertyDescriptor, hasOwnProperty, getPrototypeOf } from './helpers';\nimport { isConstructed } from './Component';\n\n/**\n * A Symbol which contains all Property instances of a Component.\n */\nconst PROPERTIES_SYMBOL: unique symbol = createSymbol();\n\n/**\n * A Symbol which contains all Property observers of a Component.\n */\nconst OBSERVERS_SYMBOL: unique symbol = createSymbol();\n\n/**\n * Retrieve properties declarations of a Component.\n */\nexport type PropertiesOf<T extends ComponentInstance<HTMLElement>> = {\n    [P in keyof T]: Property<T, P>;\n};\n\n/**\n * Retrieve properties declarations of a Component.\n */\nexport type ObserversOf<T extends ComponentInstance<HTMLElement>> = {\n    [P in keyof T]: PropertyObserver<T[P]>[];\n};\n\n/**\n * A prototype with properties.\n */\nexport type WithProperties<T extends ComponentInstance<HTMLElement>> = T & {\n    [PROPERTIES_SYMBOL]?: PropertiesOf<T>;\n};\n\n/**\n * A prototype with observers.\n */\nexport type WithObservers<T extends ComponentInstance<HTMLElement>> = T & {\n    [OBSERVERS_SYMBOL]?: ObserversOf<T>;\n};\n\n/**\n * The observer signature for properties.\n *\n * @param oldValue The previous value of the property.\n * @param newValue The current value of the property.\n */\nexport type PropertyObserver<TypeHint = unknown> = (oldValue: TypeHint | undefined, newValue: TypeHint, propertyKey: string) => void;\n\n/**\n * Convert constructor types to their normalised instance types.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype ConvertConstructorTypes<C extends Constructor<unknown>> = Replace<Replace<Replace<Replace<Replace<InstanceType<C>, Number, number>, String, string>, Boolean, boolean>, unknown[], any[]>, Object, any>;\n\n/**\n * A state property declaration.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PropertyDeclaration<TypeConstructorHint extends Constructor<any> = Constructor<any>> = PropertyDescriptor & {\n    /**\n     * The property private symbol.\n     */\n    symbol?: symbol;\n    /**\n     * Flag state properties.\n     */\n    state?: boolean;\n    /**\n     * The property is bound to an attribute. Also specifies the attribute name if different from the property.\n     */\n    attribute?: boolean|string;\n    /**\n     * Convert attribute to property value.\n     *\n     * @param value The attributue value.\n     * @return The property value.\n     */\n    fromAttribute?: (value: string | null) => ConvertConstructorTypes<TypeConstructorHint> | undefined;\n    /**\n     * Convert property to attribute value.\n     * @param value The property value.\n     * @return The attributue value.\n     */\n    toAttribute?: (value: ConvertConstructorTypes<TypeConstructorHint>) => string|null|undefined;\n    /**\n     * The initial value of the property.\n     */\n    defaultValue?: ConvertConstructorTypes<TypeConstructorHint>;\n     /**\n      * A list of valid property values prototypes.\n      */\n    type?: TypeConstructorHint | TypeConstructorHint[];\n    /**\n     * Define a property observable.\n     */\n    observe?: PropertyObserver<ConvertConstructorTypes<TypeConstructorHint>>;\n    /**\n     * A list of field observables.\n     */\n    observers?: PropertyObserver<ConvertConstructorTypes<TypeConstructorHint>>[];\n    /**\n     * A custom validation function for the property.\n     * Property assignement throws when this function returns falsy values.\n     */\n    validate?: (value: unknown) => boolean;\n    /**\n     * Native custom getter for the property.\n     */\n    get?: PropertyDescriptor['get'];\n    /**\n     * Native custom setter for the property.\n     */\n    set?: PropertyDescriptor['set'];\n    /**\n     * Define custom getter for the property.\n     * @param value The current property value.\n     */\n    getter?: (value?: ConvertConstructorTypes<TypeConstructorHint>) => ReturnType<NonNullable<PropertyDescriptor['get']>>;\n    /**\n     * Define a custom setter for the property.\n     * It runs before property validations.\n     * The returned value will be set to the property.\n     * @param newValue The value to set.\n     */\n    setter?: (newValue?: Parameters<NonNullable<PropertyDescriptor['set']>>[0]) => ConvertConstructorTypes<TypeConstructorHint>;\n    /**\n     * The event to fire on property change.\n     */\n    event?: true | string;\n    /**\n     * The initializer function.\n     */\n    initializer?: Function;\n};\n\n/**\n * Property configuration for properties accessor.\n */\nexport type PropertyConfig<TypeConstructorHint extends Constructor<unknown> = Constructor<unknown>> = PropertyDeclaration<TypeConstructorHint> | TypeConstructorHint | TypeConstructorHint[];\n\n/**\n * A property instance.\n */\nexport type Property<T extends ComponentInstance<HTMLElement>, P extends keyof T>= PropertyDescriptor & {\n    /**\n     * The property name of the field.\n     */\n    readonly name: P;\n    /**\n     * The property private symbol.\n     */\n    symbol: symbol;\n    /**\n     * Flag state properties.\n     */\n    state: boolean;\n    /**\n     * The bound attribute name.\n     */\n    attribute?: string;\n    /**\n     * The initial value of the property.\n     */\n    defaultValue?: T[P];\n    /**\n     * A list of valid property values prototypes.\n     */\n    type: Constructor<T[P]>[];\n    /**\n     * Convert attribute to property value.\n     *\n     * @param value The attributue value.\n     * @return The property value.\n     */\n    fromAttribute?: (value: string|null) => T[P];\n    /**\n     * Convert property to attribute value.\n     * @param value The property value.\n     * @return The attributue value.\n     */\n    toAttribute?: (value: T[P]) => string|null|undefined;\n    /**\n     * A list of field observables.\n     */\n    observers: PropertyObserver<T[P]>[];\n    /**\n     * A custom validation function for the property.\n     * Property assignement throws when this function returns falsy values.\n     */\n    validate?: (value: unknown) => boolean;\n    /**\n     * Native custom getter for the property.\n     */\n    get?: PropertyDescriptor['get'];\n     /**\n      * Native custom setter for the property.\n      */\n    set?: PropertyDescriptor['set'];\n    /**\n     * Define custom getter for the property.\n     * @param value The current property value.\n     */\n    getter?: (value?: T[P]) => ReturnType<NonNullable<PropertyDescriptor['get']>>;\n    /**\n     * Define a custom setter for the property.\n     * It runs before property validations.\n     * The returned value will be set to the property.\n     * @param newValue The value to set.\n     */\n    setter?: (newValue?: Parameters<NonNullable<PropertyDescriptor['set']>>[0]) => T[P];\n    /**\n     * The event to fire on property change.\n     */\n    event?: string;\n    /**\n     * The initializer function.\n     */\n    initializer?: Function;\n}\n\n/**\n * Retrieve all properties descriptors.\n * @param prototype The component prototype.\n * @return A list of property descriptors.\n */\nexport const getProperties = <T extends ComponentInstance<HTMLElement>>(prototype: WithProperties<T>) => {\n    const props = (prototype[PROPERTIES_SYMBOL] || {}) as PropertiesOf<T>;\n\n    if (!hasOwnProperty.call(prototype, PROPERTIES_SYMBOL)) {\n        return {\n            __proto__: props,\n        } as unknown as PropertiesOf<T>;\n    }\n\n    return props;\n};\n\n/**\n * Retrieve property declaration.\n * @param prototype The component prototype.\n * @param propertyKey The name of the property.\n * @param failIfMissing Should throw an exception if the property is not defined.\n * @return The property declaration.\n */\nexport const getProperty = <T extends ComponentInstance<HTMLElement>, P extends keyof T>(prototype: T, propertyKey: P, failIfMissing = false) => {\n    const property = getProperties(prototype)[propertyKey];\n    if (failIfMissing && !property) {\n        throw new Error(`Missing property ${propertyKey}`);\n    }\n    return property;\n};\n\n/**\n * Get valid constructors for the property.\n * @param declaration The property declaration.\n * @return A list of constructors.\n */\nconst extractTypes = <T extends ComponentInstance<HTMLElement>, P extends keyof T>(declaration: PropertyDeclaration<Constructor<T[P]>>) => {\n    const type = declaration.type;\n    if (!type) {\n        return [];\n    }\n    if (isArray(type)) {\n        return type;\n    }\n\n    return [type];\n};\n\n/**\n * Get observers for the property.\n * @param declaration The property declaration.\n * @return A list of observers.\n */\nconst extractObservers = <T extends ComponentInstance<HTMLElement>, P extends keyof T>(declaration: PropertyDeclaration<Constructor<T[P]>>) => {\n    const observers = declaration.observers || [];\n    if (declaration.observe) {\n        return [declaration.observe, ...observers];\n    }\n    return observers;\n};\n\n/**\n * Define an observed property.\n * @param prototype The component prototype.\n * @param propertyKey The name of the property.\n * @param declaration The property descriptor.\n * @param symbol The symbol to use to store property value.\n * @return The final descriptor.\n */\nexport const defineProperty = <T extends ComponentInstance<HTMLElement>, P extends keyof T>(prototype: WithProperties<T>, propertyKey: P, declaration: PropertyDeclaration<Constructor<T[P]>>, symbolKey: symbol): PropertyDescriptor => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const symbol: unique symbol = symbolKey as any;\n    const hasAttribute = declaration.attribute || (declaration.attribute == null ? !declaration.state : false);\n    const declarations = prototype[PROPERTIES_SYMBOL] = getProperties(prototype);\n    const attribute = hasAttribute ?\n        (typeof declaration.attribute === 'string' ? declaration.attribute : propertyKey) :\n        undefined;\n    const event = declaration.event ?\n        (declaration.event === true ? `${propertyKey}change` : declaration.event) :\n        undefined;\n    const state = !!declaration.state;\n    const type = extractTypes(declaration);\n    const property = declarations[propertyKey] = {\n        fromAttribute(newValue) {\n            if (type.indexOf(Boolean as unknown as Constructor<T[P]>) !== -1 && (!newValue || newValue === attribute)) {\n                if (newValue === '' || newValue === attribute) {\n                    // if the attribute value is empty or it is equal to the attribute name consider it as a boolean\n                    return true;\n                }\n                return false;\n            }\n            if (newValue) {\n                if (type.indexOf(Number as unknown as Constructor<T[P]>) !== -1 && !isNaN(newValue as unknown as number)) {\n                    return parseFloat(newValue);\n                }\n                if (type.indexOf(String as unknown as Constructor<T[P]>) === -1) {\n                    try {\n                        return JSON.parse(newValue as string);\n                    } catch {\n                        //\n                    }\n                }\n            }\n            return newValue;\n        },\n        toAttribute(newValue: unknown) {\n            if (newValue == null || newValue === false) {\n                // a falsy value should remove the attribute\n                return null;\n            }\n            if (typeof newValue === 'object') {\n                // objects should be ignored\n                return;\n            }\n            // if the value is `true` should set an empty attribute\n            if (newValue === true) {\n                return '';\n            }\n            // otherwise just set the value\n            return `${newValue}`;\n        },\n        ...declaration,\n        name: propertyKey,\n        symbol,\n        state,\n        type,\n        observers: extractObservers(declaration),\n        attribute,\n        event,\n    } as Property<T, P>;\n\n    const { get, set, getter, setter } = property;\n\n    type E = T & {\n        [symbol]: E[P];\n    };\n\n    const validate = typeof property.validate === 'function' && property.validate;\n    const finalDescriptor: PropertyDescriptor = {\n        configurable: true,\n        enumerable: true,\n        get(this: E) {\n            let value = this[symbol];\n            if (get) {\n                value = get.call(this);\n            }\n            if (getter) {\n                value = getter.call(this, value);\n            }\n            return value;\n        },\n        set(this: E, newValue) {\n            if (!isConstructed(this)) {\n                this[symbol] = newValue;\n                return;\n            }\n\n            const oldValue = this[symbol];\n            if (setter) {\n                newValue = setter.call(this, newValue);\n            }\n            if (set) {\n                set.call(this, newValue);\n                newValue = this[symbol];\n            }\n\n            if (oldValue === newValue) {\n                // no changes\n                return;\n            }\n\n            // if types or custom validator has been set, check the value validity\n            if (newValue != null && newValue !== false) {\n                let valid = true;\n                if (type.length) {\n                    // check if the value is an instanceof of at least one constructor\n                    valid = type.some((Type) => (newValue instanceof Type || (newValue.constructor === Type)));\n                }\n                if (valid && validate) {\n                    valid = validate.call(this, newValue);\n                }\n                if (!valid) {\n                    throw new TypeError(`Invalid \\`${newValue}\\` value for \\`${String(propertyKey)}\\` property`);\n                }\n            }\n\n            this[symbol] = newValue;\n\n            const observers = getPropertyObservers(this, propertyKey);\n            for (let i = 0, len = observers.length; i < len; i++) {\n                observers[i].call(this, oldValue, newValue, propertyKey as string);\n            }\n\n            if (event) {\n                this.dispatchEvent(event, {\n                    newValue,\n                    oldValue,\n                });\n            }\n\n            // trigger changes\n            if (state) {\n                this.stateChangedCallback(propertyKey, oldValue, newValue);\n            } else {\n                this.propertyChangedCallback(propertyKey, oldValue, newValue);\n            }\n\n            if (this.isConnected) {\n                this.forceUpdate();\n            }\n        },\n    };\n\n    _defineProperty(prototype, propertyKey, finalDescriptor);\n\n    return finalDescriptor;\n};\n\n/**\n * Define component constructor properties.\n * @param prototype The component prototype.\n */\nexport const defineProperties = <T extends ComponentInstance<HTMLElement>>(prototype: T) => {\n    const handled: { [key: string]: boolean } = {};\n    const constructor = prototype.constructor as ComponentConstructor<HTMLElement>;\n    let ctr = constructor;\n    while (ctr && ctr !== HTMLElement) {\n        const propertiesDescriptor = getOwnPropertyDescriptor(ctr, 'properties');\n        if (propertiesDescriptor) {\n            const descriptorProperties = (propertiesDescriptor.get ? (propertiesDescriptor.get.call(constructor) || {}) : propertiesDescriptor.value) as {\n                [P in keyof T]: PropertyConfig<Constructor<T[P]>>;\n            };\n            for (const propertyKey in descriptorProperties) {\n                if (propertyKey in handled) {\n                    continue;\n                }\n                const config = descriptorProperties[propertyKey];\n                const declaration = (typeof config === 'function' || isArray(config) ? { type: config } : config) as PropertyDeclaration<Constructor<T[typeof propertyKey]>>;\n                const symbol: unique symbol = declaration.symbol || createSymbol(propertyKey as string);\n                defineProperty(\n                    prototype,\n                    propertyKey,\n                    declaration,\n                    symbol\n                );\n                handled[propertyKey] = true;\n            }\n        }\n\n        ctr = getPrototypeOf(ctr);\n    }\n};\n\n/**\n * Get the property bound to the attribute.\n * @param prototype The prototype of the Component.\n * @param attributeName The name of the bound attribute.\n * @return The property declaration.\n */\nexport const getPropertyForAttribute = <T extends ComponentInstance<HTMLElement>>(prototype: T, attributeName: string) => {\n    const properties = getProperties(prototype);\n    for (const propertyKey in properties) {\n        const property = properties[propertyKey];\n        if (property.attribute === attributeName) {\n            return property;\n        }\n    }\n    return null;\n};\n\n/**\n * Reflect property values to attributes.\n *\n * @param element The node to update.\n * @param propertyName The name of the changed property.\n * @param newValue The new value for the property (undefined if removed).\n */\nexport const reflectPropertyToAttribute = <T extends ComponentInstance<HTMLElement>, P extends keyof T>(element: T, propertyName: P, newValue: T[P]) => {\n    const property = getProperty(element, propertyName, true);\n    const { attribute, toAttribute } = property;\n    if (attribute && toAttribute) {\n        const value = toAttribute.call(element, newValue);\n        if (value === null) {\n            element.removeAttribute(attribute);\n        } else if (value !== undefined && value !== element.getAttribute(attribute)) {\n            element.setAttribute(attribute, value as string);\n        }\n    }\n};\n\n/**\n * Populate property declaration using its field descriptor.\n * @param declaration The declaration to update.\n * @param descriptor The field descriptor.\n */\nconst assignFromDescriptor = (declaration: PropertyDeclaration, descriptor: PropertyDescriptor, initializer?: Function) => {\n    declaration.initializer = initializer;\n    declaration.get = descriptor.get;\n    declaration.set = descriptor.set;\n    if (!descriptor.get) {\n        declaration.defaultValue = descriptor.value;\n    }\n};\n\n/**\n * Add a property to a component prototype.\n * @param targetOrClassElement The component prototype.\n * @param declaration The property declaration.\n * @param propertyKey The property name.\n * @param descriptor The native property descriptor.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const createProperty = <T extends ComponentInstance<HTMLElement>, P extends keyof T>(targetOrClassElement: T, declaration: PropertyDeclaration<Constructor<T[P]>>, propertyKey?: P, descriptor?: PropertyDeclaration<Constructor<T[P]>>): any => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const symbol: unique symbol = declaration.symbol || createSymbol(propertyKey as string) as any;\n    if (propertyKey !== undefined) {\n        descriptor = descriptor || getOwnPropertyDescriptor(targetOrClassElement, propertyKey);\n        if (descriptor) {\n            assignFromDescriptor(declaration, descriptor);\n        }\n        return defineProperty(targetOrClassElement as T, propertyKey, declaration, symbol);\n    }\n\n    // spec 2\n    const element = targetOrClassElement as unknown as ClassElement;\n    const key = String(element.key) as P;\n    type E = T & {\n        [symbol]: E[P];\n    };\n\n    if (element.kind !== 'field' || element.placement !== 'own') {\n        return element;\n    }\n\n    if (element.descriptor) {\n        assignFromDescriptor(declaration, element.descriptor, element.initializer);\n    }\n\n    return {\n        kind: element.kind,\n        key: symbol,\n        placement: element.placement,\n        descriptor: {\n            configurable: false,\n            writable: true,\n            enumerable: false,\n        },\n        initializer(this: E) {\n            return this[symbol];\n        },\n        finisher(constructor: Constructor<T>) {\n            defineProperty(constructor.prototype, key, declaration, symbol);\n        },\n    };\n};\n\n/**\n * Add a property observer to a component prototype.\n * @param targetOrClassElement The component prototype.\n * @param propertyKey The property name to watch.\n * @param methodKey The method name.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const createObserver = <T extends ComponentInstance<HTMLElement>, P extends keyof T, M extends keyof T>(targetOrClassElement: T, propertyKey: P, methodKey?: M): any => {\n    if (methodKey !== undefined) {\n        const property = getProperty(targetOrClassElement, propertyKey, true);\n        property.observers.push(targetOrClassElement[methodKey] as unknown as PropertyObserver<T[P]>);\n        return;\n    }\n\n    const element = targetOrClassElement as unknown as ClassElement;\n    if (!element.descriptor) {\n        return element;\n    }\n    const observer = element.descriptor.value as PropertyObserver<T[P]>;\n    element.finisher = (constructor) => {\n        const property = getProperty(constructor.prototype, propertyKey, true);\n        property.observers.push(observer);\n    };\n    return element;\n};\n\n/**\n * Get element properties observers.\n * @param element The node.\n * @return The map of observers.\n */\nexport const getObservers = <T extends ComponentInstance<HTMLElement>>(element: WithObservers<T>) => element[OBSERVERS_SYMBOL] = element[OBSERVERS_SYMBOL] || {} as ObserversOf<T>;\n\n/**\n * Get observers for an element property.\n * @param element The node.\n * @param propertyName The name of the property.\n * @return A list of observers.\n */\nexport const getPropertyObservers = <T extends ComponentInstance<HTMLElement>, P extends keyof T>(element: WithObservers<T>, propertyName: P) => {\n    if (!getProperty(element, propertyName)) {\n        throw new Error(`Missing property ${propertyName}`);\n    }\n    const observers = getObservers(element);\n    return observers[propertyName] = observers[propertyName] || [];\n};\n\n/**\n * Add an observer for a property.\n * @param element The node context.\n * @param propertyName The name of the property to watch.\n * @param observer The observer function to add.\n */\nexport const addObserver = <T extends ComponentInstance<HTMLElement>, P extends keyof T>(element: WithObservers<T>, propertyName: P, observer: PropertyObserver<T[P]>) => {\n    getPropertyObservers(element, propertyName).push(observer);\n};\n\n/**\n * Remove an observer for a property.\n * @param element The node context.\n * @param propertyName The name of the watched property.\n * @param observer The observer function to remove.\n */\nexport const removeObserver = <T extends ComponentInstance<HTMLElement>, P extends keyof T>(element: WithObservers<T>, propertyName: P, observer: PropertyObserver<T[P]>) => {\n    const observers = getPropertyObservers(element, propertyName);\n    const io = observers.indexOf(observer);\n    if (io !== -1) {\n        observers.splice(io, 1);\n    }\n};\n\n/**\n * A decorator for property definition.\n *\n * @param declaration The property declaration.\n * @return The decorator initializer.\n */\nexport function property<TypeConstructorHint extends Constructor<unknown> = Constructor<unknown>>(declaration: PropertyDeclaration<TypeConstructorHint> = {}) {\n    return <T extends ComponentInstance<HTMLElement>, P extends keyof T>(\n        targetOrClassElement: T,\n        propertyKey?: P,\n        descriptor?: PropertyDeclaration<Constructor<T[P]>>\n    ) => createProperty(targetOrClassElement, declaration as PropertyDeclaration<Constructor<T[P]>>, propertyKey, descriptor);\n}\n\n/**\n * A decorator for state property definition.\n *\n * @param declaration The state property declaration.\n * @return The decorator initializer.\n */\nexport function state<TypeConstructorHint extends Constructor<unknown> = Constructor<unknown>>(declaration: PropertyDeclaration<TypeConstructorHint> = {}) {\n    return <T extends ComponentInstance<HTMLElement>, P extends keyof T>(\n        targetOrClassElement: T,\n        propertyKey?: P,\n        descriptor?: PropertyDeclaration<Constructor<T[P]>>\n    ) => createProperty(targetOrClassElement, { ...(declaration as PropertyDeclaration<Constructor<T[P]>>), state: true }, propertyKey, descriptor);\n}\n\n/**\n * A decorator for property observer.\n *\n * @param propertyKey The property key to observe.\n * @return The decorator initializer.\n */\nexport function observe(propertyKey: string): Function {\n    return <T extends ComponentInstance<HTMLElement>, P extends MethodsOf<T>>(\n        targetOrClassElement: T,\n        methodKey?: P\n    ) => createObserver(targetOrClassElement, propertyKey as keyof T, methodKey);\n}\n", "import type { ComponentConstructor, ComponentInstance } from './Component';\nimport { connect, disconnect, isConnected, shouldEmulateLifeCycle, appendChildImpl, removeChildImpl, insertBeforeImpl, replaceChildImpl, insertAdjacentElementImpl, getAttributeImpl, hasAttributeImpl, setAttributeImpl, removeAttributeImpl, createDocumentFragmentImpl, createElementImpl, createElementNSImpl, createTextNodeImpl, createCommentImpl, createEventImpl, emulatingLifeCycle } from './helpers';\nimport { isComponent, isComponentConstructor } from './Component';\nimport { customElements } from './CustomElementRegistry';\n\n/**\n * DOM is a singleton that components uses to access DOM methods.\n * By default, it uses browsers' DOM implementation, but it can be set to use a different one.\n * For example, in a Node context it is possibile to use DNA thanks to the `jsdom` dom implementation.\n * It also handle element life cycle for custom elements unless otherwise specified.\n */\nexport const DOM = {\n    /**\n     * Create a document fragment.\n     *\n     * @return The new DOM fragment.\n     */\n    createDocumentFragment: createDocumentFragmentImpl,\n\n    /**\n     * Create a new DOM element node for the specified tag.\n     *\n     * @param qualifiedName The specified tag.\n     * @return The new DOM element instance.\n     */\n    createElement<K extends keyof HTMLElementTagNameMap>(qualifiedName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K] {\n        const is = options && options.is;\n        const name = is || qualifiedName.toLowerCase();\n        const node = createElementImpl(qualifiedName);\n        const constructor = customElements.get(name);\n        if (constructor && isComponentConstructor(constructor) && !(node instanceof constructor)) {\n            constructor.upgrade(node);\n        }\n        return node;\n    },\n\n    /**\n     * Create a new DOM element node for the specified tag using a namespace.\n     *\n     * @param namespaceURI The namespace of the tag.\n     * @param tagName The specified tag.\n     * @return The new DOM element instance.\n     */\n    createElementNS(namespaceURI: Parameters<typeof createElementNSImpl>[0], qualifiedName: Parameters<typeof createElementNSImpl>[1]) {\n        if (namespaceURI === 'http://www.w3.org/1999/xhtml') {\n            return this.createElement(qualifiedName as keyof HTMLElementTagNameMap);\n        }\n        return createElementNSImpl(namespaceURI, qualifiedName as keyof SVGElementTagNameMap);\n    },\n\n    /**\n     * Create a new DOM text node from the specified value.\n     *\n     * @param data The specified value.\n     * @return The new DOM text instance.\n     */\n    createTextNode: createTextNodeImpl,\n\n    /**\n     * Create a new DOM comment node from the specified value.\n     *\n     * @param data The specified value.\n     * @return The new DOM text instance.\n     */\n    createComment(data: string): Comment {\n        return createCommentImpl(data || '');\n    },\n\n    /**\n     * Instantiate an Event.\n     * @param typeArg The name of the event.\n     * @param eventInitDict A set of options for the event, such as detail and bubbling.\n     */\n    createEvent(typeArg: string, eventInitDict: CustomEventInit<unknown> = {}) {\n        return createEventImpl(typeArg, eventInitDict);\n    },\n\n    /**\n     * Append a child to an element.\n     *\n     * @param parent The parent element.\n     * @param newChild The child to add.\n     * @param slot Should add a slot node.\n     */\n    appendChild<T extends Node>(parent: Node, newChild: T, slot = true): T {\n        const parentNode = newChild.parentNode;\n        if (slot && isComponent(parent) && parent.slotChildNodes) {\n            const slotted = parent.slotChildNodes;\n            const previousIndex = slotted.indexOf(newChild);\n            if (previousIndex !== -1) {\n                slotted.splice(previousIndex, 1);\n            } else if (parentNode) {\n                DOM.removeChild(parentNode, newChild, slot);\n            }\n            parent.slotChildNodes.push(newChild);\n            parent.forceUpdate();\n            return newChild;\n        }\n        if (emulatingLifeCycle() && parentNode) {\n            DOM.removeChild(parentNode, newChild, slot);\n        }\n        appendChildImpl.call(parent, newChild);\n        if (emulatingLifeCycle() && isConnected.call(newChild)) {\n            connect(newChild);\n        }\n        return newChild;\n    },\n\n    /**\n     * Remove a child from an element.\n     *\n     * @param parent The parent element.\n     * @param oldChild The child to remove.\n     * @param slot Should remove a slot node.\n     */\n    removeChild<T extends Node>(parent: Node, oldChild: T, slot = true): T {\n        if (slot && isComponent(parent) && parent.slotChildNodes) {\n            const slotted = parent.slotChildNodes;\n            const io = slotted.indexOf(oldChild);\n            if (io !== -1) {\n                slotted.splice(io, 1);\n                parent.forceUpdate();\n            }\n            return oldChild;\n        }\n        const connected = isConnected.call(oldChild);\n        removeChildImpl.call(parent, oldChild);\n        if (emulatingLifeCycle() && connected) {\n            disconnect(oldChild);\n        }\n        return oldChild;\n    },\n\n    /**\n     * Insert a child before another in an element.\n     *\n     * @param parent The parent element.\n     * @param newChild The child to insert.\n     * @param refChild The referred node.\n     * @param slot Should insert a slot node.\n     */\n    insertBefore<T extends Node>(parent: Node, newChild: T, refChild: Node | null, slot = true): T {\n        const parentNode = newChild.parentNode;\n        if (slot && isComponent(parent) && parent.slotChildNodes) {\n            const slotted = parent.slotChildNodes;\n            const previousIndex = slotted.indexOf(newChild);\n            if (previousIndex !== -1) {\n                slotted.splice(previousIndex, 1);\n            } else if (parentNode) {\n                DOM.removeChild(parentNode, newChild, slot);\n            }\n\n            if (refChild) {\n                const refIndex = slotted.indexOf(refChild);\n                if (refIndex !== -1) {\n                    slotted.splice(refIndex, 0, newChild);\n                }\n            } else {\n                slotted.push(newChild);\n            }\n            parent.forceUpdate();\n            return newChild;\n        }\n        if (emulatingLifeCycle() && parentNode) {\n            DOM.removeChild(parentNode, newChild, slot);\n        }\n        insertBeforeImpl.call(parent, newChild, refChild);\n        if (emulatingLifeCycle() && isConnected.call(newChild)) {\n            connect(newChild);\n        }\n        return newChild;\n    },\n\n    /**\n     * Replace a child with another in an element.\n     *\n     * @param parent The parent element.\n     * @param newChild The child to insert.\n     * @param oldChild The node to replace.\n     * @param slot Should replace a slot node.\n     */\n    replaceChild<T extends Node>(parent: Node, newChild: Node, oldChild: T, slot = true): T {\n        const parentNode = newChild.parentNode;\n        if (slot && isComponent(parent) && parent.slotChildNodes) {\n            const slotted = parent.slotChildNodes;\n            const io = slotted.indexOf(oldChild);\n            slotted.splice(io, 1, newChild);\n            parent.forceUpdate();\n            return oldChild;\n        }\n        if (emulatingLifeCycle()) {\n            if (parentNode && newChild !== oldChild) {\n                DOM.removeChild(parentNode, newChild, slot);\n            }\n            if (isConnected.call(oldChild)) {\n                disconnect(oldChild);\n            }\n        }\n        replaceChildImpl.call(parent, newChild, oldChild);\n        if (emulatingLifeCycle() && isConnected.call(newChild)) {\n            connect(newChild);\n        }\n        return oldChild;\n    },\n\n    /**\n     * Insert a child at the given position.\n     *\n     * @param parent The parent element.\n     * @param postion The position of the insertion.\n     * @param insertedElement The child to insert.\n     * @param slot Should insert a slot node.\n     */\n    insertAdjacentElement(parent: Element, position: InsertPosition, insertedElement: Element, slot = true): Element | null {\n        if (position === 'afterbegin') {\n            const refChild = isComponent(parent) && parent.slotChildNodes ? parent.slotChildNodes[0] : parent.firstChild;\n            return DOM.insertBefore(parent, insertedElement, refChild, slot);\n        }\n        if (position === 'beforeend') {\n            return DOM.insertBefore(parent, insertedElement, null, slot);\n        }\n\n        return insertAdjacentElementImpl.call(parent, position, insertedElement);\n    },\n\n    /**\n     * Get a Component attribute.\n     *\n     * @param element The node element\n     * @param qualifiedName The attribute name\n     */\n    getAttribute(element: Element, qualifiedName: string): string | null {\n        return getAttributeImpl.call(element, qualifiedName);\n    },\n\n    /**\n     * Check if an element has an attribute.\n     *\n     * @param element The node element to check.\n     * @param qualifiedName The attribute name to check.\n     */\n    hasAttribute(element: Element, qualifiedName: string): boolean {\n        return hasAttributeImpl.call(element, qualifiedName);\n    },\n\n    /**\n     * Add/set an attribute to an element.\n     *\n     * @param element The element node to update.\n     * @param qualifiedName The attribute name to add/set.\n     * @param value The value to set.\n     */\n    setAttribute(element: Element, qualifiedName: string, value: string): void {\n        if (shouldEmulateLifeCycle(element)) {\n            const constructor = element.constructor as ComponentConstructor<HTMLElement>;\n            const observedAttributes = constructor.observedAttributes;\n            const observed = observedAttributes && observedAttributes.indexOf(qualifiedName) !== -1;\n            if (!observed) {\n                return setAttributeImpl.call(element, qualifiedName, value);\n            }\n\n            const oldValue = DOM.getAttribute(element, qualifiedName);\n            setAttributeImpl.call(element, qualifiedName, value);\n            (element as ComponentInstance<HTMLElement>).attributeChangedCallback(qualifiedName, oldValue, value);\n            return;\n        }\n        return setAttributeImpl.call(element, qualifiedName, value);\n    },\n\n    /**\n     * Remove an element's attribute.\n     *\n     * @param element The element node to update.\n     * @param qualifiedName The attribute name to remove.\n     */\n    removeAttribute(element: Element, qualifiedName: string): void {\n        if (shouldEmulateLifeCycle(element)) {\n            const constructor = element.constructor as ComponentConstructor<HTMLElement>;\n            const observedAttributes = constructor.observedAttributes;\n            const observed = observedAttributes && observedAttributes.indexOf(qualifiedName) !== -1;\n            if (!observed) {\n                return removeAttributeImpl.call(element, qualifiedName);\n            }\n\n            const oldValue = DOM.getAttribute(element, qualifiedName);\n            removeAttributeImpl.call(element, qualifiedName);\n            (element as ComponentInstance<HTMLElement>).attributeChangedCallback(qualifiedName, oldValue, null);\n        }\n        return removeAttributeImpl.call(element, qualifiedName);\n    },\n};\n", "import type { Constructor, ClassElement, MethodsOf } from './types';\nimport type { ComponentInstance, ComponentConstructor } from './Component';\nimport { createSymbol, HTMLElement, isElement, isEvent, matchesImpl, createEventImpl, hasOwnProperty, getOwnPropertyDescriptor, getPrototypeOf } from './helpers';\n\n/**\n * A Symbol which contains all Node delegation.\n */\nconst EVENT_CALLBACKS_SYMBOL: unique symbol = createSymbol();\n\n/**\n * Async event interface.\n */\nexport type AsyncEvent = Event & {\n    respondWith(callback: () => Promise<unknown>): void;\n};\n\n/**\n * Describe the signature of a delegated event callback.\n * @param event The original DOM event.\n * @param target The matched delegated element.\n */\nexport type DelegatedEventCallback = (event: Event, target?: Node) => unknown;\n\n/**\n * A descriptor for an event delegation.\n */\nexport type DelegatedEventDescriptor = AddEventListenerOptions & {\n    target?: EventTarget;\n    callback: DelegatedEventCallback;\n};\n\n/**\n * Property configuration for properties accessor.\n */\nexport type ListenerConfig = DelegatedEventCallback | DelegatedEventDescriptor;\n\n/**\n * A collector for event delegations.\n */\ntype DelegationList = {\n    /**\n     * A list of delegation descriptors.\n     */\n    descriptors: {\n        /**\n         * The name of the delegated event.\n         */\n        event: string;\n        /**\n         * The selector for the delegated event.\n         */\n        selector: string | null;\n        /**\n         * The event target.\n         */\n        target: EventTarget | null;\n        /**\n         * The callback for the delegated event.\n         */\n        callback?: DelegatedEventCallback;\n    }[];\n\n    /**\n     * The real event listener.\n     */\n    listener: EventListenerOrEventListenerObject;\n}\n\n/**\n * An object with event delegations.\n */\ntype WithEventDelegations = {\n    [EVENT_CALLBACKS_SYMBOL]?: {\n        [key: string]: DelegationList;\n    };\n}\n\nconst assertNode = (element: unknown) => {\n    if (!isElement(element)) {\n        throw new TypeError('The provided element must be a Node');\n    }\n};\n\nconst assertEvent = (event: unknown) => {\n    if (!isEvent(event)) {\n        throw new TypeError('The provided object must be an Event');\n    }\n};\n\nconst assertEventName = (eventName: unknown) => {\n    if (typeof eventName !== 'string') {\n        throw new TypeError('The provided event name must be a string');\n    }\n};\n\nconst assertEventSelector = (selector: unknown) => {\n    if (selector !== null && typeof selector !== 'string') {\n        throw new TypeError('The provided selector must be a string or null');\n    }\n};\n\nconst assertEventCallback = (callback: unknown) => {\n    if (typeof callback !== 'function') {\n        throw new TypeError('The provided callback must be a function');\n    }\n};\n\nconst assertEventBubbles = (bubbles: unknown) => {\n    if (typeof bubbles !== 'boolean') {\n        throw new TypeError('The provided bubbles option must be a boolean');\n    }\n};\n\nconst assertEventCancelable = (cancelable: unknown) => {\n    if (typeof cancelable !== 'boolean') {\n        throw new TypeError('The provided cancelable option must be a boolean');\n    }\n};\n\nconst assertEventComposed = (composed: unknown) => {\n    if (typeof composed !== 'undefined' && typeof composed !== 'boolean') {\n        throw new TypeError('The provided composed option must be a boolean');\n    }\n};\n\n/**\n * Delegate an Event listener.\n *\n * @param element The root element for the delegation\n * @param eventName The event name to listen\n * @param selector The selector to delegate\n * @param callback The callback to trigger when an Event matches the delegation\n * @param options An options object that specifies characteristics about the event listener. @see [MDN]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener}\n */\nexport const delegateEventListener = (element: Element, eventName: string, selector: string|null, callback: DelegatedEventCallback, options?: AddEventListenerOptions) => {\n    const delegatedElement: Node & WithEventDelegations = element;\n\n    assertNode(element);\n    assertEventName(eventName);\n    assertEventSelector(selector);\n    assertEventCallback(callback);\n\n    // get all delegations\n    const delegations = delegatedElement[EVENT_CALLBACKS_SYMBOL] = delegatedElement[EVENT_CALLBACKS_SYMBOL] || {};\n    // initialize the delegation list\n    const callbacks: DelegationList = delegations[eventName] = delegations[eventName] || {\n        descriptors: [],\n    };\n    const descriptors = callbacks.descriptors;\n    // check if the event has already been delegated\n    if (!callbacks.listener) {\n        // setup the listener\n        callbacks.listener = (event) => {\n            if (!event.target) {\n                return;\n            }\n            const eventTarget = event.target as Node;\n            // wrap the Event's stopPropagation in order to prevent other delegations from the same root\n            const originalStopPropagation = event.stopPropagation;\n            const originalImmediatePropagation = event.stopImmediatePropagation;\n            let stopped = false;\n            let stoppedImmediated = false;\n            event.stopPropagation = () => {\n                stopped = true;\n                // exec the real stopPropagation method\n                return originalStopPropagation.call(event);\n            };\n            event.stopImmediatePropagation = () => {\n                stopped = true;\n                stoppedImmediated = true;\n                // exec the real stopPropagation method\n                return originalImmediatePropagation.call(event);\n            };\n\n            // filter matched selector for the event\n            const filtered: { target: Node; callback: DelegatedEventCallback }[] = [];\n            for (let i = 0; i < descriptors.length; i++) {\n                const { selector, callback } = descriptors[i];\n                let selectorTarget;\n                if (selector) {\n                    let target = eventTarget;\n                    while (target && target !== element) {\n                        if (isElement(target) && matchesImpl.call(target, selector)) {\n                            selectorTarget = target;\n                            break;\n                        }\n                        target = target.parentNode as Node;\n                    }\n                } else {\n                    selectorTarget = element;\n                }\n                if (selectorTarget) {\n                    filtered.push({\n                        target: selectorTarget,\n                        callback: callback as DelegatedEventCallback,\n                    });\n                }\n            }\n\n            let lastTarget: Node;\n            filtered\n                // clone the array in order to correctly sort callbacks in old browsers\n                .slice(0)\n                // reorder targets by position in the dom tree.\n                .sort((match1, match2) => {\n                    if (match1.target === match2.target) {\n                        return filtered.indexOf(match1) - filtered.indexOf(match2);\n                    }\n                    return match1.target.contains(match2.target) ? filtered.length : -filtered.length;\n                })\n                // trigger the callback\n                .some(({ callback, target }) => {\n                    if (stoppedImmediated) {\n                        return true;\n                    }\n                    if (stopped && target !== lastTarget) {\n                        return true;\n                    }\n                    lastTarget = target;\n                    return callback.call(element, event, target) === false;\n                });\n        };\n\n        element.addEventListener(eventName, callbacks.listener, options);\n    }\n\n    // add the delegation to the list\n    descriptors.push({ event: eventName, callback, selector, target: null });\n};\n\n/**\n * Remove an Event delegation.\n *\n * @param element The root element of the delegation\n * @param eventName The Event name to undelegate\n * @param selector The selector to undelegate\n * @param callback The callback to remove\n */\nexport const undelegateEventListener = (element: Element, eventName: string, selector: string | null, callback: DelegatedEventCallback) => {\n    assertNode(element);\n    assertEventName(eventName);\n    assertEventSelector(selector);\n    assertEventCallback(callback);\n\n    const delegatedElement: Node & WithEventDelegations = element;\n    // get all delegations\n    const delegations = delegatedElement[EVENT_CALLBACKS_SYMBOL];\n    if (!delegations) {\n        return;\n    }\n    if (!(eventName in delegations)) {\n        return;\n    }\n    const { descriptors, listener } = delegations[eventName];\n    // get the list of delegations\n    // find the index of the callback to remove in the list\n    for (let i = 0; i < descriptors.length; i++) {\n        const descriptor = descriptors[i];\n        if (descriptor.selector === selector && descriptor.callback === callback) {\n            descriptors.splice(i, 1);\n            if (descriptors.length === 0) {\n                element.removeEventListener(eventName, listener);\n            }\n        }\n    }\n};\n\n/**\n * Create custom Event.\n *\n * @param event The event to dispatch or the name of the synthetic event to create.\n * @param detail Detail object of the event.\n * @param bubbles Should the event bubble.\n * @param cancelable Should the event be cancelable.\n * @param composed Is the event composed.\n */\nfunction initEvent(event: Event | string, detail?: CustomEventInit, bubbles?: boolean, cancelable?: boolean, composed?: boolean) {\n    if (typeof event !== 'string') {\n        assertEvent(event);\n        return event;\n    }\n\n    assertEventBubbles(bubbles);\n    assertEventCancelable(cancelable);\n    assertEventComposed(composed);\n\n    return createEventImpl(event, {\n        detail,\n        bubbles,\n        cancelable,\n        composed,\n    });\n}\n\n/**\n * Dispatch a custom Event.\n *\n * @param element The dispatcher node.\n * @param event The event to dispatch or the name of the synthetic event to create.\n * @param detail Detail object of the event.\n * @param bubbles Should the event bubble.\n * @param cancelable Should the event be cancelable.\n * @param composed Is the event composed.\n */\nexport const dispatchEvent = (element: Element, event: Event | string, detail?: CustomEventInit['detail'], bubbles: boolean = true, cancelable: boolean = true, composed: boolean = false): boolean => {\n    assertNode(element);\n    event = initEvent(event, detail, bubbles, cancelable, composed);\n    return HTMLElement.prototype.dispatchEvent.call(element, event);\n};\n\n/**\n * Dispatch an async custom Event.\n *\n * @param element The dispatcher node.\n * @param event The event to dispatch or the name of the synthetic event to create.\n * @param detail Detail object of the event.\n * @param bubbles Should the event bubble.\n * @param cancelable Should the event be cancelable.\n * @param composed Is the event composed.\n */\nexport const dispatchAsyncEvent = async (element: Element, event: Event | string, detail?: CustomEventInit['detail'], bubbles: boolean = true, cancelable: boolean = true, composed: boolean = false): Promise<unknown[]> => {\n    const asyncEvent = initEvent(event, detail, bubbles, cancelable, composed) as unknown as AsyncEvent;\n    const promises: unknown[] = [];\n    asyncEvent.respondWith = function(callback) {\n        promises.push(callback());\n    };\n    if (!dispatchEvent(element, asyncEvent)) {\n        throw new Error('Event has been canceled');\n    }\n    return await Promise.all(promises);\n};\n\n/**\n * A Symbol which contains all listeners instances of a component constructor.\n */\nconst LISTENERS_SYMBOL: unique symbol = createSymbol();\n\n/**\n * An object with listeners.\n */\ntype WithListeners<T> = T & {\n    [LISTENERS_SYMBOL]?: Listener[];\n};\n\n/**\n * The listener interface.\n */\ntype Listener = {\n    event: string;\n    selector: string | null;\n    target: EventTarget | null;\n    callback: DelegatedEventCallback;\n    options?: AddEventListenerOptions;\n};\n\n/**\n * Retrieve all listeners descriptors.\n * @param constructor The component constructor.\n * @return A list of listeners.\n */\nexport const getListeners = (prototype: WithListeners<ComponentInstance<HTMLElement>>) => {\n    const listeners = prototype[LISTENERS_SYMBOL];\n    if (!listeners) {\n        return [];\n    }\n\n    if (!hasOwnProperty.call(prototype, LISTENERS_SYMBOL)) {\n        return listeners.slice(0);\n    }\n\n    return listeners;\n};\n\n/**\n * Add an event listener to the prototype.\n * @param prototype The component prototype.\n * @param eventName The name of the event to listen.\n * @param callback The event callback.\n * @param options The event listener options.\n */\nexport function defineListener(\n    prototype: WithListeners<ComponentInstance<HTMLElement>>,\n    eventName: string,\n    target: EventTarget | null,\n    selector: string | null,\n    callback: DelegatedEventCallback,\n    options: AddEventListenerOptions = {}\n) {\n    const listeners = prototype[LISTENERS_SYMBOL] = getListeners(prototype);\n    listeners.push({\n        event: eventName,\n        selector,\n        callback,\n        target,\n        options,\n    });\n}\n\n/**\n * Define component listeners.\n * @param prototype The component prototype.\n */\nexport const defineListeners = (prototype: ComponentInstance<HTMLElement>) => {\n    const constructor = prototype.constructor as WithListeners<ComponentConstructor<HTMLElement>>;\n    let ctr = constructor;\n    while (ctr && ctr.prototype && ctr !== HTMLElement) {\n        if (hasOwnProperty.call(ctr.prototype, LISTENERS_SYMBOL)) {\n            break;\n        }\n        const listenersDescriptor = getOwnPropertyDescriptor(ctr, 'listeners');\n        const listenersGetter = listenersDescriptor && listenersDescriptor.get;\n        if (listenersGetter) {\n            const listenerDescriptors = (listenersGetter.call(constructor) || {}) as {\n                [key: string]: ListenerConfig;\n            };\n            // register listeners\n            for (const eventPath in listenerDescriptors) {\n                const paths = eventPath.trim().split(' ');\n                const eventName = paths.shift() as string;\n                const selector = paths.length ? paths.join(' ') : null;\n                const descriptor = listenerDescriptors[eventPath];\n                const { callback, target = null, ...options } = typeof descriptor === 'object' ? descriptor : { callback: descriptor };\n                defineListener(prototype, eventName, target, selector, callback, options);\n            }\n        }\n        ctr = getPrototypeOf(ctr);\n    }\n};\n\n/**\n * Add a property observer to a component prototype.\n * @param targetOrClassElement The component prototype.\n * @param propertyKey The property name to watch.\n * @param methodKey The method name.\n */\nexport const createListener = <T extends ComponentInstance<HTMLElement>, P extends MethodsOf<T>>(\n    targetOrClassElement: T,\n    eventName: string,\n    target: EventTarget | null,\n    selector: string | null,\n    options: AddEventListenerOptions,\n    methodKey?: P\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n): any => {\n    if (methodKey !== undefined) {\n        defineListener(targetOrClassElement, eventName, target, selector, targetOrClassElement[methodKey], options);\n        return;\n    }\n\n    const element = targetOrClassElement as unknown as ClassElement;\n    return {\n        ...element,\n        finisher(constructor: Constructor<T>) {\n            defineListener(constructor.prototype, eventName, target, selector, constructor.prototype[element.key as P], options);\n        },\n    };\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isEventTarget = (target: any): target is EventTarget => typeof target === 'object' && 'addEventListener' in target;\n\n/**\n * A decorator for listening DOM events.\n *\n * @param eventName The name of the event to listen.\n * @param options Options to pass to addEventListener.\n * @return The decorator initializer.\n */\nfunction listen(eventName: string, options?: AddEventListenerOptions): Function;\nfunction listen(eventName: string, selector: string, options?: AddEventListenerOptions): Function;\nfunction listen(eventName: string, target: EventTarget, options?: AddEventListenerOptions): Function;\nfunction listen(eventName: string, target?: string | EventTarget | AddEventListenerOptions, options?: AddEventListenerOptions) {\n    return <T extends ComponentInstance<HTMLElement>, P extends MethodsOf<T>>(\n        targetOrClassElement: T,\n        methodKey: P\n    ) => createListener(\n        targetOrClassElement,\n        eventName,\n        isEventTarget(target) ? target : null,\n        typeof target === 'string' ? target : null,\n        (!isEventTarget(target) && typeof target !== 'string' ? target : options) || {},\n        methodKey\n    );\n}\n\nexport { listen };\n", "var n=function(t,s,r,e){var u;s[0]=0;for(var h=1;h<s.length;h++){var p=s[h++],a=s[h]?(s[0]|=p?1:2,r[s[h++]]):s[++h];3===p?e[0]=a:4===p?e[1]=Object.assign(e[1]||{},a):5===p?(e[1]=e[1]||{})[s[++h]]=a:6===p?e[1][s[++h]]+=a+\"\":p?(u=t.apply(a,n(t,a,r,[\"\",null])),e.push(u),a[0]?s[0]|=2:(s[h-2]=0,s[h]=u)):e.push(a)}return e},t=new Map;export default function(s){var r=t.get(this);return r||(r=new Map,t.set(this,r)),(r=n(this,r.get(s)||(r.set(s,r=function(n){for(var t,s,r=1,e=\"\",u=\"\",h=[0],p=function(n){1===r&&(n||(e=e.replace(/^\\s*\\n\\s*|\\s*\\n\\s*$/g,\"\")))?h.push(0,n,e):3===r&&(n||e)?(h.push(3,n,e),r=2):2===r&&\"...\"===e&&n?h.push(4,n,0):2===r&&e&&!n?h.push(5,0,!0,e):r>=5&&((e||!n&&5===r)&&(h.push(r,0,e,s),r=6),n&&(h.push(r,n,0,s),r=6)),e=\"\"},a=0;a<n.length;a++){a&&(1===r&&p(),p(a));for(var l=0;l<n[a].length;l++)t=n[a][l],1===r?\"<\"===t?(p(),h=[h],r=3):e+=t:4===r?\"--\"===e&&\">\"===t?(r=1,e=\"\"):e=t+e[0]:u?t===u?u=\"\":e+=t:'\"'===t||\"'\"===t?u=t:\">\"===t?(p(),r=1):r&&(\"=\"===t?(r=5,s=e,e=\"\"):\"/\"===t&&(r<5||\">\"===n[a][l+1])?(p(),3===r&&(h=h[0]),r=h,(h=h[0]).push(2,0,r),r=0):\" \"===t||\"\\t\"===t||\"\\n\"===t||\"\\r\"===t?(p(),r=2):e+=t),3===r&&\"!--\"===e&&(r=4,h=h[0])}return p(),h}(s)),r),arguments,[])).length>1?r:r[0]}\n", "import { createSymbol } from './helpers';\n\n/**\n * A Symbol which contains Thenable state.\n */\nconst THENABLE_SYMBOL: unique symbol = createSymbol();\n\ntype WithThenableState<T> = T & {\n    [THENABLE_SYMBOL]?: ThenableState;\n};\n\n/**\n * An object representing the status of a Thenable.\n */\nexport type ThenableState = {\n    pending: boolean;\n    result?: unknown;\n};\n\n/**\n * Check if the target is a Thenable (has the `then` method).\n * @param target The object to check.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isThenable = (target: any): target is Promise<any> => typeof target.then === 'function';\n\n/**\n * Get or inject a state into a Thenable object.\n * @param target The Thenable to extend.\n * @return The Thenable state instance.\n */\nexport const getThenableState = (target: WithThenableState<Promise<unknown>>): ThenableState => {\n    const state = target[THENABLE_SYMBOL];\n    if (state) {\n        return state;\n    }\n\n    const newState = target[THENABLE_SYMBOL] = {\n        pending: true,\n    } as ThenableState;\n    target\n        .then((result: unknown) => {\n            newState.result = result;\n            newState.pending = false;\n        })\n        .catch((error: unknown) => {\n            newState.result = error;\n            newState.pending = false;\n        });\n\n    return newState;\n};\n", "import { createSymbol } from './helpers';\n\n/**\n * Subscription-like minimal interface.\n */\nexport type Subscription = {\n    unsubscribe(): void;\n};\n\n/**\n * Observable-like minimal interface.\n */\nexport type Observable<T> = {\n    pipe(operator: (value: T) => unknown): Observable<T>;\n    subscribe(nextCallback: (value: T) => unknown, errorCallback: (error: Error) => unknown, completeCallback: () => unknown): Subscription;\n};\n\n/**\n * A Symbol which contains Subscription state.\n */\nconst SUBSCRIPTION_SYMBOL: unique symbol = createSymbol();\n\ntype WithObservableState<T> = T & {\n    [SUBSCRIPTION_SYMBOL]?: ObservableState;\n};\n\n/**\n * An object representing the status of a Subscribable.\n */\nexport type ObservableState = {\n    complete: boolean;\n    errored: boolean;\n    current?: unknown;\n};\n\n/**\n * Check if the target is a Subscribable (has the `subscribe` method).\n * @param target The object to check.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isObservable = (target: any): target is Observable<unknown> => typeof target['subscribe'] === 'function';\n\n/**\n * Get or inject a state into a Subscribable object.\n * @param target The Subscribable to extend.\n * @return The Subscribable state instance.\n */\nexport const getObservableState = <T extends Observable<unknown>>(target: WithObservableState<T>): ObservableState => {\n    const state = target[SUBSCRIPTION_SYMBOL];\n    if (state) {\n        return state;\n    }\n    const newState = target[SUBSCRIPTION_SYMBOL] = {\n        complete: false,\n        errored: false,\n    } as ObservableState;\n    target\n        .subscribe((value) => {\n            newState.current = value;\n            newState.errored = false;\n        }, (error) => {\n            newState.current = error;\n            newState.errored = true;\n        }, () => {\n            newState.complete = true;\n        });\n\n    return newState;\n};\n", "/**\n * A cache for scoped CSS.\n */\nconst CACHE: {\n    [key: string]: {\n        [key: string]: string;\n    };\n} = {};\n\n/**\n * Match all `:host` selectors in a CSS string.\n */\nconst HOST_REGEX = /:host(\\(([^({)]+(\\([^)]*\\))?)+\\))?/g;\n\n/**\n * Match all comments in a CSS string.\n */\nconst CSS_COMMENTS_REGEX = /\\s*\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\/\\s*/g;\n\n/**\n * Match all css selectors in a CSS string.\n */\nconst CSS_SELECTORS_REGEX = /(#|\\*|\\.|@|\\[|[a-zA-Z])([^{;}]*){/g;\n\n/**\n * Scope a CSS string, adding a compnent-specific trailing selector to all rules.\n * It also converts `:host` selectors for cross browser compatibility.\n *\n * @param name The component definition name.\n * @param cssText The CSS string.\n * @param extend The builtin element.\n * @return A scoped CSS string.\n */\nexport const css = (name: string, cssText: string, extend?: string): string => {\n    if (typeof name !== 'string') {\n        throw new TypeError('The provided name must be a string');\n    }\n    if (typeof cssText !== 'string') {\n        throw new TypeError('The provided CSS text must be a string');\n    }\n\n    const cached = CACHE[name] = CACHE[name] || {};\n    const scope = extend && extend !== name ? `${extend}[is=\"${name}\"]` : name;\n    if (cssText in cached) {\n        return cached[cssText];\n    }\n    return cached[cssText] = cssText\n        .replace(CSS_COMMENTS_REGEX, '\\n')\n        .replace(HOST_REGEX, (fullMatch, mod) => `${scope}${mod ? mod.slice(1, -1).replace(':defined', '[:defined]') : ''}`)\n        .replace(CSS_SELECTORS_REGEX, (match) => {\n            match = match.trim();\n            if (match[0] === '@') {\n                return match;\n            }\n            return match\n                .split(',')\n                .map((selector) => {\n                    selector = selector.trim();\n                    if (selector.indexOf(scope) === 0) {\n                        return selector;\n                    }\n                    return `${scope} ${selector}`;\n                })\n                .join(',');\n        });\n};\n", "import type { TagNameMap, IterableNodeList, Writable, WritableOf } from './types';\nimport type { CustomElement, CustomElementConstructor } from './CustomElementRegistry';\nimport type { Observable } from './Observable';\nimport type { ComponentInstance } from './Component';\nimport htm from 'htm';\nimport { createSymbol, isNode, isElement, isArray, isText, indexOf, cloneChildNodes } from './helpers';\nimport { isComponent } from './Component';\nimport { customElements, isCustomElementConstructor } from './CustomElementRegistry';\nimport { DOM } from './DOM';\nimport { isThenable, getThenableState } from './Thenable';\nimport { isObservable, getObservableState } from './Observable';\nimport { css } from './css';\nimport { getProperty } from './property';\n\nconst innerHtml = htm.bind(h);\n\n/**\n * Compile a string into virtual DOM template.\n *\n * @return The virtual DOM template.\n */\nexport const compile = (string: string): Template => {\n    const array = [string] as string[] & { raw?: string[] };\n    array.raw = [string];\n    return innerHtml(array as unknown as TemplateStringsArray);\n};\n\n/**\n * Compile a template string into virtual DOM template.\n *\n * @return The virtual DOM template.\n */\nfunction html(string: TemplateStringsArray, ...values: unknown[]): Template;\n/**\n * @deprecated use compile function instead.\n */\nfunction html(string: string): Template;\nfunction html(string: string | TemplateStringsArray, ...values: unknown[]): Template {\n    if (typeof string === 'string') {\n        return compile(string);\n    }\n    return innerHtml(string, ...values);\n}\n\nexport { html };\n\n/**\n * A generic template. Can be a single atomic item or a list of items.\n */\nexport type Template =\n    Element |\n    Text |\n    Node |\n    HyperFragment |\n    HyperFunction |\n    HyperComponent<CustomElementConstructor<HTMLElement>> |\n    HyperNode<Node> |\n    HyperSlot |\n    HyperTag<keyof TagNameMap> |\n    Promise<unknown> |\n    Observable<unknown> |\n    string |\n    number |\n    boolean |\n    undefined |\n    null |\n    Template[];\n\n/**\n* A filter function signature for template items.\n*\n* @param item The template item to check.\n* @return A truthy value for valid items, a falsy for value for invalid ones.\n*/\nexport type Filter = (item: Node) => boolean;\n\n/**\n * A re-render function.\n */\nexport type UpdateRequest = () => boolean;\n\n/**\n * A function that returns a template.\n *\n * @param props A set of properties with children.\n * @param context The current render context.\n * @return A template.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type FunctionComponent<P = any> = (\n    props: P,\n    context: Context<Node, UpdateRequest, P>,\n    /**\n     * @deprecated Use context.requestUpdate method.\n     */\n    requestUpdate: UpdateRequest,\n    /**\n     * @deprecated Use the returned value of the context.requestUpdate method.\n     */\n    isAttached: () => boolean,\n    /**\n     * @deprecated Use context.\n     */\n    sameContext: Context<Node, UpdateRequest, P>\n) => Template;\n\n/**\n * Identify hyper objects.\n */\nexport const HYPER_OBJECT_SYM: unique symbol = createSymbol();\n\n/**\n * A constructor alias used for JSX fragments </>.\n */\nexport const Fragment: unique symbol = createSymbol();\n\n/**\n * Classes dictionary.\n */\nexport type HyperClasses = string | { [key: string]: boolean };\n\n/**\n * Styles dictionary.\n */\nexport type HyperStyle = string | { [key: string]: string };\n\n/**\n * Properties used by the render engine.\n * They can be assigned to a node but they are not part of the node prototype.\n */\nexport type HyperProperties = {\n    is?: string;\n    slot?: string;\n    key?: unknown;\n    xmlns?: string;\n    children?: Template[];\n    class?: HyperClasses;\n    style?: HyperStyle;\n};\n\n/**\n * The interface of a JSX fragment node.\n */\nexport type HyperFragment = {\n    Function?: undefined;\n    Component?: undefined;\n    node?: undefined;\n    tag?: undefined;\n    isFragment: true;\n    isSlot?: false;\n    key?: unknown;\n    properties?: {};\n    children: Template[];\n    [HYPER_OBJECT_SYM]: true;\n};\n\n/**\n * The interface of a functional component.\n */\nexport type HyperFunction = {\n    Function: FunctionComponent;\n    Component?: undefined;\n    node?: undefined;\n    tag?: undefined;\n    isFragment?: false;\n    isSlot?: false;\n    key?: unknown;\n    namespaceURI?: string;\n    properties: HyperProperties;\n    children: Template[];\n    [HYPER_OBJECT_SYM]: true;\n};\n\n/**\n * The interface of an HTML node used as JSX tag.\n */\nexport type HyperNode<T extends Node> = {\n    Function?: undefined;\n    Component?: undefined;\n    node: T;\n    tag?: undefined;\n    isFragment?: false;\n    isSlot?: false;\n    key?: unknown;\n    namespaceURI?: string;\n    properties: Writable<T> & HyperProperties;\n    children: Template[];\n    [HYPER_OBJECT_SYM]: true;\n};\n\n/**\n * The interface of a Component constructor used as JSX tag.\n */\nexport type HyperComponent<T extends CustomElementConstructor<HTMLElement>> = {\n    Function?: undefined;\n    Component: T;\n    node?: undefined;\n    tag?: undefined;\n    isFragment?: false;\n    isSlot?: false;\n    key?: unknown;\n    namespaceURI?: string;\n    properties: Writable<InstanceType<T>> & HyperProperties;\n    children: Template[];\n    [HYPER_OBJECT_SYM]: true;\n};\n\n/**\n * The interface of slot element.\n */\nexport type HyperSlot = {\n    Function?: undefined;\n    Component?: undefined;\n    node?: undefined;\n    tag: 'slot';\n    isFragment?: false;\n    isSlot: true;\n    key?: unknown;\n    properties: Writable<HTMLElementTagNameMap['slot']> & HyperProperties;\n    children: Template[];\n    [HYPER_OBJECT_SYM]: true;\n};\n\n/**\n * The interface of a generic JSX tag.\n */\nexport type HyperTag<T extends keyof TagNameMap> = {\n    Function?: undefined;\n    Component?: undefined;\n    node?: undefined;\n    tag: T;\n    isFragment?: false;\n    isSlot?: false;\n    key?: unknown;\n    namespaceURI?: string;\n    properties: Writable<TagNameMap[T]> & HyperProperties;\n    children: Template[];\n    [HYPER_OBJECT_SYM]: true;\n};\n\n/**\n * Generic hyper object.\n */\nexport type HyperObject = HyperFragment | HyperFunction | HyperComponent<CustomElementConstructor<HTMLElement>> | HyperNode<Node> | HyperSlot | HyperTag<keyof TagNameMap>;\n\n/**\n * Check if the current virtual node is a fragment.\n * @param target The node to check.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isHyperObject = (target: any): target is HyperObject => typeof target === 'object' && !!target[HYPER_OBJECT_SYM];\n\n/**\n * Check if the current virtual node is a fragment.\n * @param target The node to check.\n */\nexport const isHyperFragment = (target: HyperObject): target is HyperFragment => !!target.isFragment;\n\n/**\n * Check if the current virtual node is a functional component.\n * @param target The node to check.\n */\nexport const isHyperFunction = (target: HyperObject): target is HyperFunction => !!target.Function;\n\n/**\n * Check if the current virtual node is a Component.\n * @param target The node to check.\n */\nexport const isHyperComponent = (target: HyperObject): target is HyperComponent<CustomElementConstructor<HTMLElement>> => !!target.Component;\n\n/**\n * Check if the current virtual node is an HTML node instance.\n * @param target The node to check.\n */\nexport const isHyperNode = (target: HyperObject): target is HyperNode<Node> => !!target.node;\n\n/**\n * Check if the current virtual node is a slot element.\n * @param target The node to check.\n */\nexport const isHyperSlot = (target: HyperObject): target is HyperSlot => !!target.isSlot;\n\n/**\n * Check if the current virtual node is a generic tag to render.\n * @param target The node to check.\n */\nexport const isHyperTag = (target: HyperObject): target is HyperTag<'div'> => !!target.tag;\n\n\n/**\n * HyperFunction factory to use as JSX pragma.\n *\n * @param tagOrComponent The tag name, the constructor or the instance of the node.\n * @param properties The set of properties of the Node.\n * @param children The children of the Node.\n */\nfunction h(tagOrComponent: typeof Fragment, properties: null, ...children: Template[]): HyperFragment;\nfunction h<T extends FunctionComponent>(tagOrComponent: T, properties: HyperProperties | null, ...children: Template[]): HyperFunction;\nfunction h<T extends CustomElementConstructor<HTMLElement>>(tagOrComponent: T, properties: Writable<InstanceType<T>> & HyperProperties | null, ...children: Template[]): HyperComponent<T>;\nfunction h<T extends Node>(tagOrComponent: T, properties: Writable<T> & HyperProperties | null, ...children: Template[]): HyperNode<T>;\nfunction h(tagOrComponent: 'slot', properties: Writable<HTMLSlotElement> & HyperProperties | null, ...children: Template[]): HyperSlot;\nfunction h<T extends keyof TagNameMap>(tagOrComponent: T, properties: Writable<TagNameMap[T]> & HyperProperties | null, ...children: Template[]): HyperTag<T>;\nfunction h(tagOrComponent: typeof Fragment | FunctionComponent | CustomElementConstructor<HTMLElement> | Node | keyof TagNameMap, properties: HyperProperties | null = null, ...children: Template[]) {\n    const { is, key, xmlns } = (properties || {});\n\n    if (tagOrComponent === Fragment) {\n        return {\n            isFragment: true,\n            children,\n            [HYPER_OBJECT_SYM]: true,\n        } as HyperFragment;\n    }\n\n    if (isNode(tagOrComponent)) {\n        return {\n            node: tagOrComponent,\n            key,\n            namespaceURI: xmlns,\n            properties: properties || {},\n            children,\n            [HYPER_OBJECT_SYM]: true,\n        } as HyperNode<typeof tagOrComponent>;\n    }\n\n    if (typeof tagOrComponent === 'string') {\n        if (tagOrComponent === 'svg') {\n            return {\n                tag: tagOrComponent,\n                key,\n                namespaceURI: 'http://www.w3.org/2000/svg',\n                properties,\n                children,\n                [HYPER_OBJECT_SYM]: true,\n            };\n        }\n\n        if (tagOrComponent === 'slot') {\n            return {\n                tag: tagOrComponent,\n                isSlot: true,\n                key,\n                properties: properties || {},\n                children,\n                [HYPER_OBJECT_SYM]: true,\n            } as HyperSlot;\n        }\n\n        const Component = customElements.get(is || tagOrComponent);\n        if (Component) {\n            return {\n                Component,\n                key,\n                namespaceURI: xmlns,\n                properties: properties || {},\n                children,\n                [HYPER_OBJECT_SYM]: true,\n            } as HyperComponent<typeof Component>;\n        }\n\n        return {\n            tag: tagOrComponent as keyof TagNameMap,\n            key,\n            namespaceURI: xmlns,\n            properties: properties || {},\n            children,\n            [HYPER_OBJECT_SYM]: true,\n        } as HyperTag<typeof tagOrComponent>;\n    }\n\n    if (isCustomElementConstructor(tagOrComponent)) {\n        return {\n            Component: tagOrComponent,\n            key,\n            namespaceURI: xmlns,\n            properties: properties || {},\n            children,\n            [HYPER_OBJECT_SYM]: true,\n        } as HyperComponent<typeof tagOrComponent>;\n    }\n\n    return {\n        Function: tagOrComponent,\n        key,\n        namespaceURI: xmlns,\n        properties: properties || {},\n        children,\n        [HYPER_OBJECT_SYM]: true,\n    } as HyperFunction;\n}\n\nexport { h };\n\n/**\n * A symbol for node context.\n */\nconst CONTEXT_SYMBOL: unique symbol = createSymbol();\n\nexport type WithContext<T extends Node, F extends UpdateRequest | undefined> = T & {\n    [CONTEXT_SYMBOL]?: Context<T, F>;\n};\n\n/**\n * The node context interface.\n */\nexport type Context<\n    T extends Node = Node,\n    F extends UpdateRequest | undefined = UpdateRequest | undefined,\n    P = Writable<T>,\n    S = Map<string, unknown>\n> = {\n    node: T;\n    isElement?: boolean;\n    isText?: boolean;\n    tagName?: string;\n    is?: string;\n    key?: unknown;\n    properties: [\n        WeakMap<Context<T, UpdateRequest | undefined, P>, P & HyperProperties>,\n        WeakMap<Context<T, UpdateRequest | undefined, P>, P & HyperProperties>,\n    ];\n    store: S;\n    childNodes?: IterableNodeList;\n    slotChildNodes?: IterableNodeList;\n    Function?: FunctionComponent<P>;\n    start?: Node;\n    end?: Node;\n    fragments: Context[];\n    parent?: Context;\n    root?: Context;\n    requestUpdate: F;\n    __proto__: {\n        readonly size: number;\n        has: Map<string, unknown>['has'];\n        get: Map<string, unknown>['get'];\n        set: Map<string, unknown>['set'];\n        delete: Map<string, unknown>['delete'];\n        clear: Map<string, unknown>['clear'];\n        forEach: Map<string, unknown>['forEach'];\n    };\n};\n\n/**\n * Attach a context to an object.\n * @param target The object to context.\n * @param context The context to set.\n */\nexport const setContext = <T extends Node, F extends UpdateRequest | undefined = undefined>(target: WithContext<T, F>, context: Context<T, F>): Context<T, F> => target[CONTEXT_SYMBOL] = context;\n\n/**\n * Create a node context.\n * @param node The node scope of the context.\n * @return A context object for the node.\n */\nexport const createContext = <\n    T extends Node,\n    F extends UpdateRequest | undefined\n>(node: T, requestUpdate?: F) => {\n    const isElementNode = isElement(node);\n    const isTextNode = !isElementNode && isText(node);\n    const is = (node as unknown as CustomElement<HTMLElement>).is;\n    const store = new Map() as Map<string, unknown>;\n    return setContext(node, {\n        node,\n        isElement: isElementNode,\n        isText: isTextNode,\n        tagName: isElementNode ? (node as unknown as HTMLElement).tagName.toLowerCase() : undefined,\n        childNodes: isElementNode ? node.childNodes as unknown as IterableNodeList : undefined,\n        is,\n        properties: [new WeakMap(), new WeakMap()],\n        store,\n        fragments: [],\n        requestUpdate,\n        __proto__: {\n            get size() {\n                return store.size;\n            },\n            has: store.has.bind(store),\n            get: store.get.bind(store),\n            set: store.set.bind(store),\n            delete: store.delete.bind(store),\n            clear: store.clear.bind(store),\n            forEach: store.forEach.bind(store),\n        },\n    }) as Context<T, F extends UpdateRequest ? UpdateRequest : undefined>;\n};\n\n/**\n * Get the context attached to an object.\n * @param target The scope of the context.\n * @return The context object (if it exists).\n */\nexport const getOrCreateContext = <\n    T extends Node,\n    F extends UpdateRequest | undefined\n>(target: WithContext<T, F>, requestUpdate?: F) => (target[CONTEXT_SYMBOL] || createContext(target, requestUpdate)) as Context<T, F extends UpdateRequest ? UpdateRequest : undefined>;\n\n/**\n * Cleanup child fragments of a context.\n * @param context The fragment to empty.\n */\nexport const emptyFragments = <T extends Node>(context: Context<T>) => {\n    const fragments = context.fragments;\n    let len = fragments.length;\n    while (len--) {\n        emptyFragments(fragments.pop() as Context);\n    }\n    return fragments;\n};\n\n/**\n * A cache for converted class values.\n */\nconst CLASSES_CACHE: { [key: string]: string[] } = {};\n\n/**\n * Convert strings or classes map to a list of classes.\n * @param value The value to convert.\n * @return A list of classes.\n */\nconst convertClasses = (value: HyperClasses | null | undefined) => {\n    const classes: string[] = [];\n    if (!value) {\n        return classes;\n    }\n    if (typeof value === 'object') {\n        for (const k in value) {\n            if (value[k]) {\n                classes.push(k);\n            }\n        }\n        return classes;\n    }\n    return CLASSES_CACHE[value] = CLASSES_CACHE[value] || value.toString().trim().split(' ');\n};\n\n/**\n * A cache for converted style values.\n */\nconst STYLES_CACHE: { [key: string]: { [key: string]: string } } = {};\n\n/**\n * Convert strings or styles map to a list of styles.\n * @param value The value to convert.\n * @return A set of styles.\n */\nconst convertStyles = (value: HyperStyle| null | undefined) => {\n    const styles: { [key: string]: string } = {};\n    if (!value) {\n        return styles;\n    }\n    if (typeof value === 'object') {\n        for (const propertyKey in value) {\n            const camelName = propertyKey.replace(/[A-Z]/g, (match: string) =>\n                `-${match.toLowerCase()}`\n            );\n            styles[camelName] = value[propertyKey];\n        }\n        return styles;\n    }\n    return STYLES_CACHE[value] = STYLES_CACHE[value] || value\n        .toString()\n        .split(';')\n        .reduce((ruleMap: { [key: string]: string }, ruleString: string) => {\n            const rulePair = ruleString.split(':');\n            if (rulePair.length > 1) {\n                ruleMap[(rulePair.shift() as string).trim()] = rulePair.join(':').trim();\n            }\n            return ruleMap;\n        }, styles);\n};\n\n/**\n * Check if the render engine is handling input values.\n * @param element The current node element.\n * @param propertyKey The changed property key.\n */\nconst isRenderingInput = (element: HTMLElement, propertyKey: string): element is HTMLInputElement =>\n    (propertyKey === 'checked' || propertyKey === 'value') &&\n    element.tagName === 'INPUT';\n\n/**\n * Add missing keys to properties object.\n * @param previous The previous object.\n * @param actual The actual one.\n */\nconst fillEmptyValues = <T extends {}>(previous: T, actual: { [key: string]: unknown }) => {\n    for (const key in previous) {\n        if (!(key in actual)) {\n            actual[key] = undefined;\n        }\n    }\n\n    return actual as unknown as T;\n};\n\n/**\n * Set a value to an HTML element.\n * @param element The node to update.\n * @param propertyKey The key to update.\n * @param value The value to set.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst setValue = <T extends HTMLElement>(element: T, propertyKey: WritableOf<T>, value: any) => {\n    element[propertyKey] = value;\n};\n\n/**\n * Render a set of Nodes into another, with some checks for Nodes in order to avoid\n * useless changes in the tree and to mantain or update the state of compatible Nodes.\n *\n * @param root The root Node for the render.\n * @param input The child (or the children) to render in Virtual DOM format or already generated.\n * @param slot Should handle slot children.\n * @param context The render context of the root.\n * @param namespace The current namespace uri of the render.\n * @param rootContext The current custom element context of the render.\n * @param refContext The main context of the render.\n * @param fragment The fragment context to update.\n * @return The resulting child nodes list.\n */\nexport const internalRender = (\n    root: Node,\n    input: Template,\n    slot = isComponent(root),\n    context?: Context,\n    namespace = root.namespaceURI || 'http://www.w3.org/1999/xhtml',\n    rootContext?: Context,\n    mainContext?: Context,\n    fragment?: Context\n) => {\n    let renderContext = context || getOrCreateContext(root);\n    const refContext = mainContext || renderContext;\n\n    let childNodes: IterableNodeList;\n    if (slot && renderContext.slotChildNodes) {\n        childNodes = renderContext.slotChildNodes as IterableNodeList;\n    } else {\n        childNodes = renderContext.childNodes || (root.childNodes as unknown as IterableNodeList);\n        if (renderContext.is) {\n            rootContext = renderContext;\n        }\n    }\n    if (!childNodes) {\n        return childNodes;\n    }\n\n    let currentIndex: number;\n    let currentFragment = fragment;\n    let lastNode: Node|undefined;\n    if (fragment) {\n        currentIndex = indexOf.call(childNodes, fragment.start as Node);\n        lastNode = fragment.end as Node;\n    } else {\n        emptyFragments(renderContext);\n        currentIndex = 0;\n    }\n    let currentNode = childNodes.item(currentIndex) as Node;\n    let currentContext = currentNode ? getOrCreateContext(currentNode) : null;\n\n    const handleItems = (template: Template, filter?: Filter) => {\n        if (template == null || template === false) {\n            return;\n        }\n\n        if (isArray(template)) {\n            // call the render function for each child\n            for (let i = 0, len = template.length; i < len; i++) {\n                handleItems(template[i], filter);\n            }\n            return;\n        }\n\n        let templateNode;\n        let templateContext: Context | undefined;\n        let templateChildren: Template[] | undefined;\n        let templateNamespace = namespace;\n\n        if (isHyperObject(template)) {\n            if (isHyperFragment(template)) {\n                handleItems(template.children, filter);\n                return;\n            }\n\n            if (isHyperFunction(template)) {\n                const { Function, properties, children } = template;\n                const rootFragment = fragment;\n                const previousContext = renderContext;\n                const previousFragment = currentFragment;\n                const fragments = renderContext.fragments;\n                let placeholder: Node;\n                if (fragment) {\n                    placeholder = fragment.start as Node;\n                } else if (currentContext && currentContext.Function === Function) {\n                    placeholder = currentContext.start as Node;\n                } else {\n                    placeholder = DOM.createComment(Function.name);\n                }\n\n                const renderFragmentContext = getOrCreateContext(placeholder, () => {\n                    if (fragments.indexOf(renderFragmentContext) === -1) {\n                        return false;\n                    }\n                    internalRender(root, template, slot, previousContext, namespace, rootContext, refContext, renderFragmentContext);\n                    return true;\n                });\n                emptyFragments(renderFragmentContext);\n                renderFragmentContext.Function = Function;\n                renderFragmentContext.start = placeholder;\n                renderContext = renderFragmentContext;\n                currentFragment = renderFragmentContext;\n                fragment = undefined;\n\n                handleItems(\n                    [\n                        placeholder,\n                        Function(\n                            {\n                                children,\n                                ...properties,\n                            },\n                            renderFragmentContext,\n                            renderFragmentContext.requestUpdate.bind(renderFragmentContext),\n                            () => fragments.indexOf(renderFragmentContext) !== -1,\n                            renderFragmentContext\n                        ),\n                    ],\n                    filter\n                );\n\n                fragment = rootFragment;\n                renderFragmentContext.end = childNodes.item(currentIndex - 1) as Node;\n                renderContext = previousContext;\n                currentFragment = previousFragment;\n\n                if (!fragment) {\n                    fragments.push(renderFragmentContext);\n                } else {\n                    fragments.splice(fragments.indexOf(fragment), 1, renderFragmentContext);\n                    fragment = renderFragmentContext;\n                }\n                return;\n            }\n\n            // if the current patch is a slot,\n            if (isHyperSlot(template)) {\n                if (rootContext) {\n                    const { properties, children } = template;\n                    const slotChildNodes = rootContext.slotChildNodes;\n                    if (slotChildNodes) {\n                        for (let i = 0, len = slotChildNodes.length; i < len; i++) {\n                            const node = slotChildNodes.item(i) as Node;\n                            const context = getOrCreateContext(node);\n                            if (!context.root) {\n                                context.root = rootContext;\n                            }\n                        }\n                    }\n\n                    const name = properties.name;\n                    const filter = (item: Node) => {\n                        if (getOrCreateContext(item).root === rootContext) {\n                            if (isElement(item)) {\n                                if (!name) {\n                                    return !item.getAttribute('slot');\n                                }\n\n                                return item.getAttribute('slot') === name;\n                            }\n                        }\n\n                        return !name;\n                    };\n\n                    handleItems(slotChildNodes || [], filter);\n                    if (!childNodes.length) {\n                        handleItems(children);\n                    }\n                }\n                return;\n            }\n\n            const { key, children, namespaceURI } = template;\n            if (isHyperNode(template)) {\n                templateNode = template.node;\n            } else {\n                templateNamespace = namespaceURI || namespace;\n\n                checkKey: if (currentContext) {\n                    let currentKey = currentContext.key;\n                    if (currentKey != null && key != null && key !== currentKey) {\n                        DOM.removeChild(root, currentNode, slot);\n                        currentNode = childNodes.item(currentIndex) as Node;\n                        currentContext = currentNode ? getOrCreateContext(currentNode) : null;\n                        if (!currentContext) {\n                            break checkKey;\n                        }\n                        currentKey = currentContext.key;\n                    }\n\n                    if (currentFragment && currentNode) {\n                        const io = indexOf.call(childNodes, currentNode);\n                        const lastIo = indexOf.call(childNodes, currentFragment.end);\n                        if (io !== -1 && io > lastIo) {\n                            break checkKey;\n                        }\n                    }\n\n                    if (key != null || currentKey != null) {\n                        if (key === currentKey) {\n                            templateNode = currentNode;\n                            templateContext = currentContext;\n                        }\n                    } else if (isHyperComponent(template) && currentNode instanceof template.Component) {\n                        templateNode = currentNode;\n                        templateContext = currentContext;\n                    } else if (isHyperTag(template) && currentContext.tagName === template.tag) {\n                        templateNode = currentNode;\n                        templateContext = currentContext;\n                    }\n                }\n\n                if (!templateNode) {\n                    if (isHyperComponent(template)) {\n                        templateNode = new template.Component();\n                    } else {\n                        templateNode = DOM.createElementNS(templateNamespace, template.tag);\n                    }\n                }\n            }\n\n            // update the Node properties\n            const templateElement = templateNode as HTMLElement;\n\n            templateContext = templateContext || getOrCreateContext(templateNode);\n            const map = templateContext.properties[slot ? 1 : 0];\n            const oldProperties = (map.get(refContext) || {}) as Writable<HTMLElement> & HyperProperties;\n            const properties = fillEmptyValues(oldProperties, template.properties);\n            map.set(refContext, properties);\n            if (key != null) {\n                templateContext.key = key;\n            }\n\n            let propertyKey: keyof typeof properties;\n            for (propertyKey in properties) {\n                if (propertyKey === 'is' || propertyKey === 'key' || propertyKey === 'children' || propertyKey === 'xmlns') {\n                    continue;\n                }\n                const value = properties[propertyKey];\n                const oldValue = oldProperties[propertyKey];\n                if (oldValue === value) {\n                    if (isRenderingInput(templateElement, propertyKey)) {\n                        setValue(templateElement, propertyKey as unknown as 'value', value);\n                    }\n                    continue;\n                }\n\n                if (propertyKey === 'style') {\n                    const style = templateElement.style;\n                    const oldStyles = convertStyles(oldProperties.style);\n                    const newStyles = convertStyles(properties.style);\n                    for (const propertyKey in oldStyles) {\n                        if (!(propertyKey in newStyles)) {\n                            style.removeProperty(propertyKey);\n                        }\n                    }\n                    for (const propertyKey in newStyles) {\n                        style.setProperty(propertyKey, newStyles[propertyKey]);\n                    }\n                    continue;\n                } else if (propertyKey === 'class') {\n                    const classList = templateElement.classList;\n                    const newClasses = convertClasses(properties.class);\n                    if (oldValue) {\n                        const oldClasses = convertClasses(oldProperties.class);\n                        for (let i = 0, len = oldClasses.length; i < len; i++) {\n                            const className = oldClasses[i];\n                            if (newClasses.indexOf(className) === -1) {\n                                classList.remove(className);\n                            }\n                        }\n                    }\n                    for (let i = 0, len = newClasses.length; i < len; i++) {\n                        const className = newClasses[i];\n                        if (!classList.contains(className)) {\n                            classList.add(className);\n                        }\n                    }\n                    continue;\n                } else if (propertyKey[0] === 'o' && propertyKey[1] === 'n' && !(propertyKey in templateElement.constructor.prototype)) {\n                    const eventName = propertyKey.substr(2);\n                    if (oldValue) {\n                        templateElement.removeEventListener(eventName, oldValue as EventListener);\n                    }\n                    if (value) {\n                        templateElement.addEventListener(eventName, value as EventListener);\n                    }\n                    continue;\n                }\n\n                const type = typeof value;\n                const wasType = typeof oldValue;\n                const isReference = (value && type === 'object') || type === 'function';\n                const wasReference = (oldValue && wasType === 'object') || wasType === 'function';\n\n                if (isReference || wasReference || isRenderingInput(templateElement, propertyKey)) {\n                    setValue(templateElement, propertyKey, value);\n                } else if (isHyperComponent(template)) {\n                    const Component = template.Component;\n                    if (type === 'string') {\n                        const observedAttributes = Component.observedAttributes;\n                        if (!observedAttributes || observedAttributes.indexOf(propertyKey) === -1) {\n                            setValue(templateElement, propertyKey, value);\n                        } else {\n                            const property = getProperty(Component.prototype as ComponentInstance<HTMLElement>, propertyKey);\n                            if (property && property.fromAttribute) {\n                                setValue(templateElement, propertyKey, property.fromAttribute(value as string));\n                            }\n                        }\n                    } else {\n                        setValue(templateElement, propertyKey, value);\n                    }\n                }\n\n                if (value == null || value === false) {\n                    if (templateElement.hasAttribute(propertyKey)) {\n                        templateElement.removeAttribute(propertyKey);\n                    }\n                } else if (!isReference) {\n                    const attrValue = value === true ? '' : (value as string).toString();\n                    if (templateElement.getAttribute(propertyKey) !== attrValue) {\n                        templateElement.setAttribute(propertyKey, attrValue);\n                    }\n                }\n            }\n\n            templateChildren = children;\n        } else if (isThenable(template)) {\n            handleItems(h((props, context) => {\n                const status = getThenableState(template as Promise<unknown>);\n                if (status.pending) {\n                    (template as Promise<unknown>)\n                        .catch(() => 1)\n                        .then(() => {\n                            context.requestUpdate();\n                        });\n                }\n                return status.result as Template;\n            }, null), filter);\n            return;\n        } else if (isObservable(template)) {\n            const observable = template;\n            handleItems(h((props, context) => {\n                const status = getObservableState(observable);\n                if (!status.complete) {\n                    const subscription = observable.subscribe(\n                        () => {\n                            if (!context.requestUpdate()) {\n                                subscription.unsubscribe();\n                            }\n                        },\n                        () => {\n                            if (!context.requestUpdate()) {\n                                subscription.unsubscribe();\n                            }\n                        },\n                        () => {\n                            subscription.unsubscribe();\n                        }\n                    );\n                }\n                return status.current as Template;\n            }, null), filter);\n            return;\n        } else if (isNode(template)) {\n            templateNode = template;\n        } else  {\n            if (typeof template === 'string' && rootContext && renderContext.tagName === 'style') {\n                const is = rootContext.is as string;\n                template = css(is, template as string, customElements.tagNames[is]);\n                (root as HTMLStyleElement).setAttribute('name', is);\n            }\n\n            if (currentContext && currentContext.isText) {\n                templateNode = currentNode as Text;\n                if (templateNode.textContent != template) {\n                    templateNode.textContent = template as string;\n                }\n            } else {\n                // convert non-Node template into Text\n                templateNode = DOM.createTextNode(template as string);\n            }\n        }\n\n        if (filter && !filter(templateNode)) {\n            return;\n        }\n\n        // now, we are confident that if the input is a Node or a Component,\n        // check if Nodes are the same instance\n        // (patch result should return same Node instances for compatible types)\n        if (templateNode !== currentNode) {\n            // they are different, so we need to insert the new Node into the tree\n            // if current iterator is defined, insert the Node before it\n            // otherwise append the new Node at the end of the parent\n            DOM.insertBefore(root, templateNode, currentNode, slot);\n            currentIndex++;\n        } else {\n            currentNode = childNodes.item(++currentIndex) as Node;\n            currentContext = currentNode ? getOrCreateContext(currentNode) : null;\n        }\n\n        if (isElement(templateNode) &&\n            templateChildren &&\n            templateContext &&\n            ((templateContext.parent && templateContext.parent === refContext) || templateChildren.length)) {\n            templateContext.parent = refContext;\n            // the Node has slotted children, trigger a new render context for them\n            internalRender(\n                templateNode as HTMLElement,\n                templateChildren,\n                isComponent(templateNode),\n                templateContext,\n                templateNamespace,\n                rootContext,\n                refContext\n            );\n        }\n    };\n\n    handleItems(input);\n\n    // all children of the root have been handled,\n    // we can start to cleanup the tree\n    // remove all Nodes that are outside the result range\n    let lastIndex: number;\n    if (lastNode) {\n        lastIndex = indexOf.call(childNodes, lastNode) + 1;\n    } else {\n        lastIndex = childNodes.length;\n    }\n    while (currentIndex < lastIndex) {\n        const item = childNodes.item(--lastIndex) as Node;\n        if (slot) {\n            const context = getOrCreateContext(item);\n            if (context.root === rootContext) {\n                delete context.root;\n            }\n            if (context.parent === refContext) {\n                delete context.parent;\n            }\n        }\n        DOM.removeChild(root, item, slot);\n    }\n\n    return childNodes;\n};\n\n/**\n * Render a set of Nodes into another, with some checks for Nodes in order to avoid\n * useless changes in the tree and to mantain or update the state of compatible Nodes.\n *\n * @param input The child (or the children) to render in Virtual DOM format or already generated.\n * @param root The root Node for the render.\n * @param slot Should render to slot children.\n * @return The resulting child Nodes.\n */\nexport const render = (input: Template, root: Node = DOM.createDocumentFragment(), slot: boolean = isComponent(root)): Node | Node[] | void => {\n    const childNodes = internalRender(root, input, slot);\n    if (!childNodes) {\n        return;\n    }\n    if (childNodes.length < 2) {\n        return childNodes[0];\n    }\n    return cloneChildNodes(childNodes);\n};\n", "import type { Constructor, ClassDescriptor } from './types';\nimport type { DelegatedEventCallback, ListenerConfig } from './events';\nimport type { PropertyConfig, PropertyObserver } from './property';\nimport type { Template } from './render';\nimport { addObserver, getProperty, reflectPropertyToAttribute, removeObserver } from './property';\nimport { createSymbol, HTMLElement, isConnected, emulateLifeCycle, setAttributeImpl, createElementImpl, setPrototypeOf, isElement, defineProperty, cloneChildNodes } from './helpers';\nimport { customElements } from './CustomElementRegistry';\nimport { DOM } from './DOM';\nimport { delegateEventListener, undelegateEventListener, dispatchEvent, dispatchAsyncEvent, getListeners } from './events';\nimport { getOrCreateContext, internalRender } from './render';\nimport { getProperties, getPropertyForAttribute } from './property';\n\n/**\n * A symbol which identify components.\n */\nexport const COMPONENT_SYMBOL: unique symbol = createSymbol();\n\nexport type WithComponentFlag<T> = T & {\n    [COMPONENT_SYMBOL]?: boolean;\n};\n\n/**\n * A symbol which identify constructed components (properties can be assigned).\n */\nexport const CONSTRUCTED_SYMBOL: unique symbol = createSymbol();\n\nexport type WithConstructedFlag<T> = T & {\n    [CONSTRUCTED_SYMBOL]?: boolean;\n};\n\n/**\n * Check if a node is a component.\n * @param node The node to check.\n */\nexport const isComponent = (node: WithComponentFlag<Node>): node is ComponentInstance<HTMLElement> => !!node[COMPONENT_SYMBOL];\n\n/**\n * Check if a node is a constructed component.\n * @param node The node to check.\n */\nexport const isConstructed = (node: WithConstructedFlag<Node>) => !!node[CONSTRUCTED_SYMBOL];\n\n/**\n * Add the constructed flag to the node.\n * @param node The constructed node.\n */\nexport const flagConstructed = (node: WithConstructedFlag<HTMLElement>) => {\n    node[CONSTRUCTED_SYMBOL] = true;\n};\n\n/**\n * Check if a constructor is a component constructor.\n * @param constructor The constructor to check.\n */\nexport const isComponentConstructor = (constructor: Function): constructor is ComponentConstructor<HTMLElement> => !!constructor.prototype[COMPONENT_SYMBOL];\n\n/**\n * Extract slotted child nodes for initial child nodes.\n * @param context The compoonent context.\n * @return A list of new slotted children.\n */\nfunction initSlotChildNodes<T extends HTMLElement>(element: ComponentInstance<T>) {\n    const context = getOrCreateContext(element);\n    const doc = element.ownerDocument;\n    /* istanbul ignore next */\n    if (!element.childNodes.length && doc.readyState === 'loading') {\n        return;\n    }\n    const slotChildNodes = cloneChildNodes(element.childNodes);\n    for (let i = 0, len = slotChildNodes.length; i < len; i++) {\n        element.removeChild(slotChildNodes[i]);\n    }\n    context.slotChildNodes = slotChildNodes;\n    return slotChildNodes;\n}\n\n/**\n * Create a base Component class which extends a native constructor.\n * @param ctor The base HTMLElement constructor to extend.\n * @return The extend class.\n */\nconst mixin = <T extends HTMLElement>(ctor: Constructor<T>) => {\n    const Component = class Component extends (ctor as Constructor<HTMLElement>) {\n        /**\n         * An array containing the names of the attributes to observe.\n         */\n        static get observedAttributes(): string[] {\n            const propertiesDescriptor = getProperties(this.prototype);\n            const attributes = [];\n            for (const key in propertiesDescriptor) {\n                const prop = propertiesDescriptor[key as keyof typeof propertiesDescriptor];\n                if (prop && prop.attribute && !prop.state) {\n                    attributes.push(prop.attribute);\n                }\n            }\n\n            return attributes;\n        }\n\n        /**\n         * Define component properties.\n         */\n        static readonly properties?: {\n            [key: string]: PropertyConfig;\n        };\n\n        /**\n         * Define component listeners.\n         */\n        static readonly listeners?: {\n            [key: string]: ListenerConfig;\n        };\n\n        /**\n         * Identify shimmed constructors.\n         * Constructor will skip native constructing when true.\n         */\n        static shim?: boolean;\n\n        /**\n         * Upgrade a plain element prototype.\n         * @param node The node to upgrade.\n         * @return The new prototyped node.\n         */\n        static upgrade<T extends HTMLElement>(node: T) {\n            return new this(node);\n        }\n\n        /**\n         * The tag name used for Component definition.\n         */\n        get is(): string {\n            return undefined as unknown as string;\n        }\n\n        /**\n         * A flag with the connected value of the node.\n         */\n        get isConnected(): boolean {\n            return isConnected.call(this);\n        }\n\n        /**\n         * A list of slot nodes.\n         */\n        get slotChildNodes() {\n            return getOrCreateContext(this).slotChildNodes;\n        }\n\n        /**\n         * Create a new Component instance.\n         * @param node Instantiate the element using the given node instead of creating a new one.\n         * @param properties A set of initial properties for the element.\n         */\n        constructor(...args: any[]) {\n            super();\n\n            const node = isElement(args[0]) && args[0];\n            const props = (node ? args[1] : args[0]) as { [P in keyof this]: this[P] };\n\n            const element = (node ? (setPrototypeOf(node, this), node) : this) as this;\n            const context = getOrCreateContext(element);\n            context.is = element.is;\n            initSlotChildNodes(element);\n\n            // setup listeners\n            const listeners = getListeners(this);\n            for (let i = 0, len = listeners.length; i < len; i++) {\n                const { event, target, selector, callback, options } = listeners[i];\n                if (!target) {\n                    element.delegateEventListener(event, selector, callback, options);\n                }\n            }\n\n            // setup properties\n            const properties = getProperties(this);\n            for (const propertyKey in properties) {\n                delete element[propertyKey];\n                const property = properties[propertyKey];\n                if (typeof property.initializer === 'function') {\n                    element[propertyKey] = property.initializer.call(element);\n                } else if (typeof property.defaultValue !== 'undefined') {\n                    element[propertyKey] = property.defaultValue;\n                }\n\n                const observers = property.observers;\n                for (let i = 0; i < observers.length; i++) {\n                    element.observe(propertyKey, observers[i]);\n                }\n            }\n\n            element.initialize(props);\n            return element;\n        }\n\n        /**\n         * Initialize component properties.\n         * @param properties A set of initial properties for the element.\n         */\n        initialize(properties?: { [P in keyof this]: this[P] }) {\n            flagConstructed(this);\n            if (properties) {\n                for (const propertyKey in properties) {\n                    this[propertyKey] = properties[propertyKey];\n                }\n            }\n        }\n\n        /**\n         * Invoked each time the Component is appended into a document-connected element.\n         * This will happen each time the node is moved, and may happen before the element's contents have been fully parsed.\n         */\n        connectedCallback() {\n            if (this.is !== this.localName) {\n                // force the is attribute\n                setAttributeImpl.call(this, 'is', this.is);\n            }\n            setAttributeImpl.call(this, ':defined', '');\n\n            const listeners = getListeners(this);\n            for (let i = 0, len = listeners.length; i < len; i++) {\n                const { event, target, callback, options } = listeners[i];\n                if (target) {\n                    target.addEventListener(event, callback, options);\n                }\n            }\n\n            // trigger a re-render when the Node is connected\n            this.forceUpdate();\n        }\n\n        /**\n         * Invoked each time the Component is disconnected from the document's DOM.\n         */\n        disconnectedCallback() {\n            const listeners = getListeners(this);\n            for (let i = 0, len = listeners.length; i < len; i++) {\n                const { event, target, callback, options } = listeners[i];\n                if (target) {\n                    target.removeEventListener(event, callback, options);\n                }\n            }\n        }\n\n        /**\n         * Invoked each time one of the Component's attributes is added, removed, or changed.\n         *\n         * @param attributeName The name of the updated attribute.\n         * @param oldValue The previous value of the attribute.\n         * @param newValue The new value for the attribute (null if removed).\n         */\n        attributeChangedCallback(attributeName: string, oldValue: null | string, newValue: string | null) {\n            const property = getPropertyForAttribute(this, attributeName);\n            if (!property) {\n                return;\n            }\n\n            // update the Component Property value\n            const { name, attribute, fromAttribute } = property;\n            if (attribute && fromAttribute) {\n                this[name] = fromAttribute.call(this, newValue);\n            }\n        }\n\n        /**\n         * Invoked each time one of a Component's state property is setted, removed, or changed.\n         *\n         * @param propertyName The name of the changed property.\n         * @param oldValue The previous value of the property.\n         * @param newValue The new value for the property (undefined if removed).\n         */\n        stateChangedCallback<P extends keyof this>(propertyName: P, oldValue: this[P] | undefined, newValue: this[P]) {\n            reflectPropertyToAttribute(this, propertyName, newValue);\n        }\n\n        /**\n         * Invoked each time one of a Component's property is setted, removed, or changed.\n         *\n         * @param propertyName The name of the changed property.\n         * @param oldValue The previous value of the property.\n         * @param newValue The new value for the property (undefined if removed).\n         */\n        propertyChangedCallback<P extends keyof this>(propertyName: P, oldValue: this[P] | undefined, newValue: this[P]) {\n            reflectPropertyToAttribute(this, propertyName, newValue);\n        }\n\n        /**\n         * Get the inner value of a property.\n         * This is an helper method for properties getters and setters.\n         * @param propertyName The name of the property to get.\n         * @return The inner value of the property.\n         */\n        getInnerPropertyValue<P extends keyof this>(propertyName: P): this[P] {\n            const property = getProperty(this, propertyName, true);\n            return this[property.symbol as keyof this] as this[P];\n        }\n\n        /**\n         * Set the inner value of a property.\n         * This is an helper method for properties getters and setters.\n         * @param propertyName The name of the property to get.\n         * @param value The inner value to set.\n         */\n        setInnerPropertyValue<P extends keyof this>(propertyName: P, value: this[P]) {\n            const property = getProperty(this, propertyName, true);\n            this[property.symbol as keyof this] = value;\n        }\n\n        /**\n         * Observe a Component Property.\n         *\n         * @param propertyName The name of the Property to observe\n         * @param observer The callback function\n         */\n        observe<P extends keyof this>(propertyName: P, observer: PropertyObserver<this[P]>) {\n            addObserver(this, propertyName, observer);\n        }\n\n        /**\n         * Unobserve a Component Property.\n         *\n         * @param propertyName The name of the Property to unobserve\n         * @param observer The callback function to remove\n         */\n        unobserve<P extends keyof this>(propertyName: P, observer: PropertyObserver<this[P]>) {\n            removeObserver(this, propertyName, observer);\n        }\n\n        /**\n         * Dispatch a custom Event.\n         *\n         * @param event The event to dispatch or the name of the synthetic event to create.\n         * @param detail Detail object of the event.\n         * @param bubbles Should the event bubble.\n         * @param cancelable Should the event be cancelable.\n         * @param composed Is the event composed.\n         */\n        dispatchEvent(event: Event): boolean;\n        dispatchEvent(event: string, detail?: CustomEventInit['detail'], bubbles?: boolean, cancelable?: boolean, composed?: boolean): boolean;\n        dispatchEvent(event: Event | string, detail?: CustomEventInit['detail'], bubbles?: boolean, cancelable?: boolean, composed?: boolean) {\n            return dispatchEvent(this, event as string, detail, bubbles, cancelable, composed);\n        }\n\n        /**\n         * Dispatch an async custom Event.\n         *\n         * @param event The event to dispatch or the name of the synthetic event to create.\n         * @param detail Detail object of the event.\n         * @param bubbles Should the event bubble.\n         * @param cancelable Should the event be cancelable.\n         * @param composed Is the event composed.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        dispatchAsyncEvent(event: Event): Promise<any[]>;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        dispatchAsyncEvent(event: string, detail?: CustomEventInit['detail'], bubbles?: boolean, cancelable?: boolean, composed?: boolean): Promise<any[]>;\n        dispatchAsyncEvent(event: Event | string, detail?: CustomEventInit['detail'], bubbles?: boolean, cancelable?: boolean, composed?: boolean) {\n            return dispatchAsyncEvent(this, event as string, detail, bubbles, cancelable, composed);\n        }\n\n        /**\n         * Delegate an Event listener.\n         *\n         * @param eventName The event name to listen\n         * @param selector The selector to delegate\n         * @param callback The callback to trigger when an Event matches the delegation\n         */\n        delegateEventListener(event: string, selector: string | null, callback: DelegatedEventCallback, options?: AddEventListenerOptions) {\n            return delegateEventListener(this, event, selector, callback, options);\n        }\n\n        /**\n         * Remove an Event delegation.\n         *\n         * @param eventName The Event name to undelegate\n         * @param selector The selector to undelegate\n         * @param callback The callback to remove\n         */\n        undelegateEventListener(event: string, selector: string | null, callback: DelegatedEventCallback) {\n            return undelegateEventListener(this, event, selector, callback);\n        }\n\n        /**\n         * Render method of the Component.\n         *\n         * @return The instances of the rendered Components and/or Nodes\n         */\n        render(): Template | undefined {\n            return this.slotChildNodes;\n        }\n\n        /**\n         * Force an element to re-render.\n         */\n        forceUpdate() {\n            const childNodes = this.slotChildNodes || initSlotChildNodes(this);\n            if (childNodes) {\n                internalRender(this, this.render(), false);\n            }\n        }\n\n        /**\n         * Append a child to the Component.\n         *\n         * @param newChild The child to add.\n         */\n        appendChild<T extends Node>(newChild: T): T {\n            return DOM.appendChild(this, newChild);\n        }\n\n        /**\n         * Remove a child from the Component.\n         *\n         * @param {Node} oldChild The child to remove.\n         */\n        removeChild<T extends Node>(oldChild: T): T {\n            return DOM.removeChild(this, oldChild);\n        }\n\n        /**\n         * Insert a child before another in the Component.\n         *\n         * @param newChild The child to insert.\n         * @param refChild The referred Node.\n         */\n        insertBefore<T extends Node>(newChild: T, refChild: Node | null): T {\n            return DOM.insertBefore(this, newChild, refChild);\n        }\n\n        /**\n         * Replace a child with another in the Component.\n         *\n         * @param newChild The child to insert.\n         * @param oldChild The Node to replace.\n         */\n        replaceChild<T extends Node>(newChild: Node, oldChild: T): T {\n            return DOM.replaceChild(this, newChild, oldChild);\n        }\n\n        /**\n         * Insert a child at the given position.\n         *\n         * @param postion The position of the insertion.\n         * @param insertedElement The child to insert.\n         * @param slot Should insert a slot node.\n         */\n        insertAdjacentElement(position: InsertPosition, insertedElement: Element): Element | null {\n            return DOM.insertAdjacentElement(this, position, insertedElement);\n        }\n\n        /**\n         * Set a Component attribute.\n         *\n         * @param ualifiedName The attribute name.\n         * @param value The value to set.\n         */\n        setAttribute(qualifiedName: string, value: string) {\n            return DOM.setAttribute(this, qualifiedName, value);\n        }\n\n        /**\n         * Remove a Component attribute.\n         *\n         * @param qualifiedName The attribute name.\n         */\n        removeAttribute(qualifiedName: string) {\n            return DOM.removeAttribute(this, qualifiedName);\n        }\n    };\n\n    defineProperty(Component.prototype, COMPONENT_SYMBOL, {\n        get() {\n            return true;\n        },\n    });\n\n    return Component;\n};\n\n/**\n * The basic DNA Component constructor.\n */\nexport type ComponentConstructor<T extends HTMLElement> = ReturnType<typeof mixin> & Constructor<T>;\n\n/**\n * The basic DNA Component interface.\n * It's a Custom Element, but with some extra useful method.\n * @see [W3C specification]{@link https://w3c.github.io/webcomponents/spec/custom/}.\n */\nexport type ComponentInstance<T extends HTMLElement> = InstanceType<ComponentConstructor<T>>;\n\n/**\n * Create a shim Constructor for Element constructors, in order to extend and instantiate them programmatically,\n * because using `new HTMLElement()` in browsers throw `Illegal constructor`.\n *\n * @param base The constructor or the class to shim.\n * @return A newable constructor with the same prototype.\n */\nexport const shim = <T extends typeof HTMLElement>(base: T): T => {\n    const shim = function(this: InstanceType<ReturnType<typeof mixin>>, ...args: any[]) {\n        const constructor = this.constructor as ReturnType<typeof mixin>;\n        const is = this.is;\n        if (!is) {\n            throw new TypeError('Illegal constructor');\n        }\n\n        const tag = customElements.tagNames[is];\n        let element: InstanceType<typeof constructor>;\n        if (customElements.native && !constructor.shim) {\n            element = Reflect.construct(base, args, constructor);\n            if (tag === element.localName) {\n                return element;\n            }\n        }\n\n        element = createElementImpl(tag) as InstanceType<typeof constructor>;\n        setPrototypeOf(element, constructor.prototype);\n        emulateLifeCycle(element);\n        return element;\n    } as unknown as T;\n    setPrototypeOf(shim, base);\n    (shim as Function).apply = Function.apply;\n    (shim as Function).call = Function.call;\n    shim.prototype = base.prototype;\n    return shim;\n};\n\n/**\n * Get a native HTMLElement constructor to extend by its name.\n * @param name The name of the constructor (eg. \"HTMLAnchorElement\").\n * @return A proxy that extends the native constructor.\n */\nexport const extend = <T extends HTMLElement>(constructor: Constructor<T>) => mixin(shim(constructor)) as unknown as ComponentConstructor<T>;\n\n/**\n * The DNA base Component constructor, a Custom Element constructor with\n * declarative properties and event delegations, custom template and\n * a complete life cycle implementation.\n * All DNA components **must** extends this class.\n */\nexport const Component = extend(HTMLElement);\n\n/**\n * Decorate and define component classes.\n * @param name The name of the custom element.\n * @param options The custom element options.\n * @return The decorated component class.\n */\nexport const customElement = (name: string, options?: ElementDefinitionOptions) =>\n    // TypeScript complains about return type because we handle babel output\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (classOrDescriptor: ComponentConstructor<HTMLElement>|ClassDescriptor): any => {\n        const upgrade = (constructor: ComponentConstructor<HTMLElement>) => {\n            const Component = class extends constructor {\n                /**\n                 * Store constructor properties.\n                 */\n                private initProps?: { [P in keyof this]: this[P] };\n\n                /**\n                 * @inheritdoc\n                 */\n                constructor(...args: any[]) {\n                    super(...args);\n                    flagConstructed(this);\n                    this.initialize(this.initProps);\n                }\n\n                /**\n                 * @inheritdoc\n                 */\n                initialize(props?: { [P in keyof this]: this[P] }) {\n                    if (!isConstructed(this)) {\n                        this.initProps = props;\n                        return;\n                    }\n                    return super.initialize(props);\n                }\n            };\n\n            customElements.define(name, Component, options);\n            return Component as typeof classOrDescriptor;\n        };\n\n        if (typeof classOrDescriptor === 'function') {\n            // typescript\n            return upgrade(classOrDescriptor);\n        }\n\n        // spec 2\n        const { kind, elements } = classOrDescriptor;\n        return {\n            kind,\n            elements,\n            finisher<T extends HTMLElement>(constructor: Constructor<T>) {\n                return upgrade(constructor as ComponentConstructor<T>);\n            },\n        };\n    };\n", "import type { Constructor } from './types';\nimport { window } from './window';\nimport { connect, defineProperty } from './helpers';\nimport { isComponent, isComponentConstructor, isConstructed } from './Component';\nimport { defineProperties } from './property';\nimport { defineListeners } from './events';\n\n/**\n * The native custom elements registry.\n */\nconst nativeCustomElements = window.customElements;\n\n/**\n * The current document instance.\n */\nconst document = window.document;\n\n/**\n * Check the validity of a Custom Element name.\n * @param name The name to validate.\n */\nconst assertValidateCustomElementName = (name: string): boolean => (\n    !!name                     // missing element name\n    && name.indexOf('-') >= 1  // custom element names must contain (and must not start with) a hyphen\n    && /[a-z\\-\\d]/.test(name)  // custom element names can contain lowercase characters, digits and hyphens\n    && /^[^\\d]/i.test(name)    // custom element names must not start with a digit\n);\n\n/**\n * The plain Custom Element interface.\n */\nexport type CustomElement<T extends HTMLElement> = T & {\n    is: string;\n    connectedCallback(): void;\n    disconnectedCallback(): void;\n    attributeChangedCallback(attrName: string, oldValue: null | string, newValue: null | string): void;\n}\n\n/**\n * The plain Custom Element constructor.\n */\nexport type CustomElementConstructor<T extends HTMLElement> = Constructor<CustomElement<T>> & {\n    readonly observedAttributes?: string[];\n}\n\n/**\n * Check if the function is a Custom Element constructor.\n * @param constructor The function to check.\n */\nexport const isCustomElementConstructor = (constructor: Function): constructor is CustomElementConstructor<HTMLElement> => constructor.prototype instanceof window.HTMLElement;\n\n/**\n * The CustomElementRegistry interface provides methods for registering custom elements and querying registered elements.\n */\nexport class CustomElementRegistry {\n    /**\n     * Support native registry.\n     */\n    readonly native: boolean = !!nativeCustomElements;\n\n    /**\n     * A global registry.\n     */\n    readonly registry: {\n        [key: string]: CustomElementConstructor<HTMLElement>;\n    } = {};\n\n    /**\n     * A map of tag names.\n     */\n    readonly tagNames: {\n        [key: string]: string;\n    } = {};\n\n    /**\n     * Collect \"whenDefined\" promises.\n     */\n    readonly queue: {\n        [key: string]: Array<(value?: unknown) => void>;\n    } = {};\n\n    /**\n     * Get the Custom Element definition for a tag.\n     *\n     * @param name The name of the tag.\n     * @return The definition for the given tag.\n     */\n    get(name: string): CustomElementConstructor<HTMLElement> | undefined {\n        let constructor: CustomElementConstructor<HTMLElement> = this.registry[name];\n        // the native custom elements get method is slow\n        // assert valid names before calling it.\n        if (!constructor && nativeCustomElements && assertValidateCustomElementName(name)) {\n            constructor = nativeCustomElements.get(name);\n        }\n        return constructor;\n    }\n\n    /**\n     * Define a new Custom Element.\n     *\n     * @param name The tag name for the element.\n     * @param constructor The Custom Element constructor.\n     * @param options A set of definition options, like `extends` for native tag extension.\n     */\n    define(name: string, constructor: CustomElementConstructor<HTMLElement> & { shim?: boolean }, options: ElementDefinitionOptions = {}) {\n        if (!assertValidateCustomElementName(name)) {\n            throw new SyntaxError('The provided name must be a valid Custom Element name');\n        }\n\n        if (typeof constructor !== 'function') {\n            throw new TypeError('The referenced constructor must be a constructor');\n        }\n\n        if (this.registry[name]) {\n            throw new Error('The registry already contains an entry with the same name');\n        }\n\n        if (isComponentConstructor(constructor)) {\n            defineProperties(constructor.prototype);\n            defineListeners(constructor.prototype);\n        }\n\n        try {\n            defineProperty(constructor.prototype, 'is', {\n                writable: false,\n                configurable: false,\n                value: name,\n            });\n        } catch {\n            throw new Error('The registry already contains an entry with the constructor (or is otherwise already defined)');\n        }\n\n        const tagName = (options.extends || name).toLowerCase();\n        this.registry[name] = constructor;\n        this.tagNames[name] = tagName;\n\n        if (nativeCustomElements) {\n            const shouldShim = constructor.shim;\n            if (tagName !== name) {\n                constructor.shim = true;\n                options = {\n                    get extends() {\n                        constructor.shim = shouldShim;\n                        return tagName;\n                    },\n                };\n            }\n            nativeCustomElements.define(name, constructor, options);\n        } else {\n            const queue = this.queue;\n            if (document.body) {\n                this.upgrade(document.body);\n            }\n            const elementQueue = queue[name];\n            if (elementQueue) {\n                for (let i = 0, len = elementQueue.length; i < len; i++) {\n                    elementQueue[i](constructor);\n                }\n            }\n        }\n    }\n\n    /**\n     * It returns a Promise that resolves when the named element is defined.\n     * @param name The Custom Element name.\n     * @return A Promise that resolves when the named element is defined.\n     */\n    whenDefined(name: string): Promise<CustomElementConstructor<HTMLElement>> {\n        if (nativeCustomElements) {\n            return nativeCustomElements\n                .whenDefined(name)\n                // not all browsers resolve the constructor class\n                .then(() => nativeCustomElements.get(name));\n        }\n        if (this.registry[name]) {\n            return Promise.resolve(this.registry[name]);\n        }\n        const queue = this.queue;\n        const whenDefinedPromise = new Promise((resolve) => {\n            queue[name] = queue[name] || [];\n            queue[name].push(resolve);\n        });\n\n        return whenDefinedPromise as Promise<CustomElementConstructor<HTMLElement>>;\n    }\n\n    /**\n     * It upgrades all custom elements in a subtree even before they are connected to the main document.\n     * @param root A Node instance with descendant elements that are to be upgraded.\n     */\n    upgrade(root: HTMLElement) {\n        const is = (root.getAttribute('is') || root.tagName).toLowerCase();\n        const constructor = this.get(is);\n        // find all root children\n        const nodes = root.children;\n        // iterate all nodes found\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            this.upgrade(nodes[i] as HTMLElement);\n        }\n        if (!constructor) {\n            return;\n        }\n\n        if (nativeCustomElements && 'upgrade' in nativeCustomElements) {\n            // native upgrade\n            nativeCustomElements.upgrade(root);\n        }\n\n        // check if already instantiated\n        if (isComponent(root)) {\n            if (isConstructed(root)) {\n                root.forceUpdate();\n            }\n            return;\n        }\n\n        if (isComponentConstructor(constructor)) {\n            const attributes: { name: string; value: string }[] = [];\n            const observed = constructor.observedAttributes || [];\n            for (let i = 0, len = root.attributes.length; i < len; i++) {\n                const attr = root.attributes[i];\n                if (observed.indexOf(attr.name) !== -1) {\n                    attributes.push({\n                        name: attr.name,\n                        value: attr.value,\n                    });\n                }\n            }\n            const element = constructor.upgrade(root);\n            for (let i = 0, len = attributes.length; i < len; i++) {\n                const { name, value } = attributes[i];\n                if (element.getAttribute(name) === value) {\n                    element.attributeChangedCallback(name, null, value);\n                } else {\n                    element.setAttribute(name, value);\n                }\n            }\n            if (element.isConnected) {\n                connect(element);\n            }\n            element.forceUpdate();\n        }\n    }\n}\n\n/**\n * The global DNA registry instance.\n */\nexport const customElements = new CustomElementRegistry();\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    customElements.upgrade(document.body);\n});\n", "import type { Template } from './render';\nimport { cloneChildNodes } from './helpers';\nimport { DOM } from './DOM';\nimport { h } from './render';\nimport { getThenableState } from './Thenable';\n\n/**\n * Convert an HTML string to DOM nodes.\n * @param string The HTML string to conver.\n * @return The virtual DOM template function.\n */\nexport const parseDOM = (string: string): Template => {\n    const source = string;\n    return h((props, { store }) => {\n        if (store.get('source') === source) {\n            return store.get('dom') as Node[];\n        }\n\n        const wrapper = DOM.createElement('div');\n        wrapper.innerHTML = source;\n        customElements.upgrade(wrapper);\n        const dom = cloneChildNodes(wrapper.childNodes);\n        store.set('source', source);\n        store.set('dom', dom);\n        return dom;\n    }, null);\n};\n\n/**\n * It renders the template when then provided Thenable is in pending status.\n * @param thenable The Promise-like object.\n * @param template The template to render.\n * @return A promise which resolves the template while the Thenable is in pending status.\n */\nexport const until = (thenable: Promise<unknown>, template: Template) => {\n    const original = getThenableState(thenable);\n    const wrapper = thenable.then(() => false).catch(() => false);\n    const state = getThenableState(wrapper);\n    state.result = original.pending && template;\n    return wrapper;\n};\n"],
  "mappings": "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",
  "names": []
}
