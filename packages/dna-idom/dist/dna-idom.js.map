{"version":3,"file":"dna-idom.js","sources":["node_modules/@dnajs/core/src/lib/typeof.js","node_modules/@dnajs/core/src/lib/registry.js","node_modules/@dnajs/core/src/lib/symbols.js","node_modules/@dnajs/core/src/lib/dom.js","node_modules/@dnajs/core/src/mixins/component.js","node_modules/@dnajs/core/src/polyfills/custom-event.js","node_modules/@dnajs/core/src/lib/dispatch.js","node_modules/@dnajs/core/src/lib/property.js","node_modules/@dnajs/core/src/mixins/properties-component.js","node_modules/@dnajs/core/src/polyfills/matches.js","node_modules/@dnajs/core/src/mixins/events-component.js","node_modules/@dnajs/core/src/lib/style.js","node_modules/@dnajs/core/src/mixins/style-component.js","node_modules/@dnajs/core/src/mixins/template-component.js","node_modules/@dnajs/core/src/polyfills/reduce.js","node_modules/@dnajs/core/src/lib/mixins.js","node_modules/@dnajs/core/src/lib/shim.js","node_modules/@dnajs/core/src/core.js","node_modules/incremental-dom/src/util.js","node_modules/incremental-dom/src/node_data.js","node_modules/incremental-dom/src/nodes.js","node_modules/incremental-dom/src/notifications.js","node_modules/incremental-dom/src/context.js","node_modules/incremental-dom/src/assertions.js","node_modules/incremental-dom/src/dom_util.js","node_modules/incremental-dom/src/core.js","node_modules/incremental-dom/src/symbols.js","node_modules/incremental-dom/src/attributes.js","node_modules/incremental-dom/src/virtual_elements.js","node_modules/incremental-dom/index.js","node_modules/@dnajs/core/index.js"],"sourcesContent":["/**\n * Check if an value is a function.\n * @method isFunction\n * @memberof! DNA.\n * @static\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isFunction(obj) {\n    return typeof obj === 'function';\n}\n/**\n * Check if an value is a string.\n * @method isString\n * @memberof! DNA.\n * @static\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isString(obj) {\n    return typeof obj === 'string';\n}\n/**\n * Check if an value is an object.\n * @method isObject\n * @memberof! DNA.\n * @static\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isObject(obj) {\n    return Object.prototype.toString.call(obj) === '[object Object]';\n}\n/**\n * Check if an value is undefined.\n * @method isUndefined\n * @memberof! DNA.\n * @static\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isUndefined(obj) {\n    return typeof obj === 'undefined';\n}\n/**\n * Check if an value is an array.\n * @method isArray\n * @memberof! DNA.\n * @static\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isArray(obj) {\n    return Array.isArray(obj);\n}\n","import { isFunction, isString } from './typeof.js';\n\n/**\n * A custom components registry.\n * It replicates the [CustomElementRegistry interface](https://www.w3.org/TR/custom-elements/#custom-elements-api).\n * @name registry\n * @namespace registry\n * @memberof! DNA.\n * @static\n */\nexport const registry = {\n    /**\n     * The list of defined components.\n     * @type {Object}\n     */\n    components: {},\n    /**\n     * Register a new component.\n     * @param {String} name The id of the component.\n     * @param {Function} Ctr The component constructor.\n     * @param {Object} config Optional component configuration.\n     */\n    define(name, Ctr, config = {}) {\n        this.components[name.toLowerCase()] = {\n            is: name,\n            Ctr,\n            config,\n        };\n    },\n    /**\n     * Retrieve a component descriptor by id.\n     * @private\n     * @param {String} name The component id.\n     * @return {Object} The component descriptor.\n     */\n    getDescriptor(name) {\n        if (isString(name)) {\n            return this.components[name.toLowerCase()];\n        } else if (isFunction(name)) {\n            for (let k in this.components) {\n                let desc = this.components[k];\n                if (desc.Ctr === name) {\n                    return desc;\n                }\n            }\n        }\n    },\n    /**\n     * Retrieve a component constructor by id.\n     * @param {String} name The component id.\n     * @return {Function} The component constructor.\n     */\n    get(name) {\n        let desc = this.getDescriptor(name);\n        if (desc) {\n            return desc.Ctr;\n        }\n    },\n};\n","export const COMPONENT_SYMBOL = '__component';\n","import { isFunction } from './typeof.js';\nimport { registry } from './registry.js';\nimport { COMPONENT_SYMBOL } from './symbols.js';\n\n/**\n * The `connectedCallback` name.\n * @private\n *\n * @type {String}\n * @see [W3C spec](https://www.w3.org/TR/custom-elements/#custom-element-reactions)\n */\nconst CONNECTED = 'connectedCallback';\n/**\n * The `disconnectedCallback` name.\n * @private\n *\n * @type {String}\n * @see [W3C spec](https://www.w3.org/TR/custom-elements/#custom-element-reactions)\n */\nconst DISCONNECTED = 'disconnectedCallback';\n/**\n * The `attributeChangedCallback` name.\n * @private\n *\n * @type {String}\n * @see [W3C spec](https://www.w3.org/TR/custom-elements/#custom-element-reactions)\n */\nconst UPDATED = 'attributeChangedCallback';\n/**\n * Retrieve a component constructor from an Element or from a tag name.\n * @method getComponent\n * @memberof DNA.DOM\n * @static\n *\n * @param {Component|String} element The element or the tag name.\n * @param {Boolean} full Retrieve full component information.\n * @return {Function} The component constructor for the given param.\n */\nexport function getComponent(element, full = false) {\n    if (element.node) {\n        element = element.node;\n    }\n    if (element.nodeType === Node.ELEMENT_NODE) {\n        element = element.getAttribute('is') || element.tagName;\n    }\n    return full ? registry.getDescriptor(element) : registry.get(element);\n}\n/**\n * Check if a node is an instance of a component.\n * @method isComponent\n * @memberof DNA.DOM\n * @static\n *\n * @param {Component} element The element to check.\n * @return {Boolean}\n */\nexport function isComponent(element) {\n    let Ctr = getComponent(element);\n    return Ctr && (element instanceof Ctr);\n}\n/**\n * An helper for dynamically trigger the `connectedCallback` reaction on components.\n * @method connect\n * @memberof DNA.DOM\n * @static\n *\n * @param {Component} element The attached node.\n * @return {Boolean} The callback has been triggered.\n */\nexport function connect(element) {\n    if (isComponent(element)) {\n        element[CONNECTED].call(element);\n        return true;\n    }\n}\n/**\n * An helper for dynamically trigger the `disconnectedCallback` reaction on components.\n * @method disconnect\n * @memberof DNA.DOM\n * @static\n *\n * @param {Component} element The detached node.\n * @return {Boolean} The callback has been triggered.\n */\nexport function disconnect(element) {\n    if (isComponent(element)) {\n        element[DISCONNECTED].call(element);\n        return true;\n    }\n}\n/**\n * An helper for dynamically trigger the `attributeChangedCallback` reaction on components.\n * @method update\n * @memberof DNA.DOM\n * @static\n *\n * @param {Component} element The updated element.\n * @return {Boolean} The callback has been triggered.\n */\nexport function update(element, name, oldValue, newValue) {\n    if (isComponent(element)) {\n        element[UPDATED].call(element, name, oldValue, newValue);\n        return true;\n    }\n}\n/**\n * Attach a component prototype to an already instantiated HTMLElement.\n * @method bind\n * @memberof DNA.DOM\n * @static\n *\n * @param {HTMLElement} node The node to update.\n * @param {Function} Ctr The component class to use (leave empty for auto detect).\n * @return {Boolean} The prototype has been attached.\n */\nexport function bind(node, Ctr) {\n    if (!isFunction(Ctr)) {\n        Ctr = getComponent(node);\n    }\n    if (isFunction(Ctr)) {\n        node.__proto__ = Ctr.prototype;\n        Object.defineProperty(node, 'constructor', {\n            value: Ctr,\n            configurable: true,\n            writable: true,\n        });\n        Ctr.call(node);\n        return true;\n    }\n    return false;\n}\n/**\n * Create a component instance.\n * @method createElement\n * @memberof DNA.DOM\n * @static\n *\n * @param {String} is The component tag name.\n * @return {HTMLElement} The component instance.\n */\nexport function createElement(is) {\n    let Ctr = getComponent(is);\n    if (Ctr) {\n        return new Ctr();\n    }\n}\n/**\n * Dynamically append a node and call the `connectedCallback`.\n * - disconnect the node if already in the tree\n * - connect the node after the insertion\n * @method appendChild\n * @memberof DNA.DOM\n * @static\n *\n * @param {HTMLElement} parent The parent element.\n * @param {Component} element The element to append.\n * @return {Boolean} The node has been appended.\n */\nexport function appendChild(parent, element) {\n    if (element.node) {\n        let node = element.node;\n        if (parent !== node.parentNode || parent.lastElementChild !== node) {\n            if (node.parentNode) {\n                removeChild(node.parentNode, element);\n            }\n            parent.appendChild(node);\n            return connect(element);\n        }\n    }\n    return false;\n}\n/**\n * Dynamically remove a node and call the `disconnectedCallback`.\n * @method removeChild\n * @memberof DNA.DOM\n * @static\n *\n * @param {HTMLElement} parent The parent element.\n * @param {Component} element The element to remove.\n * @return {Boolean} The node has been removed.\n */\nexport function removeChild(parent, element) {\n    if (element.node) {\n        parent.removeChild(element.node);\n        return disconnect(element);\n    }\n}\n/**\n * Dynamically insert a node before another and call all the reactions.\n * - disconnect the node if already in the tree\n * - connect the node after the insertion\n * @method insertBefore\n * @memberof DNA.DOM\n * @static\n *\n * @param {HTMLElement} parent The parent element.\n * @param {Component} element The element to insert.\n * @param {HTMLElement} refNode The node for positioning.\n * @return {Boolean} The node has been appended.\n */\nexport function insertBefore(parent, element, refNode) {\n    if (element.node) {\n        let node = element.node;\n        if (node.nextSibling !== refNode) {\n            if (node.parentNode) {\n                disconnect(element);\n            }\n            parent.insertBefore(node, refNode);\n            return connect(element);\n        }\n    }\n}\n/**\n * Dynamically replace a node with another and call all the reactions.\n * - disconnect the node if already in the tree\n * - disconnect the replaced node\n * - connect the first node after the insertion\n * @method replaceChild\n * @memberof DNA.DOM\n * @static\n *\n * @param {HTMLElement} parent The parent element.\n * @param {Component} element The element to insert.\n * @param {HTMLElement} refNode The node to replace.\n * @return {Boolean} The node has been appended.\n */\nexport function replaceChild(parent, element, refNode) {\n    if (element.node) {\n        let node = element.node;\n        if (node.parentNode) {\n            disconnect(element);\n        }\n        parent.replaceChild(node, refNode);\n        if (refNode[COMPONENT_SYMBOL]) {\n            disconnect(refNode[COMPONENT_SYMBOL]);\n        }\n        return connect(node);\n    }\n}\n/**\n * Dynamically update a node attribute and call all the reactions.\n * @method setAttribute\n * @memberof DNA.DOM\n * @static\n *\n * @param {Component} element The element to update.\n * @param {String} name The attribute name.\n * @param {String} value The attribute value.\n * @return {Boolean} The node has been updated.\n */\nexport function setAttribute(element, name, value) {\n    if (element.node) {\n        let node = element.node;\n        let oldValue = node.getAttribute(name);\n        node.setAttribute(name, value);\n        let attrs = element.constructor.observedAttributes || [];\n        if (attrs.indexOf(name) !== -1) {\n            return update(element, name, oldValue, value);\n        }\n    }\n}\n/**\n * Dynamically remove a node attribute and call all the reactions.\n * @method removeAttribute\n * @memberof DNA.DOM\n * @static\n *\n * @param {Component} element The element to update.\n * @param {String} name The attribute name.\n * @return {Boolean} The node has been updated.\n */\nexport function removeAttribute(element, name) {\n    if (element.node) {\n        let node = element.node;\n        let oldValue = node.getAttribute(name);\n        node.removeAttribute(name);\n        let attrs = element.constructor.observedAttributes || [];\n        if (attrs.indexOf(name) !== -1) {\n            return update(element, name, oldValue, null);\n        }\n    }\n}\n","import { COMPONENT_SYMBOL } from '../lib/symbols.js';\n\n/**\n * THe base custom component mixins. Just add life cycles callback and `is` getter.\n * @mixin ComponentMixin\n * @memberof DNA.MIXINS\n * @static\n */\nexport const ComponentMixin = (SuperClass) => class extends SuperClass {\n    /**\n     * @property {String} is Get component id.\n     * @name is\n     * @type {String}\n     * @memberof DNA.MIXINS.ComponentMixin\n     * @instance\n     */\n    get is() {\n        return (this.getAttribute('is') || this.localName).toLowerCase();\n    }\n    /**\n     * @property {HTMLElement} node Get component node reference.\n     * @name node\n     * @type {HTMLElement}\n     * @memberof DNA.MIXINS.ComponentMixin\n     * @instance\n     */\n    get node() {\n        return this;\n    }\n    /**\n     * Fires when an instance was inserted into the document.\n     * @method connectedCallback\n     * @memberof DNA.MIXINS.ComponentMixin\n     * @instance\n     */\n    connectedCallback() {\n        this.node[COMPONENT_SYMBOL] = this;\n    }\n    /**\n     * Fires when an instance was detached from the document.\n     * @method disconnectedCallback\n     * @memberof DNA.MIXINS.ComponentMixin\n     * @instance\n     */\n    disconnectedCallback() {}\n    /**\n     * Fires when an attribute was added, removed, or updated.\n     * @method attributeChangedCallback\n     * @memberof DNA.MIXINS.ComponentMixin\n     * @instance\n     *\n     * @param {String} attrName The changed attribute name.\n     * @param {String} oldVal The value of the attribute before the change.\n     * @param {String} newVal The value of the attribute after the change.\n     */\n    attributeChangedCallback() {}\n};\n","let CustomEvent;\n\ntry {\n    // eslint-disable-next-line\n    let ev = new self.CustomEvent('test');\n    CustomEvent = self.CustomEvent;\n} catch(ex) {\n    CustomEvent = function(event, params) {\n        params = params || {\n            bubbles: false,\n            cancelable: false,\n            detail: undefined,\n        };\n        let evt = document.createEvent('CustomEvent');\n        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n        return evt;\n    };\n    CustomEvent.prototype = self.CustomEvent.prototype;\n}\n\nexport { CustomEvent };\n","import { isString } from './typeof.js';\nimport { CustomEvent } from '../polyfills/custom-event.js';\n\n/**\n * Trigger a custom DOM Event.\n * @private\n *\n * @param {Node} node The event target.\n * @param {String} evName The custom event name.\n * @param {Object} data Extra data to pass to the event.\n * @param {Boolean} bubbles Enable event bubbling.\n * @param {Boolean} cancelable Make event cancelable.\n * @return {Boolean} True if event propagation has not be stopped.\n */\nexport function dispatch(node, evName, data, bubbles = true, cancelable = true) {\n    if (!isString(evName)) {\n        throw new TypeError('Event name is undefined');\n    }\n    let ev = new CustomEvent(evName, {\n        detail: data,\n        bubbles,\n        cancelable,\n    });\n    return node.dispatchEvent(ev);\n}\n","import { isUndefined, isFunction, isArray, isObject, isString } from './typeof.js';\n\n/**\n * Shortcut to `Object.defineProperty`.\n * @type {Function}\n * @private\n */\nconst define = Object.defineProperty;\n\n/**\n * Power to the component's properties.\n * Type checking, validation, callbacks, events and attribute syncing.\n * @private\n */\nclass Property {\n    /**\n     * Create a Property instance.\n     * @param {Function|Array} A single or a list of valid constructors for the property value.\n     * @return {Property}\n     */\n    constructor(ctrs) {\n        this._ = [];\n        ctrs = ctrs || [];\n        if (!isArray(ctrs)) {\n            ctrs = [ctrs];\n        }\n        this.ctrs = ctrs;\n        this.validator = () => true;\n        this._setter = (val) => val;\n        this.getterFn = () => this.value;\n        this.setterFn = (val) => {\n            val = this._setter(val);\n            if ((val === null || val === undefined) ||\n                this.validateType(val) && this.validator(val)) {\n                let oldValue = this.value;\n                if (oldValue !== val) {\n                    this.value = val;\n                    this.changed(val, oldValue);\n                }\n            } else {\n                // eslint-disable-next-line\n                throw new TypeError(\n                    `Invalid \\`${val}\\` value for \\`${this.name}\\` property for \\`${this.scope.is}\\`.`\n                );\n            }\n        };\n    }\n    /**\n     * Add a callback when the property changes.\n     * @param {Function} callback The callback to trigger.\n     * @return {Property} The property instance for chaining.\n     */\n    observe(callback) {\n        if (isFunction(callback) || isString(callback)) {\n            this._.push(callback);\n        }\n        return this;\n    }\n    /**\n     * Remove a callback on property changes.\n     * @param {Function} callback The callback to remove.\n     * @return {Property} The property instance for chaining.\n     */\n    unobserve(callback) {\n        let io = this._.indexOf(callback);\n        if (io !== -1) {\n            this._.splice(io, 1);\n        }\n        return this;\n    }\n    /**\n     * Trigger callbacks after a change.\n     * @private\n     * @param {*} newValue The current property value.\n     * @param {*} oldValue The previous property value.\n     */\n    changed(newValue, oldValue) {\n        for (let i = 0, len = this._.length; i < len; i++) {\n            let clb = this._[i];\n            if (isString(clb)) {\n                this.scope[clb].call(this.scope, this, newValue, oldValue);\n            } else {\n                clb(this, newValue, oldValue);\n            }\n        }\n    }\n    /**\n     * Check if a property accepts a given type as value.\n     * @param {Function} Ctr The constructor for the given type.\n     * @return {Boolean}\n     */\n    accepts(Ctr) {\n        return this.ctrs.indexOf(Ctr) !== -1;\n    }\n    /**\n     * Set the property name.\n     * It also set the attrName if `.attribute` method as been previously\n     * invoked without arguments.\n     * @param {String} name The property name.\n     * @return {Property} The property instance for chaining.\n     */\n    named(name) {\n        this.name = name;\n        if (this.attrRequested === true) {\n            this.attrName = this.name;\n        }\n        return this;\n    }\n    /**\n     * Set the property initial value.\n     * @param {*} initValue The property initial value.\n     * @return {Property} The property instance for chaining.\n     */\n    default(initValue) {\n        this.defaultValue = isObject(initValue) ?\n            Object.freeze(initValue) :\n            initValue;\n        return this;\n    }\n    /**\n     * Set the attribute name to sync.\n     * Invoked without arguments, it retrieve the name of the property.\n     * @param {String} attrName The attribute name.\n     * @return {Property} The property instance for chaining.\n     */\n    attribute(attrName = true) {\n        if (isString(attrName)) {\n            this.attrRequested = false;\n            this.attrName = attrName;\n        } else {\n            this.attrRequested = !!attrName;\n            this.attrName = this.name;\n        }\n        return this;\n    }\n    /**\n     * Add a DOM event name to dispatch on changes.\n     * @param {String} evName The event name.\n     * @return {Property} The property instance for chaining.\n     */\n    dispatch(evName) {\n        this.eventName = evName;\n        return this;\n    }\n    /**\n     * Set a getter function for the property.\n     * By default, the property value will be return.\n     * @param {Function} callback The property getter.\n     * @return {Property} The property instance for chaining.\n     */\n    getter(callback) {\n        if (isFunction(callback)) {\n            this.getterFn = () => callback(this.value);\n        }\n        return this;\n    }\n    /**\n     * Set a setter function for the property.\n     * By default, the property value will be updated with given value\n     * without any modification.\n     * @param {Function} callback The property setter.\n     * @return {Property} The property instance for chaining.\n     */\n    setter(callback) {\n        if (isFunction(callback)) {\n            this._setter = callback;\n        }\n        return this;\n    }\n    /**\n     * Set the property validator.\n     * A validator should return `true` if the value is acceptable\n     * or `false` if unaccaptable.\n     * @param {Function} callback The property validtor.\n     * @return {Property} The property instance for chaining.\n     */\n    validate(callback) {\n        if (isFunction(callback)) {\n            this.validator = callback;\n        }\n        return this;\n    }\n    /**\n     * Check if the given value is a valid type.\n     * @private\n     * @param {*} val The value to check.\n     * @return {Boolean}\n     */\n    validateType(val) {\n        let i = 0;\n        let ctrs = this.ctrs;\n        if (ctrs.length === 0) {\n            return true;\n        }\n        while (i < ctrs.length) {\n            if (val instanceof ctrs[i] || (\n                val.constructor && val.constructor === ctrs[i]\n            )) {\n                return true;\n            }\n            i++;\n        }\n        return false;\n    }\n    /**\n     * Attach the property to a scope (a component instance).\n     * Set the default value if provided.\n     * @param {Object} scope The scope which needs to be bound with the property.\n     */\n    init(scope) {\n        this.scope = scope;\n        define(scope, this.name, {\n            get: this.getterFn.bind(this),\n            set: this.setterFn.bind(this),\n            configurable: true,\n        });\n        if (!isUndefined(this.defaultValue)) {\n            scope[this.name] = this.defaultValue;\n        }\n    }\n}\n\n/**\n * Helper method for Property creation.\n * @method prop\n * @memberof! DNA.\n * @static\n *\n * @property {Property} ANY A property without type validation.\n * @property {Property} STRING A property which accepts only strings.\n * @property {Property} BOOLEAN A property which accepts only booleans.\n * @property {Property} NUMBER A property which accepts only numbers.\n *\n * @param {Property|Function|Array} ctrs A Property to clone or a single or a list of valid constructors for the property value.\n * @return {Property} The new property.\n */\nexport function prop(ctrs) {\n    if (ctrs instanceof Property) {\n        return ctrs;\n    }\n    return new Property(ctrs);\n}\n\n// Define some helpers for default types\ndefine(prop, 'ANY', { get() { return prop(); } });\ndefine(prop, 'STRING', { get() { return prop(String); } });\ndefine(prop, 'BOOLEAN', { get() { return prop(Boolean); } });\ndefine(prop, 'NUMBER', { get() { return prop(Number); } });\n","import { isArray } from '../lib/typeof.js';\nimport { dispatch } from '../lib/dispatch.js';\nimport { isUndefined } from '../lib/typeof.js';\nimport { prop } from '../lib/property.js';\n\n/**\n * Try to parse attribute value checking the property validation types.\n * @private\n *\n * @param {Property} property The property to update.\n * @param {String} attrVal The attribute value.\n * @return {*} The parsed value.\n */\nfunction getValue(property, attrVal) {\n    if (attrVal === '' && property.accepts(Boolean)) {\n        return true;\n    }\n    if (!property.accepts(String)) {\n        try {\n            return JSON.parse(attrVal);\n        } catch (ex) {\n            //\n        }\n    }\n    return attrVal;\n}\n\n/**\n * Set an attribute value checking its type.\n * @private\n *\n * @param {HTMLElement} context The node to update.\n * @param {String} attr The attribute name to update.\n * @param {*} value The value to set.\n */\nfunction setAttribute(context, attr, value) {\n    let currentAttrValue = context.getAttribute(attr);\n    if (currentAttrValue !== value) {\n        if (value !== null && value !== undefined && value !== false) {\n            switch (typeof value) {\n            case 'string':\n            case 'number':\n                context.setAttribute(attr, value);\n                break;\n            case 'boolean':\n                context.setAttribute(attr, '');\n            }\n        } else if (currentAttrValue !== null) {\n            context.removeAttribute(attr);\n        }\n    }\n}\n\n/**\n * Simple Custom Component for properties initialization via attributes.\n * @mixin PropertiesMixin\n * @memberof DNA.MIXINS\n * @static\n *\n * @example\n * ```js\n * // my-component.js\n * import { BaseComponent } from '@dnajs/core';\n * export class MyComponent extends BaseComponent {\n *   get properties() {\n *     return { name: String };\n *   }\n * }\n * ```\n * ```js\n * // app.js\n * import { define } from '@dnajs/core';\n * import { MyComponent } from './my-component.js';\n * define('my-component', MyComponent);\n * var temp = document.createElement('div');\n * temp.innerHTML = '<my-component name=\"Albert\"></my-component>';\n * var element = temp.firstChild;\n * console.log(element.name); // logs \"Albert\"\n * ```\n */\nexport const PropertiesMixin = (SuperClass) => class extends SuperClass {\n    /**\n     * Attach properties on component creation.\n     * @method constructor\n     * @memberof DNA.MIXINS.PropertiesMixin\n     * @instance\n     */\n    constructor() {\n        super();\n        let props = this.properties;\n        if (props) {\n            if (!isArray(props)) {\n                props = [props];\n            }\n            props = props.reduce((res, partialProps) => {\n                for (let k in partialProps) {\n                    res[k] = prop(partialProps[k]);\n                }\n                return res;\n            }, {});\n        } else {\n            props = {};\n        }\n        Object.defineProperty(this, 'properties', {\n            value: props,\n            writable: false,\n            configurable: true,\n        });\n        let observed = this.constructor.observedAttributes || [];\n        for (let k in props) {\n            let prop = props[k];\n            prop.named(k).init(this);\n            let { attrName, eventName } = prop;\n            if (!attrName && observed.indexOf(k) !== -1) {\n                prop.attribute();\n                attrName = k;\n            }\n            if (attrName || eventName) {\n                prop.observe(() => {\n                    if (attrName) {\n                        setAttribute(this.node, attrName, this[prop.name]);\n                    }\n                    if (eventName) {\n                        dispatch(this.node, eventName);\n                    }\n                });\n            }\n        }\n    }\n    /**\n     * Sync initial attributes with properties.\n     * @method connectedCallback\n     * @memberof DNA.MIXINS.PropertiesMixin\n     * @instance\n     */\n    connectedCallback() {\n        super.connectedCallback();\n        let props = this.properties;\n        for (let k in props) {\n            let prop = props[k];\n            let { attrName } = prop;\n            if (attrName) {\n                if (isUndefined(this[prop.name])) {\n                    if (this.node.hasAttribute(attrName)) {\n                        this[prop.name] = getValue(prop, this.node.getAttribute(attrName));\n                    }\n                } else {\n                    setAttribute(this.node, attrName, this[prop.name]);\n                }\n            }\n        }\n    }\n    /**\n     * Sync attributes with properties.\n     * @method attributeChangedCallback\n     * @memberof DNA.MIXINS.PropertiesMixin\n     * @instance\n     *\n     * @param {String} attrName The changed attribute name.\n     * @param {String} oldVal The value of the attribute before the change.\n     * @param {String} newVal The value of the attribute after the change.\n     */\n    attributeChangedCallback(attr, oldVal, newVal) {\n        super.attributeChangedCallback(attr, oldVal, newVal);\n        let props = this.properties;\n        for (let k in props) {\n            let prop = props[k];\n            if (prop.attrName === attr) {\n                this[prop.name] = getValue(prop, newVal);\n                return;\n            }\n        }\n    }\n    /**\n     * Create a listener for node's property changes.\n     * @method observeProperty\n     * @memberof DNA.MIXINS.PropertiesMixin\n     * @instance\n     *\n     * @param {string} propName The property name to observe.\n     * @param {Function} callback The callback to fire.\n     * @return {Object} An object with `cancel` method.\n     */\n    observeProperty(propName, callback) {\n        return this.properties[propName].observe(callback);\n    }\n    /**\n     * Remove a listener for node's property changes.\n     * @method unobserveProperty\n     * @memberof DNA.MIXINS.PropertiesMixin\n     * @instance\n     *\n     * @param {string} propName The property name to unobserve.\n     * @param {Function} callback The callback to remove.\n     */\n    unobserveProperty(propName, callback) {\n        this.properties[propName].unobserve(callback);\n    }\n};\n","const ELEM_PROTO = Element.prototype;\n\nexport const matches = ELEM_PROTO.matches ||\n    ELEM_PROTO.matchesSelector ||\n    ELEM_PROTO.mozMatchesSelector ||\n    ELEM_PROTO.msMatchesSelector ||\n    ELEM_PROTO.oMatchesSelector ||\n    ELEM_PROTO.webkitMatchesSelector;\n","import { isString, isFunction } from '../lib/typeof.js';\nimport { matches } from '../polyfills/matches.js';\nimport { dispatch } from '../lib/dispatch.js';\n\nconst SPLIT_SELECTOR = /([^\\s]+)(.*)?/;\n\n/**\n * Simple Custom Component with events delegation,\n * It also implement a `dispatchEvent` wrapper named `trigger`.\n * @mixin EventsMixin\n * @memberof DNA.MIXINS.\n * @static\n *\n * @example\n * ```js\n * // my-component.js\n * import { BaseComponent } from '@dnajs/core';\n * export class MyComponent extends BaseComponent {\n *   get events() {\n *     return {\n *       'click button': 'onButtonClick'\n *     }\n *   }\n *   onButtonClick() {\n *     console.log('button clicked');\n *   }\n * }\n * ```\n * ```js\n * // app.js\n * import { define } from '@dnajs/core';\n * import { MyComponent } from './my-component.js';\n * define('my-component', MyComponent);\n * var element = new MyComponent();\n * var button = document.createElement('button');\n * button.innerText = 'Click me';\n * element.appendChild(button);\n * button.click(); // logs \"button clicked\"\n * ```\n */\nexport const EventsMixin = (SuperClass) => class extends SuperClass {\n    /**\n     * Attach and delegate events to the component.\n     * @method constructor\n     * @memberof DNA.MIXINS.EventsMixin\n     * @instance\n     */\n    constructor() {\n        super();\n        // bind events\n        let events = this.events || {};\n        for (let k in events) {\n            let callback = isString(events[k]) ?\n                this[events[k]] :\n                events[k];\n            if (isFunction(callback)) {\n                let rule = k.match(SPLIT_SELECTOR);\n                let evName = rule[1];\n                let selector = (rule[2] || '').trim();\n                if (selector) {\n                    this.delegate(evName, selector, callback);\n                } else {\n                    this.node.addEventListener(evName, (ev) => {\n                        callback.call(this, ev, this);\n                    });\n                }\n            } else {\n                throw new TypeError('Invalid callback for event.');\n            }\n        }\n    }\n    /**\n     * Delegate events to the component descendents.\n     * @method delegate\n     * @memberof DNA.MIXINS.EventsMixin\n     * @instance\n     *\n     * @param {String} evName The name of the event to delegate.\n     * @param {String} selector A CSS selector for descendents.\n     * @param {Function} callback The callback to fire when the event fires.\n     */\n    delegate(evName, selector, callback) {\n        this.node.addEventListener(evName, (event) => {\n            let target = event.target;\n            while (target && target !== this) {\n                if (matches.call(target, selector)) {\n                    callback.call(this, event, target);\n                }\n                target = target.parentNode;\n            }\n        });\n    }\n    /**\n     * `Node.prototype.dispatchEvent` wrapper.\n     * @method trigger\n     * @memberof DNA.MIXINS.EventsMixin\n     * @instance\n     *\n     * @param {String} evName The name of the event to fire.\n     * @param {Object} data A set of custom data to pass to the event.\n     * @param {Boolean} bubbles Should the event bubble throw the DOM tree.\n     * @param {Boolean} cancelable Can be the event cancel by a callback.\n     * @return {Boolean} True if event propagation has not be stopped.\n     */\n    trigger(evName, data, bubbles = true, cancelable = true) {\n        return dispatch(this, evName, data, bubbles, cancelable);\n    }\n};\n","const rootDoc = document;\n/**\n * Create and attach a style element for a component.\n * @private\n *\n * @param {HTMLElement} node A component instance.\n * @return {HTMLElement} The created style element.\n */\nexport function createStyle(node) {\n    let doc = node.ownerDocument || rootDoc;\n    let styleElem = doc.createElement('style');\n    styleElem.type = 'text/css';\n    styleElem.setAttribute('id', `style-${node.is}`);\n    let head = doc.head;\n    /* istanbul ignore else */\n    if (head.firstElementChild) {\n        head.insertBefore(styleElem, head.firstElementChild);\n    } else {\n        head.appendChild(styleElem);\n    }\n    return styleElem;\n}\n","import { isString } from '../lib/typeof.js';\nimport { createStyle } from '../lib/style.js';\n\n/**\n * Simple Custom Component with css style handling using the `css` property.\n * @mixin StyleMixin\n * @memberof DNA.MIXINS\n * @static\n *\n * @example\n * ```js\n * // my-component.js\n * import { BaseComponent } from '@dnajs/core';\n * export class MyComponent extends BaseComponent {\n *   get css() {\n *     return '.my-component p { color: red; }'\n *   }\n * }\n * ```\n * ```js\n * // app.js\n * import { define } from '@dnajs/core';\n * import { MyComponent } from './my-component.js';\n * define('my-component', MyComponent);\n * var element = new MyComponent();\n * var p = document.createElement('p');\n * p.innerText = 'Paragraph';\n * element.appendChild(p); // text inside `p` gets the red color\n * ```\n */\nexport const StyleMixin = (SuperClass) => class extends SuperClass {\n    /**\n     * Fires when an instance of the element is created.\n     */\n    constructor() {\n        super();\n        if (!this.constructor.styleElem) {\n            let Ctr = this.constructor;\n            Object.defineProperty(Ctr, 'styleElem', {\n                value: createStyle(this),\n            });\n        }\n        this.updateCSS();\n    }\n\n    connectedCallback() {\n        super.connectedCallback();\n        this.node.classList.add(this.is);\n    }\n\n    updateCSS() {\n        let style = this.css;\n        if (isString(style)) {\n            this.constructor.styleElem.textContent = style;\n        }\n    }\n};\n","import { isUndefined, isFunction, isString } from '../lib/typeof.js';\n\n/**\n * Simple Custom Component with template handling using the `template` property.\n * @memberof DNA.MIXINS\n * @mixin TemplateMixin\n * @static\n *\n * @param {Function} SuperClass The class to extend.\n * @return {Function} The extended class.\n *\n * @example\n * ```js\n * // my-component.js\n * import { BaseComponent } from '@dnajs/core';\n * export class MyComponent extends BaseComponent {\n *   get template() {\n *     return `<h1>${this.name}</h1>`;\n *   }\n *   get name() {\n *     return 'Newton';\n *   }\n * }\n * ```\n * ```js\n * // app.js\n * import { define } from '@dnajs/core';\n * import { MyComponent } from './my-component.js';\n * define('my-component', MyComponent);\n * var element = new MyComponent();\n * console.log(element.innerHTML); // logs \"<h1>Newton</h1>\"\n * ```\n */\nexport const TemplateMixin = (SuperClass) => class extends SuperClass {\n    /**\n     * @property {Boolean} autoRender Should the component re-render on properties changes.\n     * @name autoRender\n     * @type {Boolean}\n     * @memberof DNA.MIXINS.TemplateMixin\n     * @instance\n     */\n    get autoRender() {\n        return true;\n    }\n    /**\n     * Attach properties observers in order to update children.\n     * @method constructor\n     * @memberof DNA.MIXINS.TemplateMixin\n     * @instance\n     */\n    constructor() {\n        super();\n        if (this.autoRender && !isUndefined(this.template)) {\n            let props = this.properties;\n            if (props) {\n                let callback = () => {\n                    this.render();\n                };\n                for (let k in props) {\n                    props[k].observe(callback);\n                }\n            }\n        }\n    }\n    /**\n     * Render the component when connected.\n     * @method connectedCallback\n     * @memberof DNA.MIXINS.TemplateMixin\n     * @instance\n     */\n    connectedCallback() {\n        super.connectedCallback();\n        if (!isUndefined(this.template)) {\n            this.render();\n        }\n    }\n    /**\n     * Update Component child nodes.\n     * @method render\n     * @memberof DNA.MIXINS.TemplateMixin\n     * @instance\n     *\n     * @param {Function|string} tpl A template to use instead of `this.template`.\n     *\n     * @throws {TypeError} Will throw if the template type is not supported.\n     */\n    render(tpl) {\n        tpl = tpl || this.template;\n        if (isFunction(tpl)) {\n            tpl.call(this);\n        } else if (isString(tpl)) {\n            this.node.innerHTML = tpl;\n        } else {\n            throw new TypeError('Invalid template property.');\n        }\n    }\n};\n","/* eslint-disable prefer-rest-params */\nexport const reduce = Array.prototype.reduce || function(callback /*, initialValue*/ ) {\n    'use strict';\n    let t = this;\n    let len = t.length;\n    let k = 0;\n    let value;\n    if (arguments.length === 2) {\n        value = arguments[1];\n    } else {\n        while (k < len && !(k in t)) {\n            k++;\n        }\n        value = t[k++];\n    }\n    for (; k < len; k++) {\n        if (k in t) {\n            value = callback(value, t[k], k, t);\n        }\n    }\n    return value;\n};\n","/**\n * @author Justin Fagnani\n * @see https://github.com/justinfagnani/mixwith.js\n */\nimport { reduce } from '../polyfills/reduce.js';\n\n/**\n * Mix a class with a mixin.\n * @method mix(...).with(...)\n * @memberof! DNA.\n * @static\n *\n * @param {Function} superClass The class to extend.\n * @return {Function} A mixed class.\n *\n * @example\n * ```js\n * // my-super.js\n * export class MySuperClass {\n *     constructor() {\n *         // do something\n *     }\n * }\n * ```\n * ```js\n * // mixin.js\n * export const Mixin = (superClass) => class extend superClass {\n *     constructor() {\n *         super();\n *         // do something else\n *     }\n * };\n * ```\n * ```js\n * import { mix } from '@dnajs/core';\n * import { MySuperClass } from './my-super.js';\n * import { Mixin } from './mixin.js';\n *\n * export class MixedClass extends mix(MySuperClass).with(Mixin) {\n *     ...\n * }\n * ```\n */\n\n/**\n * A Mixin helper class.\n * @ignore\n */\nclass Mixin {\n    /**\n     * Create a mixable class.\n     * @param {Function} superClass The class to extend.\n     */\n    constructor(superclass) {\n        superclass = superclass || class {};\n        this.superclass = superclass;\n    }\n    /**\n     * Mix the super class with a list of mixins.\n     * @param {...Function} mixins *N* mixin functions.\n     * @return {Function} The extended class.\n     */\n    with() {\n        // eslint-disable-next-line\n        let args = [].slice.call(arguments, 0);\n        return reduce.call(args, (c, mixin) => mixin(c), this.superclass);\n    }\n}\n\n/**\n * Create a Mixin instance.\n * @ignore\n */\nexport const mix = (superClass) => new Mixin(superClass);\n","import { registry } from './registry.js';\nimport { isString } from './typeof.js';\n\n/**\n * Check if a node is already instantiated HTMLElement for programmatically `constructor` calls.\n * @private\n * @param {HTMLElement} node The node to check.\n * @return {Boolean} The node should be instantiated.\n */\nfunction isNew(node) {\n    try {\n        return !isString(node.outerHTML);\n    } catch (ex) {\n        return true;\n    }\n}\n\n/**\n * Shim original Element constructors in order to be used with `new`.\n * @method shim\n * @memberof! DNA.\n * @static\n *\n * @param {Function} Original The original constructor to shim.\n * @return {Function} The shimmed constructor.\n *\n * @example\n * ```js\n * // shim audio element\n * import { shim } from '@dnajs/core';\n *\n * class MyAudio extends shim(HTMLAudioElement) {\n *     ...\n * }\n *\n * let audio = new MyAudio();\n * ```\n */\nexport function shim(Original) {\n    class Polyfilled {\n        constructor() {\n            if (!isNew(this)) {\n                return this;\n            }\n            let desc = registry.getDescriptor(this.constructor);\n            let config = desc.config;\n            // Find the tagname of the constructor and create a new element with it\n            let element = document.createElement(\n                config.extends ? config.extends : desc.is\n            );\n            element.__proto__ = desc.Ctr.prototype;\n            if (config.extends) {\n                element.setAttribute('is', desc.is);\n            }\n            return element;\n        }\n    }\n    // Clone the prototype overriding the constructor.\n    Polyfilled.prototype = Object.create(Original.prototype, {\n        constructor: {\n            value: Polyfilled,\n            configurable: true,\n            writable: true,\n        },\n    });\n    return Polyfilled;\n}\n","import * as DOM_HELPERS from './lib/dom.js';\nimport { ComponentMixin } from './mixins/component.js';\nimport { PropertiesMixin } from './mixins/properties-component.js';\nimport { EventsMixin } from './mixins/events-component.js';\nimport { StyleMixin } from './mixins/style-component.js';\nimport { TemplateMixin } from './mixins/template-component.js';\n\n/**\n * A set of DOM helpers for callbacks trigger when Custom Elements\n * are not supported by the browser.\n * @name DOM\n * @namespace DOM\n * @memberof! DNA.\n * @static\n */\nexport const DOM = DOM_HELPERS;\n/**\n * A set of core mixins.\n * @name MIXINS\n * @namespace MIXINS\n * @memberof! DNA.\n * @static\n */\nexport const MIXINS = {\n    ComponentMixin,\n    PropertiesMixin,\n    EventsMixin,\n    StyleMixin,\n    TemplateMixin,\n};\nexport { mix } from './lib/mixins.js';\nexport { prop } from './lib/property.js';\nexport { shim } from './lib/shim.js';\nexport * from './lib/symbols.js';\nexport * from './lib/typeof.js';\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\n/**\n * A constructor function that will create blank objects.\n * @constructor\n */\nfunction Blank() {}\n\nBlank.prototype = Object.create(null);\n\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nconst has = function(map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nconst createMap = function() {\n  return new Blank();\n};\n\n\n/** */\nexport {\n  createMap,\n  has\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createMap } from './util';\n\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const {!Object<string, *>}\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * Whether or not the statics have been applied for the node yet.\n   * {boolean}\n   */\n  this.staticsApplied = false;\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {!Object<string, !Element>}\n   */\n  this.keyMap = createMap();\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * @type {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * Whether or the associated node is, or contains, a focused Element.\n   * @type {boolean}\n   */\n  this.focused = false;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nconst initData = function(node, nodeName, key) {\n  const data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {?Node} node The Node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nconst getData = function(node) {\n  importNode(node);\n  return node['__incrementalDOMData'];\n};\n\n\n/**\n * Imports node and its subtree, initializing caches.\n *\n * @param {?Node} node The Node to import.\n */\nconst importNode = function(node) {\n  if (node['__incrementalDOMData']) {\n    return;\n  }\n\n  const isElement = node instanceof Element;\n  const nodeName = isElement ? node.localName : node.nodeName;\n  const key = isElement ? node.getAttribute('key') : null;\n  const data = initData(node, nodeName, key);\n\n  if (key) {\n    getData(node.parentNode).keyMap[key] = node;\n  }\n\n  if (isElement) {\n    const attributes = node.attributes;\n    const attrs = data.attrs;\n    const newAttrs = data.newAttrs;\n    const attrsArr = data.attrsArr;\n\n    for (let i = 0; i < attributes.length; i += 1) {\n      const attr = attributes[i];\n      const name = attr.name;\n      const value = attr.value;\n\n      attrs[name] = value;\n      newAttrs[name] = undefined;\n      attrsArr.push(name);\n      attrsArr.push(value);\n    }\n  }\n\n  for (let child = node.firstChild; child; child = child.nextSibling) {\n    importNode(child);\n  }\n};\n\n\n/** */\nexport {\n  getData,\n  initData,\n  importNode\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n    getData,\n    initData\n} from './node_data';\n\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @param {?Node} parent\n * @return {?string} The namespace to create the tag in.\n */\nconst getNamespaceForTag = function(tag, parent) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n\n  if (getData(parent).nodeName === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n};\n\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {?Node} parent\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @return {!Element}\n */\nconst createElement = function(doc, parent, tag, key) {\n  const namespace = getNamespaceForTag(tag, parent);\n  let el;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  return el;\n};\n\n\n/**\n * Creates a Text Node.\n * @param {Document} doc The document with which to create the Element.\n * @return {!Text}\n */\nconst createText = function(doc) {\n  const node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n};\n\n\n/** */\nexport {\n  createElement,\n  createText\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nconst notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\nexport {\n  notifications\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { notifications } from './notifications';\n\n\n/**\n * Keeps track of the state of a patch.\n * @constructor\n */\nfunction Context() {\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = notifications.nodesDeleted && [];\n}\n\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function(node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function(node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function() {\n  if (this.created && this.created.length > 0) {\n    notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    notifications.nodesDeleted(this.deleted);\n  }\n};\n\n\n/** */\nexport {\n  Context\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n  * Keeps track whether or not we are in an attributes declaration (after\n  * elementOpenStart, but before elementOpenEnd).\n  * @type {boolean}\n  */\nlet inAttributes = false;\n\n\n/**\n  * Keeps track whether or not we are in an element that should not have its\n  * children cleared.\n  * @type {boolean}\n  */\nlet inSkip = false;\n\n\n/**\n * Makes sure that there is a current patch context.\n * @param {string} functionName\n * @param {*} context\n */\nconst assertInPatch = function(functionName, context) {\n  if (!context) {\n    throw new Error('Cannot call ' + functionName + '() unless in patch.');\n  }\n};\n\n\n/**\n * Makes sure that a patch closes every node that it opened.\n * @param {?Node} openElement\n * @param {!Node|!DocumentFragment} root\n */\nconst assertNoUnclosedTags = function(openElement, root) {\n  if (openElement === root) {\n    return;\n  }\n\n  let currentElement = openElement;\n  const openTags = [];\n  while (currentElement && currentElement !== root) {\n    openTags.push(currentElement.nodeName.toLowerCase());\n    currentElement = currentElement.parentNode;\n  }\n\n  throw new Error('One or more tags were not closed:\\n' +\n      openTags.join('\\n'));\n};\n\n\n/**\n * Makes sure that the caller is not where attributes are expected.\n * @param {string} functionName\n */\nconst assertNotInAttributes = function(functionName) {\n  if (inAttributes) {\n    throw new Error(functionName + '() can not be called between ' +\n        'elementOpenStart() and elementOpenEnd().');\n  }\n};\n\n\n/**\n * Makes sure that the caller is not inside an element that has declared skip.\n * @param {string} functionName\n */\nconst assertNotInSkip = function(functionName) {\n  if (inSkip) {\n    throw new Error(functionName + '() may not be called inside an element ' +\n        'that has called skip().');\n  }\n};\n\n\n/**\n * Makes sure that the caller is where attributes are expected.\n * @param {string} functionName\n */\nconst assertInAttributes = function(functionName) {\n  if (!inAttributes) {\n    throw new Error(functionName + '() can only be called after calling ' +\n        'elementOpenStart().');\n  }\n};\n\n\n/**\n * Makes sure the patch closes virtual attributes call\n */\nconst assertVirtualAttributesClosed = function() {\n  if (inAttributes) {\n    throw new Error('elementOpenEnd() must be called after calling ' +\n        'elementOpenStart().');\n  }\n};\n\n\n/**\n  * Makes sure that tags are correctly nested.\n  * @param {string} nodeName\n  * @param {string} tag\n  */\nconst assertCloseMatchesOpenTag = function(nodeName, tag) {\n  if (nodeName !== tag) {\n    throw new Error('Received a call to close \"' + tag + '\" but \"' +\n        nodeName + '\" was open.');\n  }\n};\n\n\n/**\n * Makes sure that no children elements have been declared yet in the current\n * element.\n * @param {string} functionName\n * @param {?Node} previousNode\n */\nconst assertNoChildrenDeclaredYet = function(functionName, previousNode) {\n  if (previousNode !== null) {\n    throw new Error(functionName + '() must come before any child ' +\n        'declarations inside the current element.');\n  }\n};\n\n\n/**\n * Checks that a call to patchOuter actually patched the element.\n * @param {?Node} startNode The value for the currentNode when the patch\n *     started.\n * @param {?Node} currentNode The currentNode when the patch finished.\n * @param {?Node} expectedNextNode The Node that is expected to follow the\n *    currentNode after the patch;\n * @param {?Node} expectedPrevNode The Node that is expected to preceed the\n *    currentNode after the patch.\n */\nconst assertPatchElementNoExtras = function(\n    startNode,\n    currentNode,\n    expectedNextNode,\n    expectedPrevNode) {\n  const wasUpdated = currentNode.nextSibling === expectedNextNode &&\n                     currentNode.previousSibling === expectedPrevNode;\n  const wasChanged = currentNode.nextSibling === startNode.nextSibling &&\n                     currentNode.previousSibling === expectedPrevNode;\n  const wasRemoved = currentNode === startNode;\n\n  if (!wasUpdated && !wasChanged && !wasRemoved) {\n    throw new Error('There must be exactly one top level call corresponding ' +\n        'to the patched element.');\n  }\n};\n\n\n/**\n * Updates the state of being in an attribute declaration.\n * @param {boolean} value\n * @return {boolean} the previous value.\n */\nconst setInAttributes = function(value) {\n  const previous = inAttributes;\n  inAttributes = value;\n  return previous;\n};\n\n\n/**\n * Updates the state of being in a skip element.\n * @param {boolean} value\n * @return {boolean} the previous value.\n */\nconst setInSkip = function(value) {\n  const previous = inSkip;\n  inSkip = value;\n  return previous;\n};\n\n\n/** */\nexport {\n  assertInPatch,\n  assertNoUnclosedTags,\n  assertNotInAttributes,\n  assertInAttributes,\n  assertCloseMatchesOpenTag,\n  assertVirtualAttributesClosed,\n  assertNoChildrenDeclaredYet,\n  assertNotInSkip,\n  assertPatchElementNoExtras,\n  setInAttributes,\n  setInSkip\n};\n","/**\n * Copyright 2016 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * @param {!Node} node\n * @return {boolean} True if the node the root of a document, false otherwise.\n */\nconst isDocumentRoot = function(node) {\n  // For ShadowRoots, check if they are a DocumentFragment instead of if they\n  // are a ShadowRoot so that this can work in 'use strict' if ShadowRoots are\n  // not supported.\n  return node instanceof Document || node instanceof DocumentFragment;\n};\n\n\n/**\n * @param {!Node} node The node to start at, inclusive.\n * @param {?Node} root The root ancestor to get until, exclusive.\n * @return {!Array<!Node>} The ancestry of DOM nodes.\n */\nconst getAncestry = function(node, root) {\n  const ancestry = [];\n  let cur = node;\n\n  while (cur !== root) {\n    ancestry.push(cur);\n    cur = cur.parentNode;\n  }\n\n  return ancestry;\n};\n\n\n/**\n * @param {!Node} node\n * @return {!Node} The root node of the DOM tree that contains node.\n */\nconst getRoot = function(node) {\n  let cur = node;\n  let prev = cur;\n\n  while (cur) {\n    prev = cur;\n    cur = cur.parentNode;\n  }\n\n  return prev;\n};\n\n\n/**\n * @param {!Node} node The node to get the activeElement for.\n * @return {?Element} The activeElement in the Document or ShadowRoot\n *     corresponding to node, if present.\n */\nconst getActiveElement = function(node) {\n  const root = getRoot(node);\n  return isDocumentRoot(root) ? root.activeElement : null;\n};\n\n\n/**\n * Gets the path of nodes that contain the focused node in the same document as\n * a reference node, up until the root.\n * @param {!Node} node The reference node to get the activeElement for.\n * @param {?Node} root The root to get the focused path until.\n * @return {!Array<Node>}\n */\nconst getFocusedPath = function(node, root) {\n  const activeElement = getActiveElement(node);\n\n  if (!activeElement || !node.contains(activeElement)) {\n    return [];\n  }\n\n  return getAncestry(activeElement, root);\n};\n\n\n/**\n * Like insertBefore, but instead instead of moving the desired node, instead\n * moves all the other nodes after.\n * @param {?Node} parentNode\n * @param {!Node} node\n * @param {?Node} referenceNode\n */\nconst moveBefore = function(parentNode, node, referenceNode) {\n  const insertReferenceNode = node.nextSibling;\n  let cur = referenceNode;\n\n  while (cur !== node) {\n    const next = cur.nextSibling;\n    parentNode.insertBefore(cur, insertReferenceNode);\n    cur = next;\n  }\n};\n\n\n/** */\nexport {\n  getFocusedPath,\n  moveBefore\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  createElement,\n  createText\n} from './nodes';\nimport { getData } from './node_data';\nimport { Context } from './context';\nimport {\n  assertInPatch,\n  assertNoUnclosedTags,\n  assertNotInAttributes,\n  assertVirtualAttributesClosed,\n  assertNoChildrenDeclaredYet,\n  assertPatchElementNoExtras,\n  setInAttributes,\n  setInSkip\n} from './assertions';\nimport {\n  getFocusedPath,\n  moveBefore\n} from './dom_util';\n\n\n/** @type {?Context} */\nlet context = null;\n\n/** @type {?Node} */\nlet currentNode = null;\n\n/** @type {?Node} */\nlet currentParent = null;\n\n/** @type {?Document} */\nlet doc = null;\n\n\n/**\n * @param {!Array<Node>} focusPath The nodes to mark.\n * @param {boolean} focused Whether or not they are focused.\n */\nconst markFocused = function(focusPath, focused) {\n  for (let i = 0; i < focusPath.length; i += 1) {\n    getData(focusPath[i]).focused = focused;\n  }\n};\n\n\n/**\n * Returns a patcher function that sets up and restores a patch context,\n * running the run function with the provided data.\n * @param {function((!Element|!DocumentFragment),!function(T),T=): ?Node} run\n * @return {function((!Element|!DocumentFragment),!function(T),T=): ?Node}\n * @template T\n */\nconst patchFactory = function(run) {\n  /**\n   * TODO(moz): These annotations won't be necessary once we switch to Closure\n   * Compiler's new type inference. Remove these once the switch is done.\n   *\n   * @param {(!Element|!DocumentFragment)} node\n   * @param {!function(T)} fn\n   * @param {T=} data\n   * @return {?Node} node\n   * @template T\n   */\n  const f = function(node, fn, data) {\n    const prevContext = context;\n    const prevDoc = doc;\n    const prevCurrentNode = currentNode;\n    const prevCurrentParent = currentParent;\n    let previousInAttributes = false;\n    let previousInSkip = false;\n\n    context = new Context();\n    doc = node.ownerDocument;\n    currentParent = node.parentNode;\n\n    if (process.env.NODE_ENV !== 'production') {\n      previousInAttributes = setInAttributes(false);\n      previousInSkip = setInSkip(false);\n    }\n\n    const focusPath = getFocusedPath(node, currentParent);\n    markFocused(focusPath, true);\n    const retVal = run(node, fn, data);\n    markFocused(focusPath, false);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assertVirtualAttributesClosed();\n      setInAttributes(previousInAttributes);\n      setInSkip(previousInSkip);\n    }\n\n    context.notifyChanges();\n\n    context = prevContext;\n    doc = prevDoc;\n    currentNode = prevCurrentNode;\n    currentParent = prevCurrentParent;\n\n    return retVal;\n  };\n  return f;\n};\n\n\n/**\n * Patches the document starting at node with the provided function. This\n * function may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @return {!Node} The patched node.\n * @template T\n */\nconst patchInner = patchFactory(function(node, fn, data) {\n  currentNode = node;\n\n  enterNode();\n  fn(data);\n  exitNode();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoUnclosedTags(currentNode, node);\n  }\n\n  return node;\n});\n\n\n/**\n * Patches an Element with the the provided function. Exactly one top level\n * element call should be made corresponding to `node`.\n * @param {!Element} node The Element where the patch should start.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM. This should have at most one top level\n *     element call.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @return {?Node} The node if it was updated, its replacedment or null if it\n *     was removed.\n * @template T\n */\nconst patchOuter = patchFactory(function(node, fn, data) {\n  let startNode = /** @type {!Element} */({ nextSibling: node });\n  let expectedNextNode = null;\n  let expectedPrevNode = null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    expectedNextNode = node.nextSibling;\n    expectedPrevNode = node.previousSibling;\n  }\n\n  currentNode = startNode;\n  fn(data);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertPatchElementNoExtras(startNode, currentNode, expectedNextNode,\n        expectedPrevNode);\n  }\n\n  if (node !== currentNode && node.parentNode) {\n    removeChild(currentParent, node, getData(currentParent).keyMap);\n  }\n\n  return (startNode === currentNode) ? null : currentNode;\n});\n\n\n/**\n * Checks whether or not the current node matches the specified nodeName and\n * key.\n *\n * @param {!Node} matchNode A node to match the data to.\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nconst matches = function(matchNode, nodeName, key) {\n  const data = getData(matchNode);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return nodeName === data.nodeName && key == data.key;\n};\n\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n */\nconst alignWithDOM = function(nodeName, key) {\n  if (currentNode && matches(currentNode, nodeName, key)) {\n    return;\n  }\n\n  const parentData = getData(currentParent);\n  const currentNodeData = currentNode && getData(currentNode);\n  const keyMap = parentData.keyMap;\n  let node;\n\n  // Check to see if the node has moved within the parent.\n  if (key) {\n    const keyNode = keyMap[key];\n    if (keyNode) {\n      if (matches(keyNode, nodeName, key)) {\n        node = keyNode;\n      } else if (keyNode === currentNode) {\n        context.markDeleted(keyNode);\n      } else {\n        removeChild(currentParent, keyNode, keyMap);\n      }\n    }\n  }\n\n  // Create the node if it doesn't exist.\n  if (!node) {\n    if (nodeName === '#text') {\n      node = createText(doc);\n    } else {\n      node = createElement(doc, currentParent, nodeName, key);\n    }\n\n    if (key) {\n      keyMap[key] = node;\n    }\n\n    context.markCreated(node);\n  }\n\n  // Re-order the node into the right position, preserving focus if either\n  // node or currentNode are focused by making sure that they are not detached\n  // from the DOM.\n  if (getData(node).focused) {\n    // Move everything else before the node.\n    moveBefore(currentParent, node, currentNode);\n  } else if (currentNodeData && currentNodeData.key && !currentNodeData.focused) {\n    // Remove the currentNode, which can always be added back since we hold a\n    // reference through the keyMap. This prevents a large number of moves when\n    // a keyed item is removed or moved backwards in the DOM.\n    currentParent.replaceChild(node, currentNode);\n    parentData.keyMapValid = false;\n  } else {\n    currentParent.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n};\n\n\n/**\n * @param {?Node} node\n * @param {?Node} child\n * @param {?Object<string, !Element>} keyMap\n */\nconst removeChild = function(node, child, keyMap) {\n  node.removeChild(child);\n  context.markDeleted(/** @type {!Node}*/(child));\n\n  const key = getData(child).key;\n  if (key) {\n    delete keyMap[key];\n  }\n};\n\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n */\nconst clearUnvisitedDOM = function() {\n  const node = currentParent;\n  const data = getData(node);\n  const keyMap = data.keyMap;\n  const keyMapValid = data.keyMapValid;\n  let child = node.lastChild;\n  let key;\n\n  if (child === currentNode && keyMapValid) {\n    return;\n  }\n\n  while (child !== currentNode) {\n    removeChild(node, child, keyMap);\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  if (!keyMapValid) {\n    for (key in keyMap) {\n      child = keyMap[key];\n      if (child.parentNode !== node) {\n        context.markDeleted(child);\n        delete keyMap[key];\n      }\n    }\n\n    data.keyMapValid = true;\n  }\n};\n\n\n/**\n * Changes to the first child of the current node.\n */\nconst enterNode = function() {\n  currentParent = currentNode;\n  currentNode = null;\n};\n\n\n/**\n * @return {?Node} The next Node to be patched.\n */\nconst getNextNode = function() {\n  if (currentNode) {\n    return currentNode.nextSibling;\n  } else {\n    return currentParent.firstChild;\n  }\n};\n\n\n/**\n * Changes to the next sibling of the current node.\n */\nconst nextNode = function() {\n  currentNode = getNextNode();\n};\n\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nconst exitNode = function() {\n  clearUnvisitedDOM();\n\n  currentNode = currentParent;\n  currentParent = currentParent.parentNode;\n};\n\n\n/**\n * Makes sure that the current node is an Element with a matching tagName and\n * key.\n *\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @return {!Element} The corresponding Element.\n */\nconst elementOpen = function(tag, key) {\n  nextNode();\n  alignWithDOM(tag, key);\n  enterNode();\n  return /** @type {!Element} */(currentParent);\n};\n\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n *\n * @return {!Element} The corresponding Element.\n */\nconst elementClose = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    setInSkip(false);\n  }\n\n  exitNode();\n  return /** @type {!Element} */(currentNode);\n};\n\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n *\n * @return {!Text} The corresponding Text Node.\n */\nconst text = function() {\n  nextNode();\n  alignWithDOM('#text', null);\n  return /** @type {!Text} */(currentNode);\n};\n\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nconst currentElement = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInPatch('currentElement', context);\n    assertNotInAttributes('currentElement');\n  }\n  return /** @type {!Element} */(currentParent);\n};\n\n\n/**\n * @return {Node} The Node that will be evaluated for the next instruction.\n */\nconst currentPointer = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInPatch('currentPointer', context);\n    assertNotInAttributes('currentPointer');\n  }\n  return getNextNode();\n};\n\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nconst skip = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoChildrenDeclaredYet('skip', currentNode);\n    setInSkip(true);\n  }\n  currentNode = currentParent.lastChild;\n};\n\n\n/**\n * Skips the next Node to be patched, moving the pointer forward to the next\n * sibling of the current pointer.\n */\nconst skipNode = nextNode;\n\n\n/** */\nexport {\n  elementOpen,\n  elementClose,\n  text,\n  patchInner,\n  patchOuter,\n  currentElement,\n  currentPointer,\n  skip,\n  skipNode\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nconst symbols = {\n  default: '__default'\n};\n\n/** */\nexport {\n  symbols\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getData } from './node_data';\nimport { symbols } from './symbols';\nimport {\n  createMap,\n  has\n} from './util';\n\n\n/**\n * @param {string} name\n * @return {string|undefined} The namespace to use for the attribute.\n */\nconst getNamespace = function(name) {\n  if (name.lastIndexOf('xml:', 0) === 0) {\n    return 'http://www.w3.org/XML/1998/namespace';\n  }\n\n  if (name.lastIndexOf('xlink:', 0) === 0) {\n    return 'http://www.w3.org/1999/xlink';\n  }\n};\n\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nconst applyAttr = function(el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    const attrNS = getNamespace(name);\n    if (attrNS) {\n      el.setAttributeNS(attrNS, name, value);\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nconst applyProp = function(el, name, value) {\n  el[name] = value;\n};\n\n\n/**\n * Applies a value to a style declaration. Supports CSS custom properties by\n * setting properties containing a dash using CSSStyleDeclaration.setProperty.\n * @param {CSSStyleDeclaration} style\n * @param {!string} prop\n * @param {*} value\n */\nconst setStyleValue = function(style, prop, value) {\n  if (prop.indexOf('-') >= 0) {\n    style.setProperty(prop, /** @type {string} */(value));\n  } else {\n    style[prop] = value;\n  }\n};\n\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nconst applyStyle = function(el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    const elStyle = el.style;\n    const obj = /** @type {!Object<string,string>} */(style);\n\n    for (const prop in obj) {\n      if (has(obj, prop)) {\n        setStyleValue(elStyle, prop, obj[prop]);\n      }\n    }\n  }\n};\n\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nconst applyAttributeTyped = function(el, name, value) {\n  const type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    applyProp(el, name, value);\n  } else {\n    applyAttr(el, name, /** @type {?(boolean|number|string)} */(value));\n  }\n};\n\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nconst updateAttribute = function(el, name, value) {\n  const data = getData(el);\n  const attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  const mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nconst attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\n\nattributes['style'] = applyStyle;\n\n\n/** */\nexport {\n  updateAttribute,\n  applyProp,\n  applyAttr,\n  attributes\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  elementOpen as coreElementOpen,\n  elementClose as coreElementClose,\n  text as coreText\n} from './core';\nimport { updateAttribute } from './attributes';\nimport { getData } from './node_data';\nimport {\n  assertNotInAttributes,\n  assertNotInSkip,\n  assertInAttributes,\n  assertCloseMatchesOpenTag,\n  setInAttributes\n} from './assertions';\n\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nconst ATTRIBUTES_OFFSET = 3;\n\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nconst argsBuilder = [];\n\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args, Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nconst elementOpen = function(tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementOpen');\n    assertNotInSkip('elementOpen');\n  }\n\n  const node = coreElementOpen(tag, key);\n  const data = getData(node);\n\n  if (!data.staticsApplied) {\n    if (statics) {\n      for (let i = 0; i < statics.length; i += 2) {\n        const name = /** @type {string} */(statics[i]);\n        const value = statics[i + 1];\n        updateAttribute(node, name, value);\n      }\n    }\n    // Down the road, we may want to keep track of the statics array to use it\n    // as an additional signal about whether a node matches or not. For now,\n    // just use a marker so that we do not reapply statics.\n    data.staticsApplied = true;\n  }\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  const attrsArr = data.attrsArr;\n  const newAttrs = data.newAttrs;\n  const isNew = !attrsArr.length;\n  let i = ATTRIBUTES_OFFSET;\n  let j = 0;\n\n  for (; i < arguments.length; i += 2, j += 2) {\n    const attr = arguments[i];\n    if (isNew) {\n      attrsArr[j] = attr;\n      newAttrs[attr] = undefined;\n    } else if (attrsArr[j] !== attr) {\n      break;\n    }\n\n    const value = arguments[i + 1];\n    if (isNew || attrsArr[j + 1] !== value) {\n      attrsArr[j + 1] = value;\n      updateAttribute(node, attr, value);\n    }\n  }\n\n  if (i < arguments.length || j < attrsArr.length) {\n    for (; i < arguments.length; i += 1, j += 1) {\n      attrsArr[j] = arguments[i];\n    }\n\n    if (j < attrsArr.length) {\n      attrsArr.length = j;\n    }\n\n    /*\n     * Actually perform the attribute update.\n     */\n    for (i = 0; i < attrsArr.length; i += 2) {\n      const name = /** @type {string} */(attrsArr[i]);\n      const value = attrsArr[i + 1];\n      newAttrs[name] = value;\n    }\n\n    for (const attr in newAttrs) {\n      updateAttribute(node, attr, newAttrs[attr]);\n      newAttrs[attr] = undefined;\n    }\n  }\n\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nconst elementOpenStart = function(tag, key, statics) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementOpenStart');\n    setInAttributes(true);\n  }\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nconst attr = function(name, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes('attr');\n  }\n\n  argsBuilder.push(name);\n  argsBuilder.push(value);\n};\n\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nconst elementOpenEnd = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes('elementOpenEnd');\n    setInAttributes(false);\n  }\n\n  const node = elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nconst elementClose = function(tag) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementClose');\n  }\n\n  const node = coreElementClose();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertCloseMatchesOpenTag(getData(node).nodeName, tag);\n  }\n\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nconst elementVoid = function(tag, key, statics, var_args) {\n  elementOpen.apply(null, arguments);\n  return elementClose(tag);\n};\n\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} var_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nconst text = function(value, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('text');\n    assertNotInSkip('text');\n  }\n\n  const node = coreText();\n  const data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */(value);\n\n    let formatted = value;\n    for (let i = 1; i < arguments.length; i += 1) {\n      /*\n       * Call the formatter function directly to prevent leaking arguments.\n       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n       */\n      const fn = arguments[i];\n      formatted = fn(formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  return node;\n};\n\n\n/** */\nexport {\n  elementOpenStart,\n  elementOpenEnd,\n  elementOpen,\n  elementVoid,\n  elementClose,\n  text,\n  attr\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport {\n  patchInner as patch,\n  patchInner,\n  patchOuter,\n  currentElement,\n  currentPointer,\n  skip,\n  skipNode\n} from './src/core';\nexport {\n  elementVoid,\n  elementOpenStart,\n  elementOpenEnd,\n  elementOpen,\n  elementClose,\n  text,\n  attr\n} from './src/virtual_elements';\nexport { symbols } from './src/symbols';\nexport {\n  attributes,\n  applyAttr,\n  applyProp\n} from './src/attributes';\nexport { notifications } from './src/notifications';\nexport { importNode } from './src/node_data';\n","/**\n * DNA\n * (c) 2015-2016 Chialab (http://www.chialab.com) <dev@chialab.io>\n * http://dna.chialab.io\n *\n * Just another components pattern.\n * Use with Custom Elements specs.\n */\nimport { mix, prop, shim, DOM, MIXINS } from './src/core.js';\nimport { registry } from './src/lib/registry.js';\n\n/**\n * @namespace DNA\n */\nexport { mix, prop, shim, DOM, MIXINS };\nexport { registry };\n\n/**\n * Register a new component.\n * @method define\n * @memberof! DNA.\n * @static\n *\n * @param {String} name The id of the component.\n * @param {Function} Ctr The component constructor.\n * @param {Object} config Optional component configuration.\n */\nexport function define(tagName, Component, config) {\n    return registry.define(tagName, Component, config);\n}\n/**\n * Create and append a new component instance.\n * @method render\n * @memberof! DNA.\n * @static\n *\n * @param {HTMLElement} node The parent node.\n * @param {Function} Component The component constructor.\n * @param {Object} props Optional set of properties to set to the component.\n * @return {HTMLElement} The new component instance.\n */\nexport function render(node, Component, props) {\n    let element = new Component();\n    for (let k in props) {\n        element[k] = props[k];\n    }\n    DOM.appendChild(node, element);\n    return element;\n}\n\n/**\n * Simple Custom Component with some behaviors.\n * @class BaseComponent\n * @extends HTMLElement\n * @memberof DNA.\n * @static\n *\n * @example\n * ```js\n * // my-component.js\n * import { BaseComponent } from '@dnajs/core';\n * export class MyComponent extends BaseComponent {\n *   static get observedAttributes() {\n *     return ['...', '...'];\n *   }\n *   get css() {\n *     return '...';\n *   }\n *   get events() {\n *     return {\n *       '...': '...'\n *     };\n *   }\n *   get template() {\n *     return '...';\n *   }\n *   get properties() {\n *     return { ... };\n *   }\n * }\n * ```\n */\nexport class BaseComponent extends mix(\n    shim(self.HTMLElement)\n).with(\n    MIXINS.ComponentMixin,\n    MIXINS.PropertiesMixin,\n    MIXINS.StyleMixin,\n    MIXINS.EventsMixin,\n    MIXINS.TemplateMixin\n) {}\n"],"names":["isFunction","obj","isString","isObject","Object","prototype","toString","call","isUndefined","isArray","Array","registry","name","Ctr","config","components","toLowerCase","k","desc","getDescriptor","COMPONENT_SYMBOL","CONNECTED","DISCONNECTED","UPDATED","getComponent","element","full","node","nodeType","Node","ELEMENT_NODE","getAttribute","tagName","get","isComponent","connect","disconnect","update","oldValue","newValue","bind","__proto__","defineProperty","createElement","is","appendChild","parent","parentNode","lastElementChild","removeChild","insertBefore","refNode","nextSibling","replaceChild","setAttribute","value","attrs","constructor","observedAttributes","indexOf","removeAttribute","ComponentMixin","SuperClass","connectedCallback","disconnectedCallback","attributeChangedCallback","localName","CustomEvent","ev","self","ex","event","params","undefined","evt","document","createEvent","initCustomEvent","bubbles","cancelable","detail","dispatch","evName","data","TypeError","dispatchEvent","define","Property","ctrs","_","validator","_setter","val","getterFn","setterFn","validateType","changed","scope","observe","callback","push","unobserve","io","splice","i","len","length","clb","accepts","named","attrRequested","attrName","default","initValue","defaultValue","freeze","attribute","eventName","getter","setter","validate","init","prop","String","Boolean","Number","getValue","property","attrVal","JSON","parse","context","attr","currentAttrValue","PropertiesMixin","props","properties","reduce","res","partialProps","observed","hasAttribute","oldVal","newVal","observeProperty","propName","unobserveProperty","ELEM_PROTO","Element","matches","matchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","SPLIT_SELECTOR","EventsMixin","events","rule","match","selector","trim","delegate","addEventListener","target","trigger","rootDoc","createStyle","doc","ownerDocument","styleElem","type","head","firstElementChild","StyleMixin","updateCSS","classList","add","style","css","textContent","TemplateMixin","autoRender","template","render","tpl","innerHTML","t","arguments","Mixin","superclass","with","args","slice","c","mixin","mix","superClass","isNew","outerHTML","shim","Original","Polyfilled","extends","create","DOM","DOM_HELPERS","MIXINS","hasOwnProperty","Blank","has","map","createMap","NodeData","nodeName","key","attrsArr","newAttrs","staticsApplied","keyMap","keyMapValid","focused","text","initData","getData","importNode","isElement","attributes","child","firstChild","getNamespaceForTag","tag","namespaceURI","namespace","el","createElementNS","createText","createTextNode","notifications","Context","created","nodesCreated","deleted","nodesDeleted","markCreated","markDeleted","notifyChanges","inAttributes","inSkip","assertNoUnclosedTags","openElement","root","currentElement","openTags","Error","join","assertNotInAttributes","functionName","assertNotInSkip","assertInAttributes","assertVirtualAttributesClosed","assertCloseMatchesOpenTag","assertNoChildrenDeclaredYet","previousNode","assertPatchElementNoExtras","startNode","currentNode","expectedNextNode","expectedPrevNode","wasUpdated","previousSibling","wasChanged","wasRemoved","setInAttributes","previous","setInSkip","isDocumentRoot","Document","DocumentFragment","getAncestry","ancestry","cur","getRoot","prev","getActiveElement","activeElement","getFocusedPath","contains","moveBefore","referenceNode","insertReferenceNode","next","currentParent","markFocused","focusPath","patchFactory","run","f","fn","prevContext","prevDoc","prevCurrentNode","prevCurrentParent","previousInAttributes","previousInSkip","retVal","patchInner","matchNode","alignWithDOM","parentData","currentNodeData","keyNode","clearUnvisitedDOM","lastChild","enterNode","getNextNode","nextNode","exitNode","elementOpen","elementClose","skip","symbols","getNamespace","lastIndexOf","applyAttr","attrNS","setAttributeNS","applyProp","setStyleValue","setProperty","applyStyle","cssText","elStyle","applyAttributeTyped","updateAttribute","mutator","ATTRIBUTES_OFFSET","argsBuilder","statics","var_args","coreElementOpen","j","elementOpenStart","elementOpenEnd","apply","coreElementClose","coreText","formatted","Component","BaseComponent","HTMLElement"],"mappings":"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","preExisting":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbIi9Vc2Vycy9lZG9hcmRvL0RldmVsb3BtZW50L2RuYS9kbmEtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvQGRuYWpzL2NvcmUvc3JjL2xpYi90eXBlb2YuanMiLCIvVXNlcnMvZWRvYXJkby9EZXZlbG9wbWVudC9kbmEvZG5hLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL0BkbmFqcy9jb3JlL3NyYy9saWIvcmVnaXN0cnkuanMiLCIvVXNlcnMvZWRvYXJkby9EZXZlbG9wbWVudC9kbmEvZG5hLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL0BkbmFqcy9jb3JlL3NyYy9saWIvc3ltYm9scy5qcyIsIi9Vc2Vycy9lZG9hcmRvL0RldmVsb3BtZW50L2RuYS9kbmEtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvQGRuYWpzL2NvcmUvc3JjL2xpYi9kb20uanMiLCIvVXNlcnMvZWRvYXJkby9EZXZlbG9wbWVudC9kbmEvZG5hLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL0BkbmFqcy9jb3JlL3NyYy9taXhpbnMvY29tcG9uZW50LmpzIiwiL1VzZXJzL2Vkb2FyZG8vRGV2ZWxvcG1lbnQvZG5hL2RuYS1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9AZG5hanMvY29yZS9zcmMvcG9seWZpbGxzL2N1c3RvbS1ldmVudC5qcyIsIi9Vc2Vycy9lZG9hcmRvL0RldmVsb3BtZW50L2RuYS9kbmEtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvQGRuYWpzL2NvcmUvc3JjL2xpYi9kaXNwYXRjaC5qcyIsIi9Vc2Vycy9lZG9hcmRvL0RldmVsb3BtZW50L2RuYS9kbmEtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvQGRuYWpzL2NvcmUvc3JjL2xpYi9wcm9wZXJ0eS5qcyIsIi9Vc2Vycy9lZG9hcmRvL0RldmVsb3BtZW50L2RuYS9kbmEtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvQGRuYWpzL2NvcmUvc3JjL21peGlucy9wcm9wZXJ0aWVzLWNvbXBvbmVudC5qcyIsIi9Vc2Vycy9lZG9hcmRvL0RldmVsb3BtZW50L2RuYS9kbmEtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvQGRuYWpzL2NvcmUvc3JjL3BvbHlmaWxscy9tYXRjaGVzLmpzIiwiL1VzZXJzL2Vkb2FyZG8vRGV2ZWxvcG1lbnQvZG5hL2RuYS1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9AZG5hanMvY29yZS9zcmMvbWl4aW5zL2V2ZW50cy1jb21wb25lbnQuanMiLCIvVXNlcnMvZWRvYXJkby9EZXZlbG9wbWVudC9kbmEvZG5hLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL0BkbmFqcy9jb3JlL3NyYy9saWIvc3R5bGUuanMiLCIvVXNlcnMvZWRvYXJkby9EZXZlbG9wbWVudC9kbmEvZG5hLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL0BkbmFqcy9jb3JlL3NyYy9taXhpbnMvc3R5bGUtY29tcG9uZW50LmpzIiwiL1VzZXJzL2Vkb2FyZG8vRGV2ZWxvcG1lbnQvZG5hL2RuYS1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9AZG5hanMvY29yZS9zcmMvbWl4aW5zL3RlbXBsYXRlLWNvbXBvbmVudC5qcyIsIi9Vc2Vycy9lZG9hcmRvL0RldmVsb3BtZW50L2RuYS9kbmEtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvQGRuYWpzL2NvcmUvc3JjL3BvbHlmaWxscy9yZWR1Y2UuanMiLCIvVXNlcnMvZWRvYXJkby9EZXZlbG9wbWVudC9kbmEvZG5hLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL0BkbmFqcy9jb3JlL3NyYy9saWIvbWl4aW5zLmpzIiwiL1VzZXJzL2Vkb2FyZG8vRGV2ZWxvcG1lbnQvZG5hL2RuYS1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9AZG5hanMvY29yZS9zcmMvbGliL3NoaW0uanMiLCIvVXNlcnMvZWRvYXJkby9EZXZlbG9wbWVudC9kbmEvZG5hLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL0BkbmFqcy9jb3JlL3NyYy9jb3JlLmpzIiwiL1VzZXJzL2Vkb2FyZG8vRGV2ZWxvcG1lbnQvZG5hL2RuYS1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9pbmNyZW1lbnRhbC1kb20vc3JjL3V0aWwuanMiLCIvVXNlcnMvZWRvYXJkby9EZXZlbG9wbWVudC9kbmEvZG5hLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2luY3JlbWVudGFsLWRvbS9zcmMvbm9kZV9kYXRhLmpzIiwiL1VzZXJzL2Vkb2FyZG8vRGV2ZWxvcG1lbnQvZG5hL2RuYS1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9pbmNyZW1lbnRhbC1kb20vc3JjL25vZGVzLmpzIiwiL1VzZXJzL2Vkb2FyZG8vRGV2ZWxvcG1lbnQvZG5hL2RuYS1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9pbmNyZW1lbnRhbC1kb20vc3JjL25vdGlmaWNhdGlvbnMuanMiLCIvVXNlcnMvZWRvYXJkby9EZXZlbG9wbWVudC9kbmEvZG5hLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2luY3JlbWVudGFsLWRvbS9zcmMvY29udGV4dC5qcyIsIi9Vc2Vycy9lZG9hcmRvL0RldmVsb3BtZW50L2RuYS9kbmEtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvaW5jcmVtZW50YWwtZG9tL3NyYy9hc3NlcnRpb25zLmpzIiwiL1VzZXJzL2Vkb2FyZG8vRGV2ZWxvcG1lbnQvZG5hL2RuYS1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9pbmNyZW1lbnRhbC1kb20vc3JjL2RvbV91dGlsLmpzIiwiL1VzZXJzL2Vkb2FyZG8vRGV2ZWxvcG1lbnQvZG5hL2RuYS1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9pbmNyZW1lbnRhbC1kb20vc3JjL2NvcmUuanMiLCIvVXNlcnMvZWRvYXJkby9EZXZlbG9wbWVudC9kbmEvZG5hLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2luY3JlbWVudGFsLWRvbS9zcmMvc3ltYm9scy5qcyIsIi9Vc2Vycy9lZG9hcmRvL0RldmVsb3BtZW50L2RuYS9kbmEtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvaW5jcmVtZW50YWwtZG9tL3NyYy9hdHRyaWJ1dGVzLmpzIiwiL1VzZXJzL2Vkb2FyZG8vRGV2ZWxvcG1lbnQvZG5hL2RuYS1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9pbmNyZW1lbnRhbC1kb20vc3JjL3ZpcnR1YWxfZWxlbWVudHMuanMiLCIvVXNlcnMvZWRvYXJkby9EZXZlbG9wbWVudC9kbmEvZG5hLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2luY3JlbWVudGFsLWRvbS9pbmRleC5qcyIsIi9Vc2Vycy9lZG9hcmRvL0RldmVsb3BtZW50L2RuYS9kbmEtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvQGRuYWpzL2NvcmUvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDaGVjayBpZiBhbiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICogQG1ldGhvZCBpc0Z1bmN0aW9uXG4gKiBAbWVtYmVyb2YhIEROQS5cbiAqIEBzdGF0aWNcbiAqXG4gKiBAcGFyYW0geyp9IG9iaiBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogQ2hlY2sgaWYgYW4gdmFsdWUgaXMgYSBzdHJpbmcuXG4gKiBAbWV0aG9kIGlzU3RyaW5nXG4gKiBAbWVtYmVyb2YhIEROQS5cbiAqIEBzdGF0aWNcbiAqXG4gKiBAcGFyYW0geyp9IG9iaiBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdzdHJpbmcnO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhbiB2YWx1ZSBpcyBhbiBvYmplY3QuXG4gKiBAbWV0aG9kIGlzT2JqZWN0XG4gKiBAbWVtYmVyb2YhIEROQS5cbiAqIEBzdGF0aWNcbiAqXG4gKiBAcGFyYW0geyp9IG9iaiBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cbi8qKlxuICogQ2hlY2sgaWYgYW4gdmFsdWUgaXMgdW5kZWZpbmVkLlxuICogQG1ldGhvZCBpc1VuZGVmaW5lZFxuICogQG1lbWJlcm9mISBETkEuXG4gKiBAc3RhdGljXG4gKlxuICogQHBhcmFtIHsqfSBvYmogVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJztcbn1cbi8qKlxuICogQ2hlY2sgaWYgYW4gdmFsdWUgaXMgYW4gYXJyYXkuXG4gKiBAbWV0aG9kIGlzQXJyYXlcbiAqIEBtZW1iZXJvZiEgRE5BLlxuICogQHN0YXRpY1xuICpcbiAqIEBwYXJhbSB7Kn0gb2JqIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iaik7XG59XG4iLCJpbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc1N0cmluZyB9IGZyb20gJy4vdHlwZW9mLmpzJztcblxuLyoqXG4gKiBBIGN1c3RvbSBjb21wb25lbnRzIHJlZ2lzdHJ5LlxuICogSXQgcmVwbGljYXRlcyB0aGUgW0N1c3RvbUVsZW1lbnRSZWdpc3RyeSBpbnRlcmZhY2VdKGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jdXN0b20tZWxlbWVudHMvI2N1c3RvbS1lbGVtZW50cy1hcGkpLlxuICogQG5hbWUgcmVnaXN0cnlcbiAqIEBuYW1lc3BhY2UgcmVnaXN0cnlcbiAqIEBtZW1iZXJvZiEgRE5BLlxuICogQHN0YXRpY1xuICovXG5leHBvcnQgY29uc3QgcmVnaXN0cnkgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIGxpc3Qgb2YgZGVmaW5lZCBjb21wb25lbnRzLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgY29tcG9uZW50czoge30sXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBuZXcgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBpZCBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IEN0ciBUaGUgY29tcG9uZW50IGNvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgT3B0aW9uYWwgY29tcG9uZW50IGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgZGVmaW5lKG5hbWUsIEN0ciwgY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzW25hbWUudG9Mb3dlckNhc2UoKV0gPSB7XG4gICAgICAgICAgICBpczogbmFtZSxcbiAgICAgICAgICAgIEN0cixcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgY29tcG9uZW50IGRlc2NyaXB0b3IgYnkgaWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgY29tcG9uZW50IGlkLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbXBvbmVudCBkZXNjcmlwdG9yLlxuICAgICAqL1xuICAgIGdldERlc2NyaXB0b3IobmFtZSkge1xuICAgICAgICBpZiAoaXNTdHJpbmcobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudHNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKG5hbWUpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBrIGluIHRoaXMuY29tcG9uZW50cykge1xuICAgICAgICAgICAgICAgIGxldCBkZXNjID0gdGhpcy5jb21wb25lbnRzW2tdO1xuICAgICAgICAgICAgICAgIGlmIChkZXNjLkN0ciA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgY29tcG9uZW50IGNvbnN0cnVjdG9yIGJ5IGlkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBjb21wb25lbnQgaWQuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBjb21wb25lbnQgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgZ2V0KG5hbWUpIHtcbiAgICAgICAgbGV0IGRlc2MgPSB0aGlzLmdldERlc2NyaXB0b3IobmFtZSk7XG4gICAgICAgIGlmIChkZXNjKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzYy5DdHI7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbiIsImV4cG9ydCBjb25zdCBDT01QT05FTlRfU1lNQk9MID0gJ19fY29tcG9uZW50JztcbiIsImltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuL3R5cGVvZi5qcyc7XG5pbXBvcnQgeyByZWdpc3RyeSB9IGZyb20gJy4vcmVnaXN0cnkuanMnO1xuaW1wb3J0IHsgQ09NUE9ORU5UX1NZTUJPTCB9IGZyb20gJy4vc3ltYm9scy5qcyc7XG5cbi8qKlxuICogVGhlIGBjb25uZWN0ZWRDYWxsYmFja2AgbmFtZS5cbiAqIEBwcml2YXRlXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBzZWUgW1czQyBzcGVjXShodHRwczovL3d3dy53My5vcmcvVFIvY3VzdG9tLWVsZW1lbnRzLyNjdXN0b20tZWxlbWVudC1yZWFjdGlvbnMpXG4gKi9cbmNvbnN0IENPTk5FQ1RFRCA9ICdjb25uZWN0ZWRDYWxsYmFjayc7XG4vKipcbiAqIFRoZSBgZGlzY29ubmVjdGVkQ2FsbGJhY2tgIG5hbWUuXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAc2VlIFtXM0Mgc3BlY10oaHR0cHM6Ly93d3cudzMub3JnL1RSL2N1c3RvbS1lbGVtZW50cy8jY3VzdG9tLWVsZW1lbnQtcmVhY3Rpb25zKVxuICovXG5jb25zdCBESVNDT05ORUNURUQgPSAnZGlzY29ubmVjdGVkQ2FsbGJhY2snO1xuLyoqXG4gKiBUaGUgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AgbmFtZS5cbiAqIEBwcml2YXRlXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBzZWUgW1czQyBzcGVjXShodHRwczovL3d3dy53My5vcmcvVFIvY3VzdG9tLWVsZW1lbnRzLyNjdXN0b20tZWxlbWVudC1yZWFjdGlvbnMpXG4gKi9cbmNvbnN0IFVQREFURUQgPSAnYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJztcbi8qKlxuICogUmV0cmlldmUgYSBjb21wb25lbnQgY29uc3RydWN0b3IgZnJvbSBhbiBFbGVtZW50IG9yIGZyb20gYSB0YWcgbmFtZS5cbiAqIEBtZXRob2QgZ2V0Q29tcG9uZW50XG4gKiBAbWVtYmVyb2YgRE5BLkRPTVxuICogQHN0YXRpY1xuICpcbiAqIEBwYXJhbSB7Q29tcG9uZW50fFN0cmluZ30gZWxlbWVudCBUaGUgZWxlbWVudCBvciB0aGUgdGFnIG5hbWUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgUmV0cmlldmUgZnVsbCBjb21wb25lbnQgaW5mb3JtYXRpb24uXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBmb3IgdGhlIGdpdmVuIHBhcmFtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tcG9uZW50KGVsZW1lbnQsIGZ1bGwgPSBmYWxzZSkge1xuICAgIGlmIChlbGVtZW50Lm5vZGUpIHtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQubm9kZTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaXMnKSB8fCBlbGVtZW50LnRhZ05hbWU7XG4gICAgfVxuICAgIHJldHVybiBmdWxsID8gcmVnaXN0cnkuZ2V0RGVzY3JpcHRvcihlbGVtZW50KSA6IHJlZ2lzdHJ5LmdldChlbGVtZW50KTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBub2RlIGlzIGFuIGluc3RhbmNlIG9mIGEgY29tcG9uZW50LlxuICogQG1ldGhvZCBpc0NvbXBvbmVudFxuICogQG1lbWJlcm9mIEROQS5ET01cbiAqIEBzdGF0aWNcbiAqXG4gKiBAcGFyYW0ge0NvbXBvbmVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBjaGVjay5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbXBvbmVudChlbGVtZW50KSB7XG4gICAgbGV0IEN0ciA9IGdldENvbXBvbmVudChlbGVtZW50KTtcbiAgICByZXR1cm4gQ3RyICYmIChlbGVtZW50IGluc3RhbmNlb2YgQ3RyKTtcbn1cbi8qKlxuICogQW4gaGVscGVyIGZvciBkeW5hbWljYWxseSB0cmlnZ2VyIHRoZSBgY29ubmVjdGVkQ2FsbGJhY2tgIHJlYWN0aW9uIG9uIGNvbXBvbmVudHMuXG4gKiBAbWV0aG9kIGNvbm5lY3RcbiAqIEBtZW1iZXJvZiBETkEuRE9NXG4gKiBAc3RhdGljXG4gKlxuICogQHBhcmFtIHtDb21wb25lbnR9IGVsZW1lbnQgVGhlIGF0dGFjaGVkIG5vZGUuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUaGUgY2FsbGJhY2sgaGFzIGJlZW4gdHJpZ2dlcmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29ubmVjdChlbGVtZW50KSB7XG4gICAgaWYgKGlzQ29tcG9uZW50KGVsZW1lbnQpKSB7XG4gICAgICAgIGVsZW1lbnRbQ09OTkVDVEVEXS5jYWxsKGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGhlbHBlciBmb3IgZHluYW1pY2FsbHkgdHJpZ2dlciB0aGUgYGRpc2Nvbm5lY3RlZENhbGxiYWNrYCByZWFjdGlvbiBvbiBjb21wb25lbnRzLlxuICogQG1ldGhvZCBkaXNjb25uZWN0XG4gKiBAbWVtYmVyb2YgRE5BLkRPTVxuICogQHN0YXRpY1xuICpcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBlbGVtZW50IFRoZSBkZXRhY2hlZCBub2RlLlxuICogQHJldHVybiB7Qm9vbGVhbn0gVGhlIGNhbGxiYWNrIGhhcyBiZWVuIHRyaWdnZXJlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc2Nvbm5lY3QoZWxlbWVudCkge1xuICAgIGlmIChpc0NvbXBvbmVudChlbGVtZW50KSkge1xuICAgICAgICBlbGVtZW50W0RJU0NPTk5FQ1RFRF0uY2FsbChlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBoZWxwZXIgZm9yIGR5bmFtaWNhbGx5IHRyaWdnZXIgdGhlIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgIHJlYWN0aW9uIG9uIGNvbXBvbmVudHMuXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICogQG1lbWJlcm9mIEROQS5ET01cbiAqIEBzdGF0aWNcbiAqXG4gKiBAcGFyYW0ge0NvbXBvbmVudH0gZWxlbWVudCBUaGUgdXBkYXRlZCBlbGVtZW50LlxuICogQHJldHVybiB7Qm9vbGVhbn0gVGhlIGNhbGxiYWNrIGhhcyBiZWVuIHRyaWdnZXJlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZShlbGVtZW50LCBuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICBpZiAoaXNDb21wb25lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgZWxlbWVudFtVUERBVEVEXS5jYWxsKGVsZW1lbnQsIG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbi8qKlxuICogQXR0YWNoIGEgY29tcG9uZW50IHByb3RvdHlwZSB0byBhbiBhbHJlYWR5IGluc3RhbnRpYXRlZCBIVE1MRWxlbWVudC5cbiAqIEBtZXRob2QgYmluZFxuICogQG1lbWJlcm9mIEROQS5ET01cbiAqIEBzdGF0aWNcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIFRoZSBub2RlIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IEN0ciBUaGUgY29tcG9uZW50IGNsYXNzIHRvIHVzZSAobGVhdmUgZW1wdHkgZm9yIGF1dG8gZGV0ZWN0KS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRoZSBwcm90b3R5cGUgaGFzIGJlZW4gYXR0YWNoZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kKG5vZGUsIEN0cikge1xuICAgIGlmICghaXNGdW5jdGlvbihDdHIpKSB7XG4gICAgICAgIEN0ciA9IGdldENvbXBvbmVudChub2RlKTtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24oQ3RyKSkge1xuICAgICAgICBub2RlLl9fcHJvdG9fXyA9IEN0ci5wcm90b3R5cGU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLCAnY29uc3RydWN0b3InLCB7XG4gICAgICAgICAgICB2YWx1ZTogQ3RyLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBDdHIuY2FsbChub2RlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgY29tcG9uZW50IGluc3RhbmNlLlxuICogQG1ldGhvZCBjcmVhdGVFbGVtZW50XG4gKiBAbWVtYmVyb2YgRE5BLkRPTVxuICogQHN0YXRpY1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpcyBUaGUgY29tcG9uZW50IHRhZyBuYW1lLlxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9IFRoZSBjb21wb25lbnQgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KGlzKSB7XG4gICAgbGV0IEN0ciA9IGdldENvbXBvbmVudChpcyk7XG4gICAgaWYgKEN0cikge1xuICAgICAgICByZXR1cm4gbmV3IEN0cigpO1xuICAgIH1cbn1cbi8qKlxuICogRHluYW1pY2FsbHkgYXBwZW5kIGEgbm9kZSBhbmQgY2FsbCB0aGUgYGNvbm5lY3RlZENhbGxiYWNrYC5cbiAqIC0gZGlzY29ubmVjdCB0aGUgbm9kZSBpZiBhbHJlYWR5IGluIHRoZSB0cmVlXG4gKiAtIGNvbm5lY3QgdGhlIG5vZGUgYWZ0ZXIgdGhlIGluc2VydGlvblxuICogQG1ldGhvZCBhcHBlbmRDaGlsZFxuICogQG1lbWJlcm9mIEROQS5ET01cbiAqIEBzdGF0aWNcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnQgVGhlIHBhcmVudCBlbGVtZW50LlxuICogQHBhcmFtIHtDb21wb25lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gYXBwZW5kLlxuICogQHJldHVybiB7Qm9vbGVhbn0gVGhlIG5vZGUgaGFzIGJlZW4gYXBwZW5kZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRDaGlsZChwYXJlbnQsIGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5ub2RlKSB7XG4gICAgICAgIGxldCBub2RlID0gZWxlbWVudC5ub2RlO1xuICAgICAgICBpZiAocGFyZW50ICE9PSBub2RlLnBhcmVudE5vZGUgfHwgcGFyZW50Lmxhc3RFbGVtZW50Q2hpbGQgIT09IG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVDaGlsZChub2RlLnBhcmVudE5vZGUsIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3QoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBEeW5hbWljYWxseSByZW1vdmUgYSBub2RlIGFuZCBjYWxsIHRoZSBgZGlzY29ubmVjdGVkQ2FsbGJhY2tgLlxuICogQG1ldGhvZCByZW1vdmVDaGlsZFxuICogQG1lbWJlcm9mIEROQS5ET01cbiAqIEBzdGF0aWNcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnQgVGhlIHBhcmVudCBlbGVtZW50LlxuICogQHBhcmFtIHtDb21wb25lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICogQHJldHVybiB7Qm9vbGVhbn0gVGhlIG5vZGUgaGFzIGJlZW4gcmVtb3ZlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudCwgZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50Lm5vZGUpIHtcbiAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQubm9kZSk7XG4gICAgICAgIHJldHVybiBkaXNjb25uZWN0KGVsZW1lbnQpO1xuICAgIH1cbn1cbi8qKlxuICogRHluYW1pY2FsbHkgaW5zZXJ0IGEgbm9kZSBiZWZvcmUgYW5vdGhlciBhbmQgY2FsbCBhbGwgdGhlIHJlYWN0aW9ucy5cbiAqIC0gZGlzY29ubmVjdCB0aGUgbm9kZSBpZiBhbHJlYWR5IGluIHRoZSB0cmVlXG4gKiAtIGNvbm5lY3QgdGhlIG5vZGUgYWZ0ZXIgdGhlIGluc2VydGlvblxuICogQG1ldGhvZCBpbnNlcnRCZWZvcmVcbiAqIEBtZW1iZXJvZiBETkEuRE9NXG4gKiBAc3RhdGljXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50IFRoZSBwYXJlbnQgZWxlbWVudC5cbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGluc2VydC5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZk5vZGUgVGhlIG5vZGUgZm9yIHBvc2l0aW9uaW5nLlxuICogQHJldHVybiB7Qm9vbGVhbn0gVGhlIG5vZGUgaGFzIGJlZW4gYXBwZW5kZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50LCBlbGVtZW50LCByZWZOb2RlKSB7XG4gICAgaWYgKGVsZW1lbnQubm9kZSkge1xuICAgICAgICBsZXQgbm9kZSA9IGVsZW1lbnQubm9kZTtcbiAgICAgICAgaWYgKG5vZGUubmV4dFNpYmxpbmcgIT09IHJlZk5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBkaXNjb25uZWN0KGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCByZWZOb2RlKTtcbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0KGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBEeW5hbWljYWxseSByZXBsYWNlIGEgbm9kZSB3aXRoIGFub3RoZXIgYW5kIGNhbGwgYWxsIHRoZSByZWFjdGlvbnMuXG4gKiAtIGRpc2Nvbm5lY3QgdGhlIG5vZGUgaWYgYWxyZWFkeSBpbiB0aGUgdHJlZVxuICogLSBkaXNjb25uZWN0IHRoZSByZXBsYWNlZCBub2RlXG4gKiAtIGNvbm5lY3QgdGhlIGZpcnN0IG5vZGUgYWZ0ZXIgdGhlIGluc2VydGlvblxuICogQG1ldGhvZCByZXBsYWNlQ2hpbGRcbiAqIEBtZW1iZXJvZiBETkEuRE9NXG4gKiBAc3RhdGljXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50IFRoZSBwYXJlbnQgZWxlbWVudC5cbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGluc2VydC5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZk5vZGUgVGhlIG5vZGUgdG8gcmVwbGFjZS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRoZSBub2RlIGhhcyBiZWVuIGFwcGVuZGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZUNoaWxkKHBhcmVudCwgZWxlbWVudCwgcmVmTm9kZSkge1xuICAgIGlmIChlbGVtZW50Lm5vZGUpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBlbGVtZW50Lm5vZGU7XG4gICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGRpc2Nvbm5lY3QoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZChub2RlLCByZWZOb2RlKTtcbiAgICAgICAgaWYgKHJlZk5vZGVbQ09NUE9ORU5UX1NZTUJPTF0pIHtcbiAgICAgICAgICAgIGRpc2Nvbm5lY3QocmVmTm9kZVtDT01QT05FTlRfU1lNQk9MXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Qobm9kZSk7XG4gICAgfVxufVxuLyoqXG4gKiBEeW5hbWljYWxseSB1cGRhdGUgYSBub2RlIGF0dHJpYnV0ZSBhbmQgY2FsbCBhbGwgdGhlIHJlYWN0aW9ucy5cbiAqIEBtZXRob2Qgc2V0QXR0cmlidXRlXG4gKiBAbWVtYmVyb2YgRE5BLkRPTVxuICogQHN0YXRpY1xuICpcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgYXR0cmlidXRlIHZhbHVlLlxuICogQHJldHVybiB7Qm9vbGVhbn0gVGhlIG5vZGUgaGFzIGJlZW4gdXBkYXRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChlbGVtZW50Lm5vZGUpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBlbGVtZW50Lm5vZGU7XG4gICAgICAgIGxldCBvbGRWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGxldCBhdHRycyA9IGVsZW1lbnQuY29uc3RydWN0b3Iub2JzZXJ2ZWRBdHRyaWJ1dGVzIHx8IFtdO1xuICAgICAgICBpZiAoYXR0cnMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGUoZWxlbWVudCwgbmFtZSwgb2xkVmFsdWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogRHluYW1pY2FsbHkgcmVtb3ZlIGEgbm9kZSBhdHRyaWJ1dGUgYW5kIGNhbGwgYWxsIHRoZSByZWFjdGlvbnMuXG4gKiBAbWV0aG9kIHJlbW92ZUF0dHJpYnV0ZVxuICogQG1lbWJlcm9mIEROQS5ET01cbiAqIEBzdGF0aWNcbiAqXG4gKiBAcGFyYW0ge0NvbXBvbmVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgYXR0cmlidXRlIG5hbWUuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUaGUgbm9kZSBoYXMgYmVlbiB1cGRhdGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsIG5hbWUpIHtcbiAgICBpZiAoZWxlbWVudC5ub2RlKSB7XG4gICAgICAgIGxldCBub2RlID0gZWxlbWVudC5ub2RlO1xuICAgICAgICBsZXQgb2xkVmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIGxldCBhdHRycyA9IGVsZW1lbnQuY29uc3RydWN0b3Iub2JzZXJ2ZWRBdHRyaWJ1dGVzIHx8IFtdO1xuICAgICAgICBpZiAoYXR0cnMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGUoZWxlbWVudCwgbmFtZSwgb2xkVmFsdWUsIG51bGwpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ09NUE9ORU5UX1NZTUJPTCB9IGZyb20gJy4uL2xpYi9zeW1ib2xzLmpzJztcblxuLyoqXG4gKiBUSGUgYmFzZSBjdXN0b20gY29tcG9uZW50IG1peGlucy4gSnVzdCBhZGQgbGlmZSBjeWNsZXMgY2FsbGJhY2sgYW5kIGBpc2AgZ2V0dGVyLlxuICogQG1peGluIENvbXBvbmVudE1peGluXG4gKiBAbWVtYmVyb2YgRE5BLk1JWElOU1xuICogQHN0YXRpY1xuICovXG5leHBvcnQgY29uc3QgQ29tcG9uZW50TWl4aW4gPSAoU3VwZXJDbGFzcykgPT4gY2xhc3MgZXh0ZW5kcyBTdXBlckNsYXNzIHtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gaXMgR2V0IGNvbXBvbmVudCBpZC5cbiAgICAgKiBAbmFtZSBpc1xuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQG1lbWJlcm9mIEROQS5NSVhJTlMuQ29tcG9uZW50TWl4aW5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBnZXQgaXMoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5nZXRBdHRyaWJ1dGUoJ2lzJykgfHwgdGhpcy5sb2NhbE5hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IG5vZGUgR2V0IGNvbXBvbmVudCBub2RlIHJlZmVyZW5jZS5cbiAgICAgKiBAbmFtZSBub2RlXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqIEBtZW1iZXJvZiBETkEuTUlYSU5TLkNvbXBvbmVudE1peGluXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZ2V0IG5vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIGFuIGluc3RhbmNlIHdhcyBpbnNlcnRlZCBpbnRvIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAbWV0aG9kIGNvbm5lY3RlZENhbGxiYWNrXG4gICAgICogQG1lbWJlcm9mIEROQS5NSVhJTlMuQ29tcG9uZW50TWl4aW5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdGhpcy5ub2RlW0NPTVBPTkVOVF9TWU1CT0xdID0gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiBhbiBpbnN0YW5jZSB3YXMgZGV0YWNoZWQgZnJvbSB0aGUgZG9jdW1lbnQuXG4gICAgICogQG1ldGhvZCBkaXNjb25uZWN0ZWRDYWxsYmFja1xuICAgICAqIEBtZW1iZXJvZiBETkEuTUlYSU5TLkNvbXBvbmVudE1peGluXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7fVxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gYW4gYXR0cmlidXRlIHdhcyBhZGRlZCwgcmVtb3ZlZCwgb3IgdXBkYXRlZC5cbiAgICAgKiBAbWV0aG9kIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja1xuICAgICAqIEBtZW1iZXJvZiBETkEuTUlYSU5TLkNvbXBvbmVudE1peGluXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ck5hbWUgVGhlIGNoYW5nZWQgYXR0cmlidXRlIG5hbWUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbCBUaGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBiZWZvcmUgdGhlIGNoYW5nZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3VmFsIFRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIGFmdGVyIHRoZSBjaGFuZ2UuXG4gICAgICovXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCkge31cbn07XG4iLCJsZXQgQ3VzdG9tRXZlbnQ7XG5cbnRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgbGV0IGV2ID0gbmV3IHNlbGYuQ3VzdG9tRXZlbnQoJ3Rlc3QnKTtcbiAgICBDdXN0b21FdmVudCA9IHNlbGYuQ3VzdG9tRXZlbnQ7XG59IGNhdGNoKGV4KSB7XG4gICAgQ3VzdG9tRXZlbnQgPSBmdW5jdGlvbihldmVudCwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7XG4gICAgICAgICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZGV0YWlsOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgICAgICAgcmV0dXJuIGV2dDtcbiAgICB9O1xuICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHNlbGYuQ3VzdG9tRXZlbnQucHJvdG90eXBlO1xufVxuXG5leHBvcnQgeyBDdXN0b21FdmVudCB9O1xuIiwiaW1wb3J0IHsgaXNTdHJpbmcgfSBmcm9tICcuL3R5cGVvZi5qcyc7XG5pbXBvcnQgeyBDdXN0b21FdmVudCB9IGZyb20gJy4uL3BvbHlmaWxscy9jdXN0b20tZXZlbnQuanMnO1xuXG4vKipcbiAqIFRyaWdnZXIgYSBjdXN0b20gRE9NIEV2ZW50LlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBldk5hbWUgVGhlIGN1c3RvbSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgRXh0cmEgZGF0YSB0byBwYXNzIHRvIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYnViYmxlcyBFbmFibGUgZXZlbnQgYnViYmxpbmcuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNhbmNlbGFibGUgTWFrZSBldmVudCBjYW5jZWxhYmxlLlxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBldmVudCBwcm9wYWdhdGlvbiBoYXMgbm90IGJlIHN0b3BwZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNwYXRjaChub2RlLCBldk5hbWUsIGRhdGEsIGJ1YmJsZXMgPSB0cnVlLCBjYW5jZWxhYmxlID0gdHJ1ZSkge1xuICAgIGlmICghaXNTdHJpbmcoZXZOYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFdmVudCBuYW1lIGlzIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBsZXQgZXYgPSBuZXcgQ3VzdG9tRXZlbnQoZXZOYW1lLCB7XG4gICAgICAgIGRldGFpbDogZGF0YSxcbiAgICAgICAgYnViYmxlcyxcbiAgICAgICAgY2FuY2VsYWJsZSxcbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZS5kaXNwYXRjaEV2ZW50KGV2KTtcbn1cbiIsImltcG9ydCB7IGlzVW5kZWZpbmVkLCBpc0Z1bmN0aW9uLCBpc0FycmF5LCBpc09iamVjdCwgaXNTdHJpbmcgfSBmcm9tICcuL3R5cGVvZi5qcyc7XG5cbi8qKlxuICogU2hvcnRjdXQgdG8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAuXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBkZWZpbmUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbi8qKlxuICogUG93ZXIgdG8gdGhlIGNvbXBvbmVudCdzIHByb3BlcnRpZXMuXG4gKiBUeXBlIGNoZWNraW5nLCB2YWxpZGF0aW9uLCBjYWxsYmFja3MsIGV2ZW50cyBhbmQgYXR0cmlidXRlIHN5bmNpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBQcm9wZXJ0eSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgUHJvcGVydHkgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxBcnJheX0gQSBzaW5nbGUgb3IgYSBsaXN0IG9mIHZhbGlkIGNvbnN0cnVjdG9ycyBmb3IgdGhlIHByb3BlcnR5IHZhbHVlLlxuICAgICAqIEByZXR1cm4ge1Byb3BlcnR5fVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGN0cnMpIHtcbiAgICAgICAgdGhpcy5fID0gW107XG4gICAgICAgIGN0cnMgPSBjdHJzIHx8IFtdO1xuICAgICAgICBpZiAoIWlzQXJyYXkoY3RycykpIHtcbiAgICAgICAgICAgIGN0cnMgPSBbY3Ryc107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdHJzID0gY3RycztcbiAgICAgICAgdGhpcy52YWxpZGF0b3IgPSAoKSA9PiB0cnVlO1xuICAgICAgICB0aGlzLl9zZXR0ZXIgPSAodmFsKSA9PiB2YWw7XG4gICAgICAgIHRoaXMuZ2V0dGVyRm4gPSAoKSA9PiB0aGlzLnZhbHVlO1xuICAgICAgICB0aGlzLnNldHRlckZuID0gKHZhbCkgPT4ge1xuICAgICAgICAgICAgdmFsID0gdGhpcy5fc2V0dGVyKHZhbCk7XG4gICAgICAgICAgICBpZiAoKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlVHlwZSh2YWwpICYmIHRoaXMudmFsaWRhdG9yKHZhbCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCh2YWwsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBJbnZhbGlkIFxcYCR7dmFsfVxcYCB2YWx1ZSBmb3IgXFxgJHt0aGlzLm5hbWV9XFxgIHByb3BlcnR5IGZvciBcXGAke3RoaXMuc2NvcGUuaXN9XFxgLmBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjYWxsYmFjayB3aGVuIHRoZSBwcm9wZXJ0eSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byB0cmlnZ2VyLlxuICAgICAqIEByZXR1cm4ge1Byb3BlcnR5fSBUaGUgcHJvcGVydHkgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIG9ic2VydmUoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spIHx8IGlzU3RyaW5nKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5fLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBjYWxsYmFjayBvbiBwcm9wZXJ0eSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byByZW1vdmUuXG4gICAgICogQHJldHVybiB7UHJvcGVydHl9IFRoZSBwcm9wZXJ0eSBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgdW5vYnNlcnZlKGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBpbyA9IHRoaXMuXy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGlvICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fLnNwbGljZShpbywgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgY2FsbGJhY2tzIGFmdGVyIGEgY2hhbmdlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBuZXdWYWx1ZSBUaGUgY3VycmVudCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlIFRoZSBwcmV2aW91cyBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKi9cbiAgICBjaGFuZ2VkKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5fLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2xiID0gdGhpcy5fW2ldO1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGNsYikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjb3BlW2NsYl0uY2FsbCh0aGlzLnNjb3BlLCB0aGlzLCBuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGIodGhpcywgbmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHByb3BlcnR5IGFjY2VwdHMgYSBnaXZlbiB0eXBlIGFzIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IEN0ciBUaGUgY29uc3RydWN0b3IgZm9yIHRoZSBnaXZlbiB0eXBlLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgYWNjZXB0cyhDdHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Rycy5pbmRleE9mKEN0cikgIT09IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHByb3BlcnR5IG5hbWUuXG4gICAgICogSXQgYWxzbyBzZXQgdGhlIGF0dHJOYW1lIGlmIGAuYXR0cmlidXRlYCBtZXRob2QgYXMgYmVlbiBwcmV2aW91c2x5XG4gICAgICogaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgcHJvcGVydHkgbmFtZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9wZXJ0eX0gVGhlIHByb3BlcnR5IGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBuYW1lZChuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIGlmICh0aGlzLmF0dHJSZXF1ZXN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0ck5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcHJvcGVydHkgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IGluaXRWYWx1ZSBUaGUgcHJvcGVydHkgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9wZXJ0eX0gVGhlIHByb3BlcnR5IGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBkZWZhdWx0KGluaXRWYWx1ZSkge1xuICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IGlzT2JqZWN0KGluaXRWYWx1ZSkgP1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShpbml0VmFsdWUpIDpcbiAgICAgICAgICAgIGluaXRWYWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgYXR0cmlidXRlIG5hbWUgdG8gc3luYy5cbiAgICAgKiBJbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBpdCByZXRyaWV2ZSB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9wZXJ0eX0gVGhlIHByb3BlcnR5IGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBhdHRyaWJ1dGUoYXR0ck5hbWUgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1N0cmluZyhhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0clJlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hdHRyTmFtZSA9IGF0dHJOYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hdHRyUmVxdWVzdGVkID0gISFhdHRyTmFtZTtcbiAgICAgICAgICAgIHRoaXMuYXR0ck5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIERPTSBldmVudCBuYW1lIHRvIGRpc3BhdGNoIG9uIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2TmFtZSBUaGUgZXZlbnQgbmFtZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9wZXJ0eX0gVGhlIHByb3BlcnR5IGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBkaXNwYXRjaChldk5hbWUpIHtcbiAgICAgICAgdGhpcy5ldmVudE5hbWUgPSBldk5hbWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSBnZXR0ZXIgZnVuY3Rpb24gZm9yIHRoZSBwcm9wZXJ0eS5cbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgcHJvcGVydHkgdmFsdWUgd2lsbCBiZSByZXR1cm4uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIHByb3BlcnR5IGdldHRlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9wZXJ0eX0gVGhlIHByb3BlcnR5IGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBnZXR0ZXIoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICB0aGlzLmdldHRlckZuID0gKCkgPT4gY2FsbGJhY2sodGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBhIHNldHRlciBmdW5jdGlvbiBmb3IgdGhlIHByb3BlcnR5LlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBwcm9wZXJ0eSB2YWx1ZSB3aWxsIGJlIHVwZGF0ZWQgd2l0aCBnaXZlbiB2YWx1ZVxuICAgICAqIHdpdGhvdXQgYW55IG1vZGlmaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgcHJvcGVydHkgc2V0dGVyLlxuICAgICAqIEByZXR1cm4ge1Byb3BlcnR5fSBUaGUgcHJvcGVydHkgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHNldHRlcihjYWxsYmFjaykge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHRlciA9IGNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHByb3BlcnR5IHZhbGlkYXRvci5cbiAgICAgKiBBIHZhbGlkYXRvciBzaG91bGQgcmV0dXJuIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYWNjZXB0YWJsZVxuICAgICAqIG9yIGBmYWxzZWAgaWYgdW5hY2NhcHRhYmxlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBwcm9wZXJ0eSB2YWxpZHRvci5cbiAgICAgKiBAcmV0dXJuIHtQcm9wZXJ0eX0gVGhlIHByb3BlcnR5IGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZShjYWxsYmFjaykge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdG9yID0gY2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHR5cGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB2YWxpZGF0ZVR5cGUodmFsKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IGN0cnMgPSB0aGlzLmN0cnM7XG4gICAgICAgIGlmIChjdHJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGkgPCBjdHJzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIGN0cnNbaV0gfHwgKFxuICAgICAgICAgICAgICAgIHZhbC5jb25zdHJ1Y3RvciAmJiB2YWwuY29uc3RydWN0b3IgPT09IGN0cnNbaV1cbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaCB0aGUgcHJvcGVydHkgdG8gYSBzY29wZSAoYSBjb21wb25lbnQgaW5zdGFuY2UpLlxuICAgICAqIFNldCB0aGUgZGVmYXVsdCB2YWx1ZSBpZiBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgVGhlIHNjb3BlIHdoaWNoIG5lZWRzIHRvIGJlIGJvdW5kIHdpdGggdGhlIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGluaXQoc2NvcGUpIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgICAgICBkZWZpbmUoc2NvcGUsIHRoaXMubmFtZSwge1xuICAgICAgICAgICAgZ2V0OiB0aGlzLmdldHRlckZuLmJpbmQodGhpcyksXG4gICAgICAgICAgICBzZXQ6IHRoaXMuc2V0dGVyRm4uYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5kZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgICAgICBzY29wZVt0aGlzLm5hbWVdID0gdGhpcy5kZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogSGVscGVyIG1ldGhvZCBmb3IgUHJvcGVydHkgY3JlYXRpb24uXG4gKiBAbWV0aG9kIHByb3BcbiAqIEBtZW1iZXJvZiEgRE5BLlxuICogQHN0YXRpY1xuICpcbiAqIEBwcm9wZXJ0eSB7UHJvcGVydHl9IEFOWSBBIHByb3BlcnR5IHdpdGhvdXQgdHlwZSB2YWxpZGF0aW9uLlxuICogQHByb3BlcnR5IHtQcm9wZXJ0eX0gU1RSSU5HIEEgcHJvcGVydHkgd2hpY2ggYWNjZXB0cyBvbmx5IHN0cmluZ3MuXG4gKiBAcHJvcGVydHkge1Byb3BlcnR5fSBCT09MRUFOIEEgcHJvcGVydHkgd2hpY2ggYWNjZXB0cyBvbmx5IGJvb2xlYW5zLlxuICogQHByb3BlcnR5IHtQcm9wZXJ0eX0gTlVNQkVSIEEgcHJvcGVydHkgd2hpY2ggYWNjZXB0cyBvbmx5IG51bWJlcnMuXG4gKlxuICogQHBhcmFtIHtQcm9wZXJ0eXxGdW5jdGlvbnxBcnJheX0gY3RycyBBIFByb3BlcnR5IHRvIGNsb25lIG9yIGEgc2luZ2xlIG9yIGEgbGlzdCBvZiB2YWxpZCBjb25zdHJ1Y3RvcnMgZm9yIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqIEByZXR1cm4ge1Byb3BlcnR5fSBUaGUgbmV3IHByb3BlcnR5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvcChjdHJzKSB7XG4gICAgaWYgKGN0cnMgaW5zdGFuY2VvZiBQcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gY3RycztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9wZXJ0eShjdHJzKTtcbn1cblxuLy8gRGVmaW5lIHNvbWUgaGVscGVycyBmb3IgZGVmYXVsdCB0eXBlc1xuZGVmaW5lKHByb3AsICdBTlknLCB7IGdldCgpIHsgcmV0dXJuIHByb3AoKTsgfSB9KTtcbmRlZmluZShwcm9wLCAnU1RSSU5HJywgeyBnZXQoKSB7IHJldHVybiBwcm9wKFN0cmluZyk7IH0gfSk7XG5kZWZpbmUocHJvcCwgJ0JPT0xFQU4nLCB7IGdldCgpIHsgcmV0dXJuIHByb3AoQm9vbGVhbik7IH0gfSk7XG5kZWZpbmUocHJvcCwgJ05VTUJFUicsIHsgZ2V0KCkgeyByZXR1cm4gcHJvcChOdW1iZXIpOyB9IH0pO1xuIiwiaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJy4uL2xpYi90eXBlb2YuanMnO1xuaW1wb3J0IHsgZGlzcGF0Y2ggfSBmcm9tICcuLi9saWIvZGlzcGF0Y2guanMnO1xuaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tICcuLi9saWIvdHlwZW9mLmpzJztcbmltcG9ydCB7IHByb3AgfSBmcm9tICcuLi9saWIvcHJvcGVydHkuanMnO1xuXG4vKipcbiAqIFRyeSB0byBwYXJzZSBhdHRyaWJ1dGUgdmFsdWUgY2hlY2tpbmcgdGhlIHByb3BlcnR5IHZhbGlkYXRpb24gdHlwZXMuXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7UHJvcGVydHl9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eSB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0clZhbCBUaGUgYXR0cmlidXRlIHZhbHVlLlxuICogQHJldHVybiB7Kn0gVGhlIHBhcnNlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUocHJvcGVydHksIGF0dHJWYWwpIHtcbiAgICBpZiAoYXR0clZhbCA9PT0gJycgJiYgcHJvcGVydHkuYWNjZXB0cyhCb29sZWFuKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFwcm9wZXJ0eS5hY2NlcHRzKFN0cmluZykpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGF0dHJWYWwpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXR0clZhbDtcbn1cblxuLyoqXG4gKiBTZXQgYW4gYXR0cmlidXRlIHZhbHVlIGNoZWNraW5nIGl0cyB0eXBlLlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250ZXh0IFRoZSBub2RlIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIFRoZSBhdHRyaWJ1dGUgbmFtZSB0byB1cGRhdGUuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZShjb250ZXh0LCBhdHRyLCB2YWx1ZSkge1xuICAgIGxldCBjdXJyZW50QXR0clZhbHVlID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgaWYgKGN1cnJlbnRBdHRyVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0QXR0cmlidXRlKGF0dHIsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50QXR0clZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBTaW1wbGUgQ3VzdG9tIENvbXBvbmVudCBmb3IgcHJvcGVydGllcyBpbml0aWFsaXphdGlvbiB2aWEgYXR0cmlidXRlcy5cbiAqIEBtaXhpbiBQcm9wZXJ0aWVzTWl4aW5cbiAqIEBtZW1iZXJvZiBETkEuTUlYSU5TXG4gKiBAc3RhdGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiAvLyBteS1jb21wb25lbnQuanNcbiAqIGltcG9ydCB7IEJhc2VDb21wb25lbnQgfSBmcm9tICdAZG5hanMvY29yZSc7XG4gKiBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAqICAgZ2V0IHByb3BlcnRpZXMoKSB7XG4gKiAgICAgcmV0dXJuIHsgbmFtZTogU3RyaW5nIH07XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICogYGBganNcbiAqIC8vIGFwcC5qc1xuICogaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSAnQGRuYWpzL2NvcmUnO1xuICogaW1wb3J0IHsgTXlDb21wb25lbnQgfSBmcm9tICcuL215LWNvbXBvbmVudC5qcyc7XG4gKiBkZWZpbmUoJ215LWNvbXBvbmVudCcsIE15Q29tcG9uZW50KTtcbiAqIHZhciB0ZW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gKiB0ZW1wLmlubmVySFRNTCA9ICc8bXktY29tcG9uZW50IG5hbWU9XCJBbGJlcnRcIj48L215LWNvbXBvbmVudD4nO1xuICogdmFyIGVsZW1lbnQgPSB0ZW1wLmZpcnN0Q2hpbGQ7XG4gKiBjb25zb2xlLmxvZyhlbGVtZW50Lm5hbWUpOyAvLyBsb2dzIFwiQWxiZXJ0XCJcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgUHJvcGVydGllc01peGluID0gKFN1cGVyQ2xhc3MpID0+IGNsYXNzIGV4dGVuZHMgU3VwZXJDbGFzcyB7XG4gICAgLyoqXG4gICAgICogQXR0YWNoIHByb3BlcnRpZXMgb24gY29tcG9uZW50IGNyZWF0aW9uLlxuICAgICAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgRE5BLk1JWElOUy5Qcm9wZXJ0aWVzTWl4aW5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgbGV0IHByb3BzID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgIGlmICghaXNBcnJheShwcm9wcykpIHtcbiAgICAgICAgICAgICAgICBwcm9wcyA9IFtwcm9wc107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzLnJlZHVjZSgocmVzLCBwYXJ0aWFsUHJvcHMpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrIGluIHBhcnRpYWxQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICByZXNba10gPSBwcm9wKHBhcnRpYWxQcm9wc1trXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9wcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJvcGVydGllcycsIHtcbiAgICAgICAgICAgIHZhbHVlOiBwcm9wcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBvYnNlcnZlZCA9IHRoaXMuY29uc3RydWN0b3Iub2JzZXJ2ZWRBdHRyaWJ1dGVzIHx8IFtdO1xuICAgICAgICBmb3IgKGxldCBrIGluIHByb3BzKSB7XG4gICAgICAgICAgICBsZXQgcHJvcCA9IHByb3BzW2tdO1xuICAgICAgICAgICAgcHJvcC5uYW1lZChrKS5pbml0KHRoaXMpO1xuICAgICAgICAgICAgbGV0IHsgYXR0ck5hbWUsIGV2ZW50TmFtZSB9ID0gcHJvcDtcbiAgICAgICAgICAgIGlmICghYXR0ck5hbWUgJiYgb2JzZXJ2ZWQuaW5kZXhPZihrKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBwcm9wLmF0dHJpYnV0ZSgpO1xuICAgICAgICAgICAgICAgIGF0dHJOYW1lID0gaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdHRyTmFtZSB8fCBldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBwcm9wLm9ic2VydmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ck5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0dHJpYnV0ZSh0aGlzLm5vZGUsIGF0dHJOYW1lLCB0aGlzW3Byb3AubmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRoaXMubm9kZSwgZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmMgaW5pdGlhbCBhdHRyaWJ1dGVzIHdpdGggcHJvcGVydGllcy5cbiAgICAgKiBAbWV0aG9kIGNvbm5lY3RlZENhbGxiYWNrXG4gICAgICogQG1lbWJlcm9mIEROQS5NSVhJTlMuUHJvcGVydGllc01peGluXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICAgIGxldCBwcm9wcyA9IHRoaXMucHJvcGVydGllcztcbiAgICAgICAgZm9yIChsZXQgayBpbiBwcm9wcykge1xuICAgICAgICAgICAgbGV0IHByb3AgPSBwcm9wc1trXTtcbiAgICAgICAgICAgIGxldCB7IGF0dHJOYW1lIH0gPSBwcm9wO1xuICAgICAgICAgICAgaWYgKGF0dHJOYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoaXNbcHJvcC5uYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZS5oYXNBdHRyaWJ1dGUoYXR0ck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3AubmFtZV0gPSBnZXRWYWx1ZShwcm9wLCB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRBdHRyaWJ1dGUodGhpcy5ub2RlLCBhdHRyTmFtZSwgdGhpc1twcm9wLm5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3luYyBhdHRyaWJ1dGVzIHdpdGggcHJvcGVydGllcy5cbiAgICAgKiBAbWV0aG9kIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja1xuICAgICAqIEBtZW1iZXJvZiBETkEuTUlYSU5TLlByb3BlcnRpZXNNaXhpblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJOYW1lIFRoZSBjaGFuZ2VkIGF0dHJpYnV0ZSBuYW1lLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWwgVGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgYmVmb3JlIHRoZSBjaGFuZ2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5ld1ZhbCBUaGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBhZnRlciB0aGUgY2hhbmdlLlxuICAgICAqL1xuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyLCBvbGRWYWwsIG5ld1ZhbCkge1xuICAgICAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ciwgb2xkVmFsLCBuZXdWYWwpO1xuICAgICAgICBsZXQgcHJvcHMgPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgICAgIGZvciAobGV0IGsgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGxldCBwcm9wID0gcHJvcHNba107XG4gICAgICAgICAgICBpZiAocHJvcC5hdHRyTmFtZSA9PT0gYXR0cikge1xuICAgICAgICAgICAgICAgIHRoaXNbcHJvcC5uYW1lXSA9IGdldFZhbHVlKHByb3AsIG5ld1ZhbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGxpc3RlbmVyIGZvciBub2RlJ3MgcHJvcGVydHkgY2hhbmdlcy5cbiAgICAgKiBAbWV0aG9kIG9ic2VydmVQcm9wZXJ0eVxuICAgICAqIEBtZW1iZXJvZiBETkEuTUlYSU5TLlByb3BlcnRpZXNNaXhpblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BOYW1lIFRoZSBwcm9wZXJ0eSBuYW1lIHRvIG9ic2VydmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGZpcmUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBgY2FuY2VsYCBtZXRob2QuXG4gICAgICovXG4gICAgb2JzZXJ2ZVByb3BlcnR5KHByb3BOYW1lLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzW3Byb3BOYW1lXS5vYnNlcnZlKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgbGlzdGVuZXIgZm9yIG5vZGUncyBwcm9wZXJ0eSBjaGFuZ2VzLlxuICAgICAqIEBtZXRob2QgdW5vYnNlcnZlUHJvcGVydHlcbiAgICAgKiBAbWVtYmVyb2YgRE5BLk1JWElOUy5Qcm9wZXJ0aWVzTWl4aW5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wTmFtZSBUaGUgcHJvcGVydHkgbmFtZSB0byB1bm9ic2VydmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIHJlbW92ZS5cbiAgICAgKi9cbiAgICB1bm9ic2VydmVQcm9wZXJ0eShwcm9wTmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW3Byb3BOYW1lXS51bm9ic2VydmUoY2FsbGJhY2spO1xuICAgIH1cbn07XG4iLCJjb25zdCBFTEVNX1BST1RPID0gRWxlbWVudC5wcm90b3R5cGU7XG5cbmV4cG9ydCBjb25zdCBtYXRjaGVzID0gRUxFTV9QUk9UTy5tYXRjaGVzIHx8XG4gICAgRUxFTV9QUk9UTy5tYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBFTEVNX1BST1RPLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuICAgIEVMRU1fUFJPVE8ubXNNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBFTEVNX1BST1RPLm9NYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBFTEVNX1BST1RPLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcbiIsImltcG9ydCB7IGlzU3RyaW5nLCBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vbGliL3R5cGVvZi5qcyc7XG5pbXBvcnQgeyBtYXRjaGVzIH0gZnJvbSAnLi4vcG9seWZpbGxzL21hdGNoZXMuanMnO1xuaW1wb3J0IHsgZGlzcGF0Y2ggfSBmcm9tICcuLi9saWIvZGlzcGF0Y2guanMnO1xuXG5jb25zdCBTUExJVF9TRUxFQ1RPUiA9IC8oW15cXHNdKykoLiopPy87XG5cbi8qKlxuICogU2ltcGxlIEN1c3RvbSBDb21wb25lbnQgd2l0aCBldmVudHMgZGVsZWdhdGlvbixcbiAqIEl0IGFsc28gaW1wbGVtZW50IGEgYGRpc3BhdGNoRXZlbnRgIHdyYXBwZXIgbmFtZWQgYHRyaWdnZXJgLlxuICogQG1peGluIEV2ZW50c01peGluXG4gKiBAbWVtYmVyb2YgRE5BLk1JWElOUy5cbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIC8vIG15LWNvbXBvbmVudC5qc1xuICogaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJ0BkbmFqcy9jb3JlJztcbiAqIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICogICBnZXQgZXZlbnRzKCkge1xuICogICAgIHJldHVybiB7XG4gKiAgICAgICAnY2xpY2sgYnV0dG9uJzogJ29uQnV0dG9uQ2xpY2snXG4gKiAgICAgfVxuICogICB9XG4gKiAgIG9uQnV0dG9uQ2xpY2soKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2J1dHRvbiBjbGlja2VkJyk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICogYGBganNcbiAqIC8vIGFwcC5qc1xuICogaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSAnQGRuYWpzL2NvcmUnO1xuICogaW1wb3J0IHsgTXlDb21wb25lbnQgfSBmcm9tICcuL215LWNvbXBvbmVudC5qcyc7XG4gKiBkZWZpbmUoJ215LWNvbXBvbmVudCcsIE15Q29tcG9uZW50KTtcbiAqIHZhciBlbGVtZW50ID0gbmV3IE15Q29tcG9uZW50KCk7XG4gKiB2YXIgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gKiBidXR0b24uaW5uZXJUZXh0ID0gJ0NsaWNrIG1lJztcbiAqIGVsZW1lbnQuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAqIGJ1dHRvbi5jbGljaygpOyAvLyBsb2dzIFwiYnV0dG9uIGNsaWNrZWRcIlxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBFdmVudHNNaXhpbiA9IChTdXBlckNsYXNzKSA9PiBjbGFzcyBleHRlbmRzIFN1cGVyQ2xhc3Mge1xuICAgIC8qKlxuICAgICAqIEF0dGFjaCBhbmQgZGVsZWdhdGUgZXZlbnRzIHRvIHRoZSBjb21wb25lbnQuXG4gICAgICogQG1ldGhvZCBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBETkEuTUlYSU5TLkV2ZW50c01peGluXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGJpbmQgZXZlbnRzXG4gICAgICAgIGxldCBldmVudHMgPSB0aGlzLmV2ZW50cyB8fCB7fTtcbiAgICAgICAgZm9yIChsZXQgayBpbiBldmVudHMpIHtcbiAgICAgICAgICAgIGxldCBjYWxsYmFjayA9IGlzU3RyaW5nKGV2ZW50c1trXSkgP1xuICAgICAgICAgICAgICAgIHRoaXNbZXZlbnRzW2tdXSA6XG4gICAgICAgICAgICAgICAgZXZlbnRzW2tdO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSBrLm1hdGNoKFNQTElUX1NFTEVDVE9SKTtcbiAgICAgICAgICAgICAgICBsZXQgZXZOYW1lID0gcnVsZVsxXTtcbiAgICAgICAgICAgICAgICBsZXQgc2VsZWN0b3IgPSAocnVsZVsyXSB8fCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlKGV2TmFtZSwgc2VsZWN0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldk5hbWUsIChldikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBldiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjYWxsYmFjayBmb3IgZXZlbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZWdhdGUgZXZlbnRzIHRvIHRoZSBjb21wb25lbnQgZGVzY2VuZGVudHMuXG4gICAgICogQG1ldGhvZCBkZWxlZ2F0ZVxuICAgICAqIEBtZW1iZXJvZiBETkEuTUlYSU5TLkV2ZW50c01peGluXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZOYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBkZWxlZ2F0ZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgQSBDU1Mgc2VsZWN0b3IgZm9yIGRlc2NlbmRlbnRzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBmaXJlIHdoZW4gdGhlIGV2ZW50IGZpcmVzLlxuICAgICAqL1xuICAgIGRlbGVnYXRlKGV2TmFtZSwgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKGV2TmFtZSwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKHRhcmdldCwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZXZlbnQsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYE5vZGUucHJvdG90eXBlLmRpc3BhdGNoRXZlbnRgIHdyYXBwZXIuXG4gICAgICogQG1ldGhvZCB0cmlnZ2VyXG4gICAgICogQG1lbWJlcm9mIEROQS5NSVhJTlMuRXZlbnRzTWl4aW5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldk5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQSBzZXQgb2YgY3VzdG9tIGRhdGEgdG8gcGFzcyB0byB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBidWJibGVzIFNob3VsZCB0aGUgZXZlbnQgYnViYmxlIHRocm93IHRoZSBET00gdHJlZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNhbmNlbGFibGUgQ2FuIGJlIHRoZSBldmVudCBjYW5jZWwgYnkgYSBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGV2ZW50IHByb3BhZ2F0aW9uIGhhcyBub3QgYmUgc3RvcHBlZC5cbiAgICAgKi9cbiAgICB0cmlnZ2VyKGV2TmFtZSwgZGF0YSwgYnViYmxlcyA9IHRydWUsIGNhbmNlbGFibGUgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaCh0aGlzLCBldk5hbWUsIGRhdGEsIGJ1YmJsZXMsIGNhbmNlbGFibGUpO1xuICAgIH1cbn07XG4iLCJjb25zdCByb290RG9jID0gZG9jdW1lbnQ7XG4vKipcbiAqIENyZWF0ZSBhbmQgYXR0YWNoIGEgc3R5bGUgZWxlbWVudCBmb3IgYSBjb21wb25lbnQuXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgQSBjb21wb25lbnQgaW5zdGFuY2UuXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gVGhlIGNyZWF0ZWQgc3R5bGUgZWxlbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlKG5vZGUpIHtcbiAgICBsZXQgZG9jID0gbm9kZS5vd25lckRvY3VtZW50IHx8IHJvb3REb2M7XG4gICAgbGV0IHN0eWxlRWxlbSA9IGRvYy5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlRWxlbS50eXBlID0gJ3RleHQvY3NzJztcbiAgICBzdHlsZUVsZW0uc2V0QXR0cmlidXRlKCdpZCcsIGBzdHlsZS0ke25vZGUuaXN9YCk7XG4gICAgbGV0IGhlYWQgPSBkb2MuaGVhZDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChoZWFkLmZpcnN0RWxlbWVudENoaWxkKSB7XG4gICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbSwgaGVhZC5maXJzdEVsZW1lbnRDaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW0pO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGVFbGVtO1xufVxuIiwiaW1wb3J0IHsgaXNTdHJpbmcgfSBmcm9tICcuLi9saWIvdHlwZW9mLmpzJztcbmltcG9ydCB7IGNyZWF0ZVN0eWxlIH0gZnJvbSAnLi4vbGliL3N0eWxlLmpzJztcblxuLyoqXG4gKiBTaW1wbGUgQ3VzdG9tIENvbXBvbmVudCB3aXRoIGNzcyBzdHlsZSBoYW5kbGluZyB1c2luZyB0aGUgYGNzc2AgcHJvcGVydHkuXG4gKiBAbWl4aW4gU3R5bGVNaXhpblxuICogQG1lbWJlcm9mIEROQS5NSVhJTlNcbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIC8vIG15LWNvbXBvbmVudC5qc1xuICogaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJ0BkbmFqcy9jb3JlJztcbiAqIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICogICBnZXQgY3NzKCkge1xuICogICAgIHJldHVybiAnLm15LWNvbXBvbmVudCBwIHsgY29sb3I6IHJlZDsgfSdcbiAqICAgfVxuICogfVxuICogYGBgXG4gKiBgYGBqc1xuICogLy8gYXBwLmpzXG4gKiBpbXBvcnQgeyBkZWZpbmUgfSBmcm9tICdAZG5hanMvY29yZSc7XG4gKiBpbXBvcnQgeyBNeUNvbXBvbmVudCB9IGZyb20gJy4vbXktY29tcG9uZW50LmpzJztcbiAqIGRlZmluZSgnbXktY29tcG9uZW50JywgTXlDb21wb25lbnQpO1xuICogdmFyIGVsZW1lbnQgPSBuZXcgTXlDb21wb25lbnQoKTtcbiAqIHZhciBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICogcC5pbm5lclRleHQgPSAnUGFyYWdyYXBoJztcbiAqIGVsZW1lbnQuYXBwZW5kQ2hpbGQocCk7IC8vIHRleHQgaW5zaWRlIGBwYCBnZXRzIHRoZSByZWQgY29sb3JcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgU3R5bGVNaXhpbiA9IChTdXBlckNsYXNzKSA9PiBjbGFzcyBleHRlbmRzIFN1cGVyQ2xhc3Mge1xuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gYW4gaW5zdGFuY2Ugb2YgdGhlIGVsZW1lbnQgaXMgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLnN0eWxlRWxlbSkge1xuICAgICAgICAgICAgbGV0IEN0ciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3RyLCAnc3R5bGVFbGVtJywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjcmVhdGVTdHlsZSh0aGlzKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlQ1NTKCk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICAgIHRoaXMubm9kZS5jbGFzc0xpc3QuYWRkKHRoaXMuaXMpO1xuICAgIH1cblxuICAgIHVwZGF0ZUNTUygpIHtcbiAgICAgICAgbGV0IHN0eWxlID0gdGhpcy5jc3M7XG4gICAgICAgIGlmIChpc1N0cmluZyhzdHlsZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3Iuc3R5bGVFbGVtLnRleHRDb250ZW50ID0gc3R5bGU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiaW1wb3J0IHsgaXNVbmRlZmluZWQsIGlzRnVuY3Rpb24sIGlzU3RyaW5nIH0gZnJvbSAnLi4vbGliL3R5cGVvZi5qcyc7XG5cbi8qKlxuICogU2ltcGxlIEN1c3RvbSBDb21wb25lbnQgd2l0aCB0ZW1wbGF0ZSBoYW5kbGluZyB1c2luZyB0aGUgYHRlbXBsYXRlYCBwcm9wZXJ0eS5cbiAqIEBtZW1iZXJvZiBETkEuTUlYSU5TXG4gKiBAbWl4aW4gVGVtcGxhdGVNaXhpblxuICogQHN0YXRpY1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFN1cGVyQ2xhc3MgVGhlIGNsYXNzIHRvIGV4dGVuZC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgZXh0ZW5kZWQgY2xhc3MuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiAvLyBteS1jb21wb25lbnQuanNcbiAqIGltcG9ydCB7IEJhc2VDb21wb25lbnQgfSBmcm9tICdAZG5hanMvY29yZSc7XG4gKiBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAqICAgZ2V0IHRlbXBsYXRlKCkge1xuICogICAgIHJldHVybiBgPGgxPiR7dGhpcy5uYW1lfTwvaDE+YDtcbiAqICAgfVxuICogICBnZXQgbmFtZSgpIHtcbiAqICAgICByZXR1cm4gJ05ld3Rvbic7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICogYGBganNcbiAqIC8vIGFwcC5qc1xuICogaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSAnQGRuYWpzL2NvcmUnO1xuICogaW1wb3J0IHsgTXlDb21wb25lbnQgfSBmcm9tICcuL215LWNvbXBvbmVudC5qcyc7XG4gKiBkZWZpbmUoJ215LWNvbXBvbmVudCcsIE15Q29tcG9uZW50KTtcbiAqIHZhciBlbGVtZW50ID0gbmV3IE15Q29tcG9uZW50KCk7XG4gKiBjb25zb2xlLmxvZyhlbGVtZW50LmlubmVySFRNTCk7IC8vIGxvZ3MgXCI8aDE+TmV3dG9uPC9oMT5cIlxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBUZW1wbGF0ZU1peGluID0gKFN1cGVyQ2xhc3MpID0+IGNsYXNzIGV4dGVuZHMgU3VwZXJDbGFzcyB7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBhdXRvUmVuZGVyIFNob3VsZCB0aGUgY29tcG9uZW50IHJlLXJlbmRlciBvbiBwcm9wZXJ0aWVzIGNoYW5nZXMuXG4gICAgICogQG5hbWUgYXV0b1JlbmRlclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBtZW1iZXJvZiBETkEuTUlYSU5TLlRlbXBsYXRlTWl4aW5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBnZXQgYXV0b1JlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBwcm9wZXJ0aWVzIG9ic2VydmVycyBpbiBvcmRlciB0byB1cGRhdGUgY2hpbGRyZW4uXG4gICAgICogQG1ldGhvZCBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBETkEuTUlYSU5TLlRlbXBsYXRlTWl4aW5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b1JlbmRlciAmJiAhaXNVbmRlZmluZWQodGhpcy50ZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgIGxldCBwcm9wcyA9IHRoaXMucHJvcGVydGllcztcbiAgICAgICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNba10ub2JzZXJ2ZShjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlciB0aGUgY29tcG9uZW50IHdoZW4gY29ubmVjdGVkLlxuICAgICAqIEBtZXRob2QgY29ubmVjdGVkQ2FsbGJhY2tcbiAgICAgKiBAbWVtYmVyb2YgRE5BLk1JWElOUy5UZW1wbGF0ZU1peGluXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy50ZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIENvbXBvbmVudCBjaGlsZCBub2Rlcy5cbiAgICAgKiBAbWV0aG9kIHJlbmRlclxuICAgICAqIEBtZW1iZXJvZiBETkEuTUlYSU5TLlRlbXBsYXRlTWl4aW5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSB0cGwgQSB0ZW1wbGF0ZSB0byB1c2UgaW5zdGVhZCBvZiBgdGhpcy50ZW1wbGF0ZWAuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IFdpbGwgdGhyb3cgaWYgdGhlIHRlbXBsYXRlIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICByZW5kZXIodHBsKSB7XG4gICAgICAgIHRwbCA9IHRwbCB8fCB0aGlzLnRlbXBsYXRlO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih0cGwpKSB7XG4gICAgICAgICAgICB0cGwuY2FsbCh0aGlzKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyh0cGwpKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUuaW5uZXJIVE1MID0gdHBsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB0ZW1wbGF0ZSBwcm9wZXJ0eS4nKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbmV4cG9ydCBjb25zdCByZWR1Y2UgPSBBcnJheS5wcm90b3R5cGUucmVkdWNlIHx8IGZ1bmN0aW9uKGNhbGxiYWNrIC8qLCBpbml0aWFsVmFsdWUqLyApIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgbGV0IHQgPSB0aGlzO1xuICAgIGxldCBsZW4gPSB0Lmxlbmd0aDtcbiAgICBsZXQgayA9IDA7XG4gICAgbGV0IHZhbHVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChrIDwgbGVuICYmICEoayBpbiB0KSkge1xuICAgICAgICAgICAgaysrO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdFtrKytdO1xuICAgIH1cbiAgICBmb3IgKDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgIGlmIChrIGluIHQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2sodmFsdWUsIHRba10sIGssIHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG4iLCIvKipcbiAqIEBhdXRob3IgSnVzdGluIEZhZ25hbmlcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2p1c3RpbmZhZ25hbmkvbWl4d2l0aC5qc1xuICovXG5pbXBvcnQgeyByZWR1Y2UgfSBmcm9tICcuLi9wb2x5ZmlsbHMvcmVkdWNlLmpzJztcblxuLyoqXG4gKiBNaXggYSBjbGFzcyB3aXRoIGEgbWl4aW4uXG4gKiBAbWV0aG9kIG1peCguLi4pLndpdGgoLi4uKVxuICogQG1lbWJlcm9mISBETkEuXG4gKiBAc3RhdGljXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJDbGFzcyBUaGUgY2xhc3MgdG8gZXh0ZW5kLlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgbWl4ZWQgY2xhc3MuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiAvLyBteS1zdXBlci5qc1xuICogZXhwb3J0IGNsYXNzIE15U3VwZXJDbGFzcyB7XG4gKiAgICAgY29uc3RydWN0b3IoKSB7XG4gKiAgICAgICAgIC8vIGRvIHNvbWV0aGluZ1xuICogICAgIH1cbiAqIH1cbiAqIGBgYFxuICogYGBganNcbiAqIC8vIG1peGluLmpzXG4gKiBleHBvcnQgY29uc3QgTWl4aW4gPSAoc3VwZXJDbGFzcykgPT4gY2xhc3MgZXh0ZW5kIHN1cGVyQ2xhc3Mge1xuICogICAgIGNvbnN0cnVjdG9yKCkge1xuICogICAgICAgICBzdXBlcigpO1xuICogICAgICAgICAvLyBkbyBzb21ldGhpbmcgZWxzZVxuICogICAgIH1cbiAqIH07XG4gKiBgYGBcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBtaXggfSBmcm9tICdAZG5hanMvY29yZSc7XG4gKiBpbXBvcnQgeyBNeVN1cGVyQ2xhc3MgfSBmcm9tICcuL215LXN1cGVyLmpzJztcbiAqIGltcG9ydCB7IE1peGluIH0gZnJvbSAnLi9taXhpbi5qcyc7XG4gKlxuICogZXhwb3J0IGNsYXNzIE1peGVkQ2xhc3MgZXh0ZW5kcyBtaXgoTXlTdXBlckNsYXNzKS53aXRoKE1peGluKSB7XG4gKiAgICAgLi4uXG4gKiB9XG4gKiBgYGBcbiAqL1xuXG4vKipcbiAqIEEgTWl4aW4gaGVscGVyIGNsYXNzLlxuICogQGlnbm9yZVxuICovXG5jbGFzcyBNaXhpbiB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbWl4YWJsZSBjbGFzcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdXBlckNsYXNzIFRoZSBjbGFzcyB0byBleHRlbmQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3VwZXJjbGFzcykge1xuICAgICAgICBzdXBlcmNsYXNzID0gc3VwZXJjbGFzcyB8fCBjbGFzcyB7fTtcbiAgICAgICAgdGhpcy5zdXBlcmNsYXNzID0gc3VwZXJjbGFzcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWl4IHRoZSBzdXBlciBjbGFzcyB3aXRoIGEgbGlzdCBvZiBtaXhpbnMuXG4gICAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gbWl4aW5zICpOKiBtaXhpbiBmdW5jdGlvbnMuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBleHRlbmRlZCBjbGFzcy5cbiAgICAgKi9cbiAgICB3aXRoKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgbGV0IGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIHJldHVybiByZWR1Y2UuY2FsbChhcmdzLCAoYywgbWl4aW4pID0+IG1peGluKGMpLCB0aGlzLnN1cGVyY2xhc3MpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBNaXhpbiBpbnN0YW5jZS5cbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGNvbnN0IG1peCA9IChzdXBlckNsYXNzKSA9PiBuZXcgTWl4aW4oc3VwZXJDbGFzcyk7XG4iLCJpbXBvcnQgeyByZWdpc3RyeSB9IGZyb20gJy4vcmVnaXN0cnkuanMnO1xuaW1wb3J0IHsgaXNTdHJpbmcgfSBmcm9tICcuL3R5cGVvZi5qcyc7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBub2RlIGlzIGFscmVhZHkgaW5zdGFudGlhdGVkIEhUTUxFbGVtZW50IGZvciBwcm9ncmFtbWF0aWNhbGx5IGBjb25zdHJ1Y3RvcmAgY2FsbHMuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBUaGUgbm9kZSB0byBjaGVjay5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRoZSBub2RlIHNob3VsZCBiZSBpbnN0YW50aWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzTmV3KG5vZGUpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gIWlzU3RyaW5nKG5vZGUub3V0ZXJIVE1MKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbi8qKlxuICogU2hpbSBvcmlnaW5hbCBFbGVtZW50IGNvbnN0cnVjdG9ycyBpbiBvcmRlciB0byBiZSB1c2VkIHdpdGggYG5ld2AuXG4gKiBAbWV0aG9kIHNoaW1cbiAqIEBtZW1iZXJvZiEgRE5BLlxuICogQHN0YXRpY1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IE9yaWdpbmFsIFRoZSBvcmlnaW5hbCBjb25zdHJ1Y3RvciB0byBzaGltLlxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaGltbWVkIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogLy8gc2hpbSBhdWRpbyBlbGVtZW50XG4gKiBpbXBvcnQgeyBzaGltIH0gZnJvbSAnQGRuYWpzL2NvcmUnO1xuICpcbiAqIGNsYXNzIE15QXVkaW8gZXh0ZW5kcyBzaGltKEhUTUxBdWRpb0VsZW1lbnQpIHtcbiAqICAgICAuLi5cbiAqIH1cbiAqXG4gKiBsZXQgYXVkaW8gPSBuZXcgTXlBdWRpbygpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGltKE9yaWdpbmFsKSB7XG4gICAgY2xhc3MgUG9seWZpbGxlZCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgaWYgKCFpc05ldyh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRlc2MgPSByZWdpc3RyeS5nZXREZXNjcmlwdG9yKHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgbGV0IGNvbmZpZyA9IGRlc2MuY29uZmlnO1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgdGFnbmFtZSBvZiB0aGUgY29uc3RydWN0b3IgYW5kIGNyZWF0ZSBhIG5ldyBlbGVtZW50IHdpdGggaXRcbiAgICAgICAgICAgIGxldCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICBjb25maWcuZXh0ZW5kcyA/IGNvbmZpZy5leHRlbmRzIDogZGVzYy5pc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsZW1lbnQuX19wcm90b19fID0gZGVzYy5DdHIucHJvdG90eXBlO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5leHRlbmRzKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lzJywgZGVzYy5pcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDbG9uZSB0aGUgcHJvdG90eXBlIG92ZXJyaWRpbmcgdGhlIGNvbnN0cnVjdG9yLlxuICAgIFBvbHlmaWxsZWQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPcmlnaW5hbC5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBQb2x5ZmlsbGVkLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIFBvbHlmaWxsZWQ7XG59XG4iLCJpbXBvcnQgKiBhcyBET01fSEVMUEVSUyBmcm9tICcuL2xpYi9kb20uanMnO1xuaW1wb3J0IHsgQ29tcG9uZW50TWl4aW4gfSBmcm9tICcuL21peGlucy9jb21wb25lbnQuanMnO1xuaW1wb3J0IHsgUHJvcGVydGllc01peGluIH0gZnJvbSAnLi9taXhpbnMvcHJvcGVydGllcy1jb21wb25lbnQuanMnO1xuaW1wb3J0IHsgRXZlbnRzTWl4aW4gfSBmcm9tICcuL21peGlucy9ldmVudHMtY29tcG9uZW50LmpzJztcbmltcG9ydCB7IFN0eWxlTWl4aW4gfSBmcm9tICcuL21peGlucy9zdHlsZS1jb21wb25lbnQuanMnO1xuaW1wb3J0IHsgVGVtcGxhdGVNaXhpbiB9IGZyb20gJy4vbWl4aW5zL3RlbXBsYXRlLWNvbXBvbmVudC5qcyc7XG5cbi8qKlxuICogQSBzZXQgb2YgRE9NIGhlbHBlcnMgZm9yIGNhbGxiYWNrcyB0cmlnZ2VyIHdoZW4gQ3VzdG9tIEVsZW1lbnRzXG4gKiBhcmUgbm90IHN1cHBvcnRlZCBieSB0aGUgYnJvd3Nlci5cbiAqIEBuYW1lIERPTVxuICogQG5hbWVzcGFjZSBET01cbiAqIEBtZW1iZXJvZiEgRE5BLlxuICogQHN0YXRpY1xuICovXG5leHBvcnQgY29uc3QgRE9NID0gRE9NX0hFTFBFUlM7XG4vKipcbiAqIEEgc2V0IG9mIGNvcmUgbWl4aW5zLlxuICogQG5hbWUgTUlYSU5TXG4gKiBAbmFtZXNwYWNlIE1JWElOU1xuICogQG1lbWJlcm9mISBETkEuXG4gKiBAc3RhdGljXG4gKi9cbmV4cG9ydCBjb25zdCBNSVhJTlMgPSB7XG4gICAgQ29tcG9uZW50TWl4aW4sXG4gICAgUHJvcGVydGllc01peGluLFxuICAgIEV2ZW50c01peGluLFxuICAgIFN0eWxlTWl4aW4sXG4gICAgVGVtcGxhdGVNaXhpbixcbn07XG5leHBvcnQgeyBtaXggfSBmcm9tICcuL2xpYi9taXhpbnMuanMnO1xuZXhwb3J0IHsgcHJvcCB9IGZyb20gJy4vbGliL3Byb3BlcnR5LmpzJztcbmV4cG9ydCB7IHNoaW0gfSBmcm9tICcuL2xpYi9zaGltLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL3N5bWJvbHMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvdHlwZW9mLmpzJztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUgVGhlIEluY3JlbWVudGFsIERPTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG4vKipcbiAqIEEgY2FjaGVkIHJlZmVyZW5jZSB0byB0aGUgaGFzT3duUHJvcGVydHkgZnVuY3Rpb24uXG4gKi9cbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuXG4vKipcbiAqIEEgY29uc3RydWN0b3IgZnVuY3Rpb24gdGhhdCB3aWxsIGNyZWF0ZSBibGFuayBvYmplY3RzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJsYW5rKCkge31cblxuQmxhbmsucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuXG4vKipcbiAqIFVzZWQgdG8gcHJldmVudCBwcm9wZXJ0eSBjb2xsaXNpb25zIGJldHdlZW4gb3VyIFwibWFwXCIgYW5kIGl0cyBwcm90b3R5cGUuXG4gKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCAqPn0gbWFwIFRoZSBtYXAgdG8gY2hlY2suXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHByb3BlcnR5IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBtYXAgaGFzIHByb3BlcnR5LlxuICovXG5jb25zdCBoYXMgPSBmdW5jdGlvbihtYXAsIHByb3BlcnR5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwgcHJvcGVydHkpO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYW4gbWFwIG9iamVjdCB3aXRob3V0IGEgcHJvdG90eXBlLlxuICogQHJldHVybiB7IU9iamVjdH1cbiAqL1xuY29uc3QgY3JlYXRlTWFwID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgQmxhbmsoKTtcbn07XG5cblxuLyoqICovXG5leHBvcnQge1xuICBjcmVhdGVNYXAsXG4gIGhhc1xufTtcblxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSBUaGUgSW5jcmVtZW50YWwgRE9NIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBjcmVhdGVNYXAgfSBmcm9tICcuL3V0aWwnO1xuXG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgaW5mb3JtYXRpb24gbmVlZGVkIHRvIHBlcmZvcm0gZGlmZnMgZm9yIGEgZ2l2ZW4gRE9NIG5vZGUuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5vZGVOYW1lXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBrZXlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBOb2RlRGF0YShub2RlTmFtZSwga2V5KSB7XG4gIC8qKlxuICAgKiBUaGUgYXR0cmlidXRlcyBhbmQgdGhlaXIgdmFsdWVzLlxuICAgKiBAY29uc3QgeyFPYmplY3Q8c3RyaW5nLCAqPn1cbiAgICovXG4gIHRoaXMuYXR0cnMgPSBjcmVhdGVNYXAoKTtcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgYXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMsIHVzZWQgZm9yIHF1aWNrbHkgZGlmZmluZyB0aGVcbiAgICogaW5jb21taW5nIGF0dHJpYnV0ZXMgdG8gc2VlIGlmIHRoZSBET00gbm9kZSdzIGF0dHJpYnV0ZXMgbmVlZCB0byBiZVxuICAgKiB1cGRhdGVkLlxuICAgKiBAY29uc3Qge0FycmF5PCo+fVxuICAgKi9cbiAgdGhpcy5hdHRyc0FyciA9IFtdO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5jb21pbmcgYXR0cmlidXRlcyBmb3IgdGhpcyBOb2RlLCBiZWZvcmUgdGhleSBhcmUgdXBkYXRlZC5cbiAgICogQGNvbnN0IHshT2JqZWN0PHN0cmluZywgKj59XG4gICAqL1xuICB0aGlzLm5ld0F0dHJzID0gY3JlYXRlTWFwKCk7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSBzdGF0aWNzIGhhdmUgYmVlbiBhcHBsaWVkIGZvciB0aGUgbm9kZSB5ZXQuXG4gICAqIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5zdGF0aWNzQXBwbGllZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGUga2V5IHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBub2RlLCB1c2VkIHRvIHByZXNlcnZlIERPTSBub2RlcyB3aGVuIHRoZXlcbiAgICogbW92ZSB3aXRoaW4gdGhlaXIgcGFyZW50LlxuICAgKiBAY29uc3RcbiAgICovXG4gIHRoaXMua2V5ID0ga2V5O1xuXG4gIC8qKlxuICAgKiBLZWVwcyB0cmFjayBvZiBjaGlsZHJlbiB3aXRoaW4gdGhpcyBub2RlIGJ5IHRoZWlyIGtleS5cbiAgICogeyFPYmplY3Q8c3RyaW5nLCAhRWxlbWVudD59XG4gICAqL1xuICB0aGlzLmtleU1hcCA9IGNyZWF0ZU1hcCgpO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUga2V5TWFwIGlzIGN1cnJlbnRseSB2YWxpZC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmtleU1hcFZhbGlkID0gdHJ1ZTtcblxuICAvKipcbiAgICogV2hldGhlciBvciB0aGUgYXNzb2NpYXRlZCBub2RlIGlzLCBvciBjb250YWlucywgYSBmb2N1c2VkIEVsZW1lbnQuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRoZSBub2RlIG5hbWUgZm9yIHRoaXMgbm9kZS5cbiAgICogQGNvbnN0IHtzdHJpbmd9XG4gICAqL1xuICB0aGlzLm5vZGVOYW1lID0gbm9kZU5hbWU7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgKi9cbiAgdGhpcy50ZXh0ID0gbnVsbDtcbn1cblxuXG4vKipcbiAqIEluaXRpYWxpemVzIGEgTm9kZURhdGEgb2JqZWN0IGZvciBhIE5vZGUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIGluaXRpYWxpemUgZGF0YSBmb3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWUgVGhlIG5vZGUgbmFtZSBvZiBub2RlLlxuICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IFRoZSBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBub2RlLlxuICogQHJldHVybiB7IU5vZGVEYXRhfSBUaGUgbmV3bHkgaW5pdGlhbGl6ZWQgZGF0YSBvYmplY3RcbiAqL1xuY29uc3QgaW5pdERhdGEgPSBmdW5jdGlvbihub2RlLCBub2RlTmFtZSwga2V5KSB7XG4gIGNvbnN0IGRhdGEgPSBuZXcgTm9kZURhdGEobm9kZU5hbWUsIGtleSk7XG4gIG5vZGVbJ19faW5jcmVtZW50YWxET01EYXRhJ10gPSBkYXRhO1xuICByZXR1cm4gZGF0YTtcbn07XG5cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIE5vZGVEYXRhIG9iamVjdCBmb3IgYSBOb2RlLCBjcmVhdGluZyBpdCBpZiBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHs/Tm9kZX0gbm9kZSBUaGUgTm9kZSB0byByZXRyaWV2ZSB0aGUgZGF0YSBmb3IuXG4gKiBAcmV0dXJuIHshTm9kZURhdGF9IFRoZSBOb2RlRGF0YSBmb3IgdGhpcyBOb2RlLlxuICovXG5jb25zdCBnZXREYXRhID0gZnVuY3Rpb24obm9kZSkge1xuICBpbXBvcnROb2RlKG5vZGUpO1xuICByZXR1cm4gbm9kZVsnX19pbmNyZW1lbnRhbERPTURhdGEnXTtcbn07XG5cblxuLyoqXG4gKiBJbXBvcnRzIG5vZGUgYW5kIGl0cyBzdWJ0cmVlLCBpbml0aWFsaXppbmcgY2FjaGVzLlxuICpcbiAqIEBwYXJhbSB7P05vZGV9IG5vZGUgVGhlIE5vZGUgdG8gaW1wb3J0LlxuICovXG5jb25zdCBpbXBvcnROb2RlID0gZnVuY3Rpb24obm9kZSkge1xuICBpZiAobm9kZVsnX19pbmNyZW1lbnRhbERPTURhdGEnXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGlzRWxlbWVudCA9IG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50O1xuICBjb25zdCBub2RlTmFtZSA9IGlzRWxlbWVudCA/IG5vZGUubG9jYWxOYW1lIDogbm9kZS5ub2RlTmFtZTtcbiAgY29uc3Qga2V5ID0gaXNFbGVtZW50ID8gbm9kZS5nZXRBdHRyaWJ1dGUoJ2tleScpIDogbnVsbDtcbiAgY29uc3QgZGF0YSA9IGluaXREYXRhKG5vZGUsIG5vZGVOYW1lLCBrZXkpO1xuXG4gIGlmIChrZXkpIHtcbiAgICBnZXREYXRhKG5vZGUucGFyZW50Tm9kZSkua2V5TWFwW2tleV0gPSBub2RlO1xuICB9XG5cbiAgaWYgKGlzRWxlbWVudCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICAgIGNvbnN0IG5ld0F0dHJzID0gZGF0YS5uZXdBdHRycztcbiAgICBjb25zdCBhdHRyc0FyciA9IGRhdGEuYXR0cnNBcnI7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGF0dHIgPSBhdHRyaWJ1dGVzW2ldO1xuICAgICAgY29uc3QgbmFtZSA9IGF0dHIubmFtZTtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXR0ci52YWx1ZTtcblxuICAgICAgYXR0cnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIG5ld0F0dHJzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgYXR0cnNBcnIucHVzaChuYW1lKTtcbiAgICAgIGF0dHJzQXJyLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGNoaWxkID0gbm9kZS5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgIGltcG9ydE5vZGUoY2hpbGQpO1xuICB9XG59O1xuXG5cbi8qKiAqL1xuZXhwb3J0IHtcbiAgZ2V0RGF0YSxcbiAgaW5pdERhdGEsXG4gIGltcG9ydE5vZGVcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1IFRoZSBJbmNyZW1lbnRhbCBET00gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gICAgZ2V0RGF0YSxcbiAgICBpbml0RGF0YVxufSBmcm9tICcuL25vZGVfZGF0YSc7XG5cblxuLyoqXG4gKiBHZXRzIHRoZSBuYW1lc3BhY2UgdG8gY3JlYXRlIGFuIGVsZW1lbnQgKG9mIGEgZ2l2ZW4gdGFnKSBpbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIHRhZyB0byBnZXQgdGhlIG5hbWVzcGFjZSBmb3IuXG4gKiBAcGFyYW0gez9Ob2RlfSBwYXJlbnRcbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBuYW1lc3BhY2UgdG8gY3JlYXRlIHRoZSB0YWcgaW4uXG4gKi9cbmNvbnN0IGdldE5hbWVzcGFjZUZvclRhZyA9IGZ1bmN0aW9uKHRhZywgcGFyZW50KSB7XG4gIGlmICh0YWcgPT09ICdzdmcnKSB7XG4gICAgcmV0dXJuICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gIH1cblxuICBpZiAoZ2V0RGF0YShwYXJlbnQpLm5vZGVOYW1lID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBwYXJlbnQubmFtZXNwYWNlVVJJO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYW4gRWxlbWVudC5cbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBUaGUgZG9jdW1lbnQgd2l0aCB3aGljaCB0byBjcmVhdGUgdGhlIEVsZW1lbnQuXG4gKiBAcGFyYW0gez9Ob2RlfSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIHRhZyBmb3IgdGhlIEVsZW1lbnQuXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBrZXkgQSBrZXkgdG8gaWRlbnRpZnkgdGhlIEVsZW1lbnQuXG4gKiBAcmV0dXJuIHshRWxlbWVudH1cbiAqL1xuY29uc3QgY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKGRvYywgcGFyZW50LCB0YWcsIGtleSkge1xuICBjb25zdCBuYW1lc3BhY2UgPSBnZXROYW1lc3BhY2VGb3JUYWcodGFnLCBwYXJlbnQpO1xuICBsZXQgZWw7XG5cbiAgaWYgKG5hbWVzcGFjZSkge1xuICAgIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsIHRhZyk7XG4gIH0gZWxzZSB7XG4gICAgZWwgPSBkb2MuY3JlYXRlRWxlbWVudCh0YWcpO1xuICB9XG5cbiAgaW5pdERhdGEoZWwsIHRhZywga2V5KTtcblxuICByZXR1cm4gZWw7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIFRleHQgTm9kZS5cbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBUaGUgZG9jdW1lbnQgd2l0aCB3aGljaCB0byBjcmVhdGUgdGhlIEVsZW1lbnQuXG4gKiBAcmV0dXJuIHshVGV4dH1cbiAqL1xuY29uc3QgY3JlYXRlVGV4dCA9IGZ1bmN0aW9uKGRvYykge1xuICBjb25zdCBub2RlID0gZG9jLmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgaW5pdERhdGEobm9kZSwgJyN0ZXh0JywgbnVsbCk7XG4gIHJldHVybiBub2RlO1xufTtcblxuXG4vKiogKi9cbmV4cG9ydCB7XG4gIGNyZWF0ZUVsZW1lbnQsXG4gIGNyZWF0ZVRleHRcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1IFRoZSBJbmNyZW1lbnRhbCBET00gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAY29uc3QgKi9cbmNvbnN0IG5vdGlmaWNhdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBDYWxsZWQgYWZ0ZXIgcGF0Y2ggaGFzIGNvbXBsZWF0ZWQgd2l0aCBhbnkgTm9kZXMgdGhhdCBoYXZlIGJlZW4gY3JlYXRlZFxuICAgKiBhbmQgYWRkZWQgdG8gdGhlIERPTS5cbiAgICogQHR5cGUgez9mdW5jdGlvbihBcnJheTwhTm9kZT4pfVxuICAgKi9cbiAgbm9kZXNDcmVhdGVkOiBudWxsLFxuXG4gIC8qKlxuICAgKiBDYWxsZWQgYWZ0ZXIgcGF0Y2ggaGFzIGNvbXBsZWF0ZWQgd2l0aCBhbnkgTm9kZXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZFxuICAgKiBmcm9tIHRoZSBET00uXG4gICAqIE5vdGUgaXQncyBhbiBhcHBsaWNhdGlvbnMgcmVzcG9uc2liaWxpdHkgdG8gaGFuZGxlIGFueSBjaGlsZE5vZGVzLlxuICAgKiBAdHlwZSB7P2Z1bmN0aW9uKEFycmF5PCFOb2RlPil9XG4gICAqL1xuICBub2Rlc0RlbGV0ZWQ6IG51bGxcbn07XG5cbmV4cG9ydCB7XG4gIG5vdGlmaWNhdGlvbnNcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1IFRoZSBJbmNyZW1lbnRhbCBET00gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IG5vdGlmaWNhdGlvbnMgfSBmcm9tICcuL25vdGlmaWNhdGlvbnMnO1xuXG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIHN0YXRlIG9mIGEgcGF0Y2guXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ29udGV4dCgpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHsoQXJyYXk8IU5vZGU+fHVuZGVmaW5lZCl9XG4gICAqL1xuICB0aGlzLmNyZWF0ZWQgPSBub3RpZmljYXRpb25zLm5vZGVzQ3JlYXRlZCAmJiBbXTtcblxuICAvKipcbiAgICogQHR5cGUgeyhBcnJheTwhTm9kZT58dW5kZWZpbmVkKX1cbiAgICovXG4gIHRoaXMuZGVsZXRlZCA9IG5vdGlmaWNhdGlvbnMubm9kZXNEZWxldGVkICYmIFtdO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICovXG5Db250ZXh0LnByb3RvdHlwZS5tYXJrQ3JlYXRlZCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgaWYgKHRoaXMuY3JlYXRlZCkge1xuICAgIHRoaXMuY3JlYXRlZC5wdXNoKG5vZGUpO1xuICB9XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICovXG5Db250ZXh0LnByb3RvdHlwZS5tYXJrRGVsZXRlZCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgIHRoaXMuZGVsZXRlZC5wdXNoKG5vZGUpO1xuICB9XG59O1xuXG5cbi8qKlxuICogTm90aWZpZXMgYWJvdXQgbm9kZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZHVyaW5nIHRoZSBwYXRjaCBvcGVhcmF0aW9uLlxuICovXG5Db250ZXh0LnByb3RvdHlwZS5ub3RpZnlDaGFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmNyZWF0ZWQgJiYgdGhpcy5jcmVhdGVkLmxlbmd0aCA+IDApIHtcbiAgICBub3RpZmljYXRpb25zLm5vZGVzQ3JlYXRlZCh0aGlzLmNyZWF0ZWQpO1xuICB9XG5cbiAgaWYgKHRoaXMuZGVsZXRlZCAmJiB0aGlzLmRlbGV0ZWQubGVuZ3RoID4gMCkge1xuICAgIG5vdGlmaWNhdGlvbnMubm9kZXNEZWxldGVkKHRoaXMuZGVsZXRlZCk7XG4gIH1cbn07XG5cblxuLyoqICovXG5leHBvcnQge1xuICBDb250ZXh0XG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSBUaGUgSW5jcmVtZW50YWwgRE9NIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cbi8qKlxuICAqIEtlZXBzIHRyYWNrIHdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBhbiBhdHRyaWJ1dGVzIGRlY2xhcmF0aW9uIChhZnRlclxuICAqIGVsZW1lbnRPcGVuU3RhcnQsIGJ1dCBiZWZvcmUgZWxlbWVudE9wZW5FbmQpLlxuICAqIEB0eXBlIHtib29sZWFufVxuICAqL1xubGV0IGluQXR0cmlidXRlcyA9IGZhbHNlO1xuXG5cbi8qKlxuICAqIEtlZXBzIHRyYWNrIHdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBhbiBlbGVtZW50IHRoYXQgc2hvdWxkIG5vdCBoYXZlIGl0c1xuICAqIGNoaWxkcmVuIGNsZWFyZWQuXG4gICogQHR5cGUge2Jvb2xlYW59XG4gICovXG5sZXQgaW5Ta2lwID0gZmFsc2U7XG5cblxuLyoqXG4gKiBNYWtlcyBzdXJlIHRoYXQgdGhlcmUgaXMgYSBjdXJyZW50IHBhdGNoIGNvbnRleHQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25OYW1lXG4gKiBAcGFyYW0geyp9IGNvbnRleHRcbiAqL1xuY29uc3QgYXNzZXJ0SW5QYXRjaCA9IGZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgY29udGV4dCkge1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxsICcgKyBmdW5jdGlvbk5hbWUgKyAnKCkgdW5sZXNzIGluIHBhdGNoLicpO1xuICB9XG59O1xuXG5cbi8qKlxuICogTWFrZXMgc3VyZSB0aGF0IGEgcGF0Y2ggY2xvc2VzIGV2ZXJ5IG5vZGUgdGhhdCBpdCBvcGVuZWQuXG4gKiBAcGFyYW0gez9Ob2RlfSBvcGVuRWxlbWVudFxuICogQHBhcmFtIHshTm9kZXwhRG9jdW1lbnRGcmFnbWVudH0gcm9vdFxuICovXG5jb25zdCBhc3NlcnROb1VuY2xvc2VkVGFncyA9IGZ1bmN0aW9uKG9wZW5FbGVtZW50LCByb290KSB7XG4gIGlmIChvcGVuRWxlbWVudCA9PT0gcm9vdCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBjdXJyZW50RWxlbWVudCA9IG9wZW5FbGVtZW50O1xuICBjb25zdCBvcGVuVGFncyA9IFtdO1xuICB3aGlsZSAoY3VycmVudEVsZW1lbnQgJiYgY3VycmVudEVsZW1lbnQgIT09IHJvb3QpIHtcbiAgICBvcGVuVGFncy5wdXNoKGN1cnJlbnRFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgIGN1cnJlbnRFbGVtZW50ID0gY3VycmVudEVsZW1lbnQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignT25lIG9yIG1vcmUgdGFncyB3ZXJlIG5vdCBjbG9zZWQ6XFxuJyArXG4gICAgICBvcGVuVGFncy5qb2luKCdcXG4nKSk7XG59O1xuXG5cbi8qKlxuICogTWFrZXMgc3VyZSB0aGF0IHRoZSBjYWxsZXIgaXMgbm90IHdoZXJlIGF0dHJpYnV0ZXMgYXJlIGV4cGVjdGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uTmFtZVxuICovXG5jb25zdCBhc3NlcnROb3RJbkF0dHJpYnV0ZXMgPSBmdW5jdGlvbihmdW5jdGlvbk5hbWUpIHtcbiAgaWYgKGluQXR0cmlidXRlcykge1xuICAgIHRocm93IG5ldyBFcnJvcihmdW5jdGlvbk5hbWUgKyAnKCkgY2FuIG5vdCBiZSBjYWxsZWQgYmV0d2VlbiAnICtcbiAgICAgICAgJ2VsZW1lbnRPcGVuU3RhcnQoKSBhbmQgZWxlbWVudE9wZW5FbmQoKS4nKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIE1ha2VzIHN1cmUgdGhhdCB0aGUgY2FsbGVyIGlzIG5vdCBpbnNpZGUgYW4gZWxlbWVudCB0aGF0IGhhcyBkZWNsYXJlZCBza2lwLlxuICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uTmFtZVxuICovXG5jb25zdCBhc3NlcnROb3RJblNraXAgPSBmdW5jdGlvbihmdW5jdGlvbk5hbWUpIHtcbiAgaWYgKGluU2tpcCkge1xuICAgIHRocm93IG5ldyBFcnJvcihmdW5jdGlvbk5hbWUgKyAnKCkgbWF5IG5vdCBiZSBjYWxsZWQgaW5zaWRlIGFuIGVsZW1lbnQgJyArXG4gICAgICAgICd0aGF0IGhhcyBjYWxsZWQgc2tpcCgpLicpO1xuICB9XG59O1xuXG5cbi8qKlxuICogTWFrZXMgc3VyZSB0aGF0IHRoZSBjYWxsZXIgaXMgd2hlcmUgYXR0cmlidXRlcyBhcmUgZXhwZWN0ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25OYW1lXG4gKi9cbmNvbnN0IGFzc2VydEluQXR0cmlidXRlcyA9IGZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSkge1xuICBpZiAoIWluQXR0cmlidXRlcykge1xuICAgIHRocm93IG5ldyBFcnJvcihmdW5jdGlvbk5hbWUgKyAnKCkgY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIGNhbGxpbmcgJyArXG4gICAgICAgICdlbGVtZW50T3BlblN0YXJ0KCkuJyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBNYWtlcyBzdXJlIHRoZSBwYXRjaCBjbG9zZXMgdmlydHVhbCBhdHRyaWJ1dGVzIGNhbGxcbiAqL1xuY29uc3QgYXNzZXJ0VmlydHVhbEF0dHJpYnV0ZXNDbG9zZWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGluQXR0cmlidXRlcykge1xuICAgIHRocm93IG5ldyBFcnJvcignZWxlbWVudE9wZW5FbmQoKSBtdXN0IGJlIGNhbGxlZCBhZnRlciBjYWxsaW5nICcgK1xuICAgICAgICAnZWxlbWVudE9wZW5TdGFydCgpLicpO1xuICB9XG59O1xuXG5cbi8qKlxuICAqIE1ha2VzIHN1cmUgdGhhdCB0YWdzIGFyZSBjb3JyZWN0bHkgbmVzdGVkLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBub2RlTmFtZVxuICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdcbiAgKi9cbmNvbnN0IGFzc2VydENsb3NlTWF0Y2hlc09wZW5UYWcgPSBmdW5jdGlvbihub2RlTmFtZSwgdGFnKSB7XG4gIGlmIChub2RlTmFtZSAhPT0gdGFnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWNlaXZlZCBhIGNhbGwgdG8gY2xvc2UgXCInICsgdGFnICsgJ1wiIGJ1dCBcIicgK1xuICAgICAgICBub2RlTmFtZSArICdcIiB3YXMgb3Blbi4nKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIE1ha2VzIHN1cmUgdGhhdCBubyBjaGlsZHJlbiBlbGVtZW50cyBoYXZlIGJlZW4gZGVjbGFyZWQgeWV0IGluIHRoZSBjdXJyZW50XG4gKiBlbGVtZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uTmFtZVxuICogQHBhcmFtIHs/Tm9kZX0gcHJldmlvdXNOb2RlXG4gKi9cbmNvbnN0IGFzc2VydE5vQ2hpbGRyZW5EZWNsYXJlZFlldCA9IGZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgcHJldmlvdXNOb2RlKSB7XG4gIGlmIChwcmV2aW91c05vZGUgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZnVuY3Rpb25OYW1lICsgJygpIG11c3QgY29tZSBiZWZvcmUgYW55IGNoaWxkICcgK1xuICAgICAgICAnZGVjbGFyYXRpb25zIGluc2lkZSB0aGUgY3VycmVudCBlbGVtZW50LicpO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ2hlY2tzIHRoYXQgYSBjYWxsIHRvIHBhdGNoT3V0ZXIgYWN0dWFsbHkgcGF0Y2hlZCB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7P05vZGV9IHN0YXJ0Tm9kZSBUaGUgdmFsdWUgZm9yIHRoZSBjdXJyZW50Tm9kZSB3aGVuIHRoZSBwYXRjaFxuICogICAgIHN0YXJ0ZWQuXG4gKiBAcGFyYW0gez9Ob2RlfSBjdXJyZW50Tm9kZSBUaGUgY3VycmVudE5vZGUgd2hlbiB0aGUgcGF0Y2ggZmluaXNoZWQuXG4gKiBAcGFyYW0gez9Ob2RlfSBleHBlY3RlZE5leHROb2RlIFRoZSBOb2RlIHRoYXQgaXMgZXhwZWN0ZWQgdG8gZm9sbG93IHRoZVxuICogICAgY3VycmVudE5vZGUgYWZ0ZXIgdGhlIHBhdGNoO1xuICogQHBhcmFtIHs/Tm9kZX0gZXhwZWN0ZWRQcmV2Tm9kZSBUaGUgTm9kZSB0aGF0IGlzIGV4cGVjdGVkIHRvIHByZWNlZWQgdGhlXG4gKiAgICBjdXJyZW50Tm9kZSBhZnRlciB0aGUgcGF0Y2guXG4gKi9cbmNvbnN0IGFzc2VydFBhdGNoRWxlbWVudE5vRXh0cmFzID0gZnVuY3Rpb24oXG4gICAgc3RhcnROb2RlLFxuICAgIGN1cnJlbnROb2RlLFxuICAgIGV4cGVjdGVkTmV4dE5vZGUsXG4gICAgZXhwZWN0ZWRQcmV2Tm9kZSkge1xuICBjb25zdCB3YXNVcGRhdGVkID0gY3VycmVudE5vZGUubmV4dFNpYmxpbmcgPT09IGV4cGVjdGVkTmV4dE5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnByZXZpb3VzU2libGluZyA9PT0gZXhwZWN0ZWRQcmV2Tm9kZTtcbiAgY29uc3Qgd2FzQ2hhbmdlZCA9IGN1cnJlbnROb2RlLm5leHRTaWJsaW5nID09PSBzdGFydE5vZGUubmV4dFNpYmxpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnByZXZpb3VzU2libGluZyA9PT0gZXhwZWN0ZWRQcmV2Tm9kZTtcbiAgY29uc3Qgd2FzUmVtb3ZlZCA9IGN1cnJlbnROb2RlID09PSBzdGFydE5vZGU7XG5cbiAgaWYgKCF3YXNVcGRhdGVkICYmICF3YXNDaGFuZ2VkICYmICF3YXNSZW1vdmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBtdXN0IGJlIGV4YWN0bHkgb25lIHRvcCBsZXZlbCBjYWxsIGNvcnJlc3BvbmRpbmcgJyArXG4gICAgICAgICd0byB0aGUgcGF0Y2hlZCBlbGVtZW50LicpO1xuICB9XG59O1xuXG5cbi8qKlxuICogVXBkYXRlcyB0aGUgc3RhdGUgb2YgYmVpbmcgaW4gYW4gYXR0cmlidXRlIGRlY2xhcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn0gdGhlIHByZXZpb3VzIHZhbHVlLlxuICovXG5jb25zdCBzZXRJbkF0dHJpYnV0ZXMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBjb25zdCBwcmV2aW91cyA9IGluQXR0cmlidXRlcztcbiAgaW5BdHRyaWJ1dGVzID0gdmFsdWU7XG4gIHJldHVybiBwcmV2aW91cztcbn07XG5cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBzdGF0ZSBvZiBiZWluZyBpbiBhIHNraXAgZWxlbWVudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRoZSBwcmV2aW91cyB2YWx1ZS5cbiAqL1xuY29uc3Qgc2V0SW5Ta2lwID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgY29uc3QgcHJldmlvdXMgPSBpblNraXA7XG4gIGluU2tpcCA9IHZhbHVlO1xuICByZXR1cm4gcHJldmlvdXM7XG59O1xuXG5cbi8qKiAqL1xuZXhwb3J0IHtcbiAgYXNzZXJ0SW5QYXRjaCxcbiAgYXNzZXJ0Tm9VbmNsb3NlZFRhZ3MsXG4gIGFzc2VydE5vdEluQXR0cmlidXRlcyxcbiAgYXNzZXJ0SW5BdHRyaWJ1dGVzLFxuICBhc3NlcnRDbG9zZU1hdGNoZXNPcGVuVGFnLFxuICBhc3NlcnRWaXJ0dWFsQXR0cmlidXRlc0Nsb3NlZCxcbiAgYXNzZXJ0Tm9DaGlsZHJlbkRlY2xhcmVkWWV0LFxuICBhc3NlcnROb3RJblNraXAsXG4gIGFzc2VydFBhdGNoRWxlbWVudE5vRXh0cmFzLFxuICBzZXRJbkF0dHJpYnV0ZXMsXG4gIHNldEluU2tpcFxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEluY3JlbWVudGFsIERPTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIG5vZGUgdGhlIHJvb3Qgb2YgYSBkb2N1bWVudCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5jb25zdCBpc0RvY3VtZW50Um9vdCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgLy8gRm9yIFNoYWRvd1Jvb3RzLCBjaGVjayBpZiB0aGV5IGFyZSBhIERvY3VtZW50RnJhZ21lbnQgaW5zdGVhZCBvZiBpZiB0aGV5XG4gIC8vIGFyZSBhIFNoYWRvd1Jvb3Qgc28gdGhhdCB0aGlzIGNhbiB3b3JrIGluICd1c2Ugc3RyaWN0JyBpZiBTaGFkb3dSb290cyBhcmVcbiAgLy8gbm90IHN1cHBvcnRlZC5cbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudCB8fCBub2RlIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudDtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0geyFOb2RlfSBub2RlIFRoZSBub2RlIHRvIHN0YXJ0IGF0LCBpbmNsdXNpdmUuXG4gKiBAcGFyYW0gez9Ob2RlfSByb290IFRoZSByb290IGFuY2VzdG9yIHRvIGdldCB1bnRpbCwgZXhjbHVzaXZlLlxuICogQHJldHVybiB7IUFycmF5PCFOb2RlPn0gVGhlIGFuY2VzdHJ5IG9mIERPTSBub2Rlcy5cbiAqL1xuY29uc3QgZ2V0QW5jZXN0cnkgPSBmdW5jdGlvbihub2RlLCByb290KSB7XG4gIGNvbnN0IGFuY2VzdHJ5ID0gW107XG4gIGxldCBjdXIgPSBub2RlO1xuXG4gIHdoaWxlIChjdXIgIT09IHJvb3QpIHtcbiAgICBhbmNlc3RyeS5wdXNoKGN1cik7XG4gICAgY3VyID0gY3VyLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gYW5jZXN0cnk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICogQHJldHVybiB7IU5vZGV9IFRoZSByb290IG5vZGUgb2YgdGhlIERPTSB0cmVlIHRoYXQgY29udGFpbnMgbm9kZS5cbiAqL1xuY29uc3QgZ2V0Um9vdCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgbGV0IGN1ciA9IG5vZGU7XG4gIGxldCBwcmV2ID0gY3VyO1xuXG4gIHdoaWxlIChjdXIpIHtcbiAgICBwcmV2ID0gY3VyO1xuICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIHByZXY7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHshTm9kZX0gbm9kZSBUaGUgbm9kZSB0byBnZXQgdGhlIGFjdGl2ZUVsZW1lbnQgZm9yLlxuICogQHJldHVybiB7P0VsZW1lbnR9IFRoZSBhY3RpdmVFbGVtZW50IGluIHRoZSBEb2N1bWVudCBvciBTaGFkb3dSb290XG4gKiAgICAgY29ycmVzcG9uZGluZyB0byBub2RlLCBpZiBwcmVzZW50LlxuICovXG5jb25zdCBnZXRBY3RpdmVFbGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICBjb25zdCByb290ID0gZ2V0Um9vdChub2RlKTtcbiAgcmV0dXJuIGlzRG9jdW1lbnRSb290KHJvb3QpID8gcm9vdC5hY3RpdmVFbGVtZW50IDogbnVsbDtcbn07XG5cblxuLyoqXG4gKiBHZXRzIHRoZSBwYXRoIG9mIG5vZGVzIHRoYXQgY29udGFpbiB0aGUgZm9jdXNlZCBub2RlIGluIHRoZSBzYW1lIGRvY3VtZW50IGFzXG4gKiBhIHJlZmVyZW5jZSBub2RlLCB1cCB1bnRpbCB0aGUgcm9vdC5cbiAqIEBwYXJhbSB7IU5vZGV9IG5vZGUgVGhlIHJlZmVyZW5jZSBub2RlIHRvIGdldCB0aGUgYWN0aXZlRWxlbWVudCBmb3IuXG4gKiBAcGFyYW0gez9Ob2RlfSByb290IFRoZSByb290IHRvIGdldCB0aGUgZm9jdXNlZCBwYXRoIHVudGlsLlxuICogQHJldHVybiB7IUFycmF5PE5vZGU+fVxuICovXG5jb25zdCBnZXRGb2N1c2VkUGF0aCA9IGZ1bmN0aW9uKG5vZGUsIHJvb3QpIHtcbiAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGdldEFjdGl2ZUVsZW1lbnQobm9kZSk7XG5cbiAgaWYgKCFhY3RpdmVFbGVtZW50IHx8ICFub2RlLmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIGdldEFuY2VzdHJ5KGFjdGl2ZUVsZW1lbnQsIHJvb3QpO1xufTtcblxuXG4vKipcbiAqIExpa2UgaW5zZXJ0QmVmb3JlLCBidXQgaW5zdGVhZCBpbnN0ZWFkIG9mIG1vdmluZyB0aGUgZGVzaXJlZCBub2RlLCBpbnN0ZWFkXG4gKiBtb3ZlcyBhbGwgdGhlIG90aGVyIG5vZGVzIGFmdGVyLlxuICogQHBhcmFtIHs/Tm9kZX0gcGFyZW50Tm9kZVxuICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICogQHBhcmFtIHs/Tm9kZX0gcmVmZXJlbmNlTm9kZVxuICovXG5jb25zdCBtb3ZlQmVmb3JlID0gZnVuY3Rpb24ocGFyZW50Tm9kZSwgbm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBjb25zdCBpbnNlcnRSZWZlcmVuY2VOb2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgbGV0IGN1ciA9IHJlZmVyZW5jZU5vZGU7XG5cbiAgd2hpbGUgKGN1ciAhPT0gbm9kZSkge1xuICAgIGNvbnN0IG5leHQgPSBjdXIubmV4dFNpYmxpbmc7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY3VyLCBpbnNlcnRSZWZlcmVuY2VOb2RlKTtcbiAgICBjdXIgPSBuZXh0O1xuICB9XG59O1xuXG5cbi8qKiAqL1xuZXhwb3J0IHtcbiAgZ2V0Rm9jdXNlZFBhdGgsXG4gIG1vdmVCZWZvcmVcbn07XG5cbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUgVGhlIEluY3JlbWVudGFsIERPTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtcbiAgY3JlYXRlRWxlbWVudCxcbiAgY3JlYXRlVGV4dFxufSBmcm9tICcuL25vZGVzJztcbmltcG9ydCB7IGdldERhdGEgfSBmcm9tICcuL25vZGVfZGF0YSc7XG5pbXBvcnQgeyBDb250ZXh0IH0gZnJvbSAnLi9jb250ZXh0JztcbmltcG9ydCB7XG4gIGFzc2VydEluUGF0Y2gsXG4gIGFzc2VydE5vVW5jbG9zZWRUYWdzLFxuICBhc3NlcnROb3RJbkF0dHJpYnV0ZXMsXG4gIGFzc2VydFZpcnR1YWxBdHRyaWJ1dGVzQ2xvc2VkLFxuICBhc3NlcnROb0NoaWxkcmVuRGVjbGFyZWRZZXQsXG4gIGFzc2VydFBhdGNoRWxlbWVudE5vRXh0cmFzLFxuICBzZXRJbkF0dHJpYnV0ZXMsXG4gIHNldEluU2tpcFxufSBmcm9tICcuL2Fzc2VydGlvbnMnO1xuaW1wb3J0IHtcbiAgZ2V0Rm9jdXNlZFBhdGgsXG4gIG1vdmVCZWZvcmVcbn0gZnJvbSAnLi9kb21fdXRpbCc7XG5cblxuLyoqIEB0eXBlIHs/Q29udGV4dH0gKi9cbmxldCBjb250ZXh0ID0gbnVsbDtcblxuLyoqIEB0eXBlIHs/Tm9kZX0gKi9cbmxldCBjdXJyZW50Tm9kZSA9IG51bGw7XG5cbi8qKiBAdHlwZSB7P05vZGV9ICovXG5sZXQgY3VycmVudFBhcmVudCA9IG51bGw7XG5cbi8qKiBAdHlwZSB7P0RvY3VtZW50fSAqL1xubGV0IGRvYyA9IG51bGw7XG5cblxuLyoqXG4gKiBAcGFyYW0geyFBcnJheTxOb2RlPn0gZm9jdXNQYXRoIFRoZSBub2RlcyB0byBtYXJrLlxuICogQHBhcmFtIHtib29sZWFufSBmb2N1c2VkIFdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGZvY3VzZWQuXG4gKi9cbmNvbnN0IG1hcmtGb2N1c2VkID0gZnVuY3Rpb24oZm9jdXNQYXRoLCBmb2N1c2VkKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm9jdXNQYXRoLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgZ2V0RGF0YShmb2N1c1BhdGhbaV0pLmZvY3VzZWQgPSBmb2N1c2VkO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyBhIHBhdGNoZXIgZnVuY3Rpb24gdGhhdCBzZXRzIHVwIGFuZCByZXN0b3JlcyBhIHBhdGNoIGNvbnRleHQsXG4gKiBydW5uaW5nIHRoZSBydW4gZnVuY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQgZGF0YS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKCFFbGVtZW50fCFEb2N1bWVudEZyYWdtZW50KSwhZnVuY3Rpb24oVCksVD0pOiA/Tm9kZX0gcnVuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigoIUVsZW1lbnR8IURvY3VtZW50RnJhZ21lbnQpLCFmdW5jdGlvbihUKSxUPSk6ID9Ob2RlfVxuICogQHRlbXBsYXRlIFRcbiAqL1xuY29uc3QgcGF0Y2hGYWN0b3J5ID0gZnVuY3Rpb24ocnVuKSB7XG4gIC8qKlxuICAgKiBUT0RPKG1veik6IFRoZXNlIGFubm90YXRpb25zIHdvbid0IGJlIG5lY2Vzc2FyeSBvbmNlIHdlIHN3aXRjaCB0byBDbG9zdXJlXG4gICAqIENvbXBpbGVyJ3MgbmV3IHR5cGUgaW5mZXJlbmNlLiBSZW1vdmUgdGhlc2Ugb25jZSB0aGUgc3dpdGNoIGlzIGRvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7KCFFbGVtZW50fCFEb2N1bWVudEZyYWdtZW50KX0gbm9kZVxuICAgKiBAcGFyYW0geyFmdW5jdGlvbihUKX0gZm5cbiAgICogQHBhcmFtIHtUPX0gZGF0YVxuICAgKiBAcmV0dXJuIHs/Tm9kZX0gbm9kZVxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cbiAgY29uc3QgZiA9IGZ1bmN0aW9uKG5vZGUsIGZuLCBkYXRhKSB7XG4gICAgY29uc3QgcHJldkNvbnRleHQgPSBjb250ZXh0O1xuICAgIGNvbnN0IHByZXZEb2MgPSBkb2M7XG4gICAgY29uc3QgcHJldkN1cnJlbnROb2RlID0gY3VycmVudE5vZGU7XG4gICAgY29uc3QgcHJldkN1cnJlbnRQYXJlbnQgPSBjdXJyZW50UGFyZW50O1xuICAgIGxldCBwcmV2aW91c0luQXR0cmlidXRlcyA9IGZhbHNlO1xuICAgIGxldCBwcmV2aW91c0luU2tpcCA9IGZhbHNlO1xuXG4gICAgY29udGV4dCA9IG5ldyBDb250ZXh0KCk7XG4gICAgZG9jID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIGN1cnJlbnRQYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJldmlvdXNJbkF0dHJpYnV0ZXMgPSBzZXRJbkF0dHJpYnV0ZXMoZmFsc2UpO1xuICAgICAgcHJldmlvdXNJblNraXAgPSBzZXRJblNraXAoZmFsc2UpO1xuICAgIH1cblxuICAgIGNvbnN0IGZvY3VzUGF0aCA9IGdldEZvY3VzZWRQYXRoKG5vZGUsIGN1cnJlbnRQYXJlbnQpO1xuICAgIG1hcmtGb2N1c2VkKGZvY3VzUGF0aCwgdHJ1ZSk7XG4gICAgY29uc3QgcmV0VmFsID0gcnVuKG5vZGUsIGZuLCBkYXRhKTtcbiAgICBtYXJrRm9jdXNlZChmb2N1c1BhdGgsIGZhbHNlKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnRWaXJ0dWFsQXR0cmlidXRlc0Nsb3NlZCgpO1xuICAgICAgc2V0SW5BdHRyaWJ1dGVzKHByZXZpb3VzSW5BdHRyaWJ1dGVzKTtcbiAgICAgIHNldEluU2tpcChwcmV2aW91c0luU2tpcCk7XG4gICAgfVxuXG4gICAgY29udGV4dC5ub3RpZnlDaGFuZ2VzKCk7XG5cbiAgICBjb250ZXh0ID0gcHJldkNvbnRleHQ7XG4gICAgZG9jID0gcHJldkRvYztcbiAgICBjdXJyZW50Tm9kZSA9IHByZXZDdXJyZW50Tm9kZTtcbiAgICBjdXJyZW50UGFyZW50ID0gcHJldkN1cnJlbnRQYXJlbnQ7XG5cbiAgICByZXR1cm4gcmV0VmFsO1xuICB9O1xuICByZXR1cm4gZjtcbn07XG5cblxuLyoqXG4gKiBQYXRjaGVzIHRoZSBkb2N1bWVudCBzdGFydGluZyBhdCBub2RlIHdpdGggdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLiBUaGlzXG4gKiBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGR1cmluZyBhbiBleGlzdGluZyBwYXRjaCBvcGVyYXRpb24uXG4gKiBAcGFyYW0geyFFbGVtZW50fCFEb2N1bWVudEZyYWdtZW50fSBub2RlIFRoZSBFbGVtZW50IG9yIERvY3VtZW50XG4gKiAgICAgdG8gcGF0Y2guXG4gKiBAcGFyYW0geyFmdW5jdGlvbihUKX0gZm4gQSBmdW5jdGlvbiBjb250YWluaW5nIGVsZW1lbnRPcGVuL2VsZW1lbnRDbG9zZS9ldGMuXG4gKiAgICAgY2FsbHMgdGhhdCBkZXNjcmliZSB0aGUgRE9NLlxuICogQHBhcmFtIHtUPX0gZGF0YSBBbiBhcmd1bWVudCBwYXNzZWQgdG8gZm4gdG8gcmVwcmVzZW50IERPTSBzdGF0ZS5cbiAqIEByZXR1cm4geyFOb2RlfSBUaGUgcGF0Y2hlZCBub2RlLlxuICogQHRlbXBsYXRlIFRcbiAqL1xuY29uc3QgcGF0Y2hJbm5lciA9IHBhdGNoRmFjdG9yeShmdW5jdGlvbihub2RlLCBmbiwgZGF0YSkge1xuICBjdXJyZW50Tm9kZSA9IG5vZGU7XG5cbiAgZW50ZXJOb2RlKCk7XG4gIGZuKGRhdGEpO1xuICBleGl0Tm9kZSgpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0Tm9VbmNsb3NlZFRhZ3MoY3VycmVudE5vZGUsIG5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59KTtcblxuXG4vKipcbiAqIFBhdGNoZXMgYW4gRWxlbWVudCB3aXRoIHRoZSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uIEV4YWN0bHkgb25lIHRvcCBsZXZlbFxuICogZWxlbWVudCBjYWxsIHNob3VsZCBiZSBtYWRlIGNvcnJlc3BvbmRpbmcgdG8gYG5vZGVgLlxuICogQHBhcmFtIHshRWxlbWVudH0gbm9kZSBUaGUgRWxlbWVudCB3aGVyZSB0aGUgcGF0Y2ggc2hvdWxkIHN0YXJ0LlxuICogQHBhcmFtIHshZnVuY3Rpb24oVCl9IGZuIEEgZnVuY3Rpb24gY29udGFpbmluZyBlbGVtZW50T3Blbi9lbGVtZW50Q2xvc2UvZXRjLlxuICogICAgIGNhbGxzIHRoYXQgZGVzY3JpYmUgdGhlIERPTS4gVGhpcyBzaG91bGQgaGF2ZSBhdCBtb3N0IG9uZSB0b3AgbGV2ZWxcbiAqICAgICBlbGVtZW50IGNhbGwuXG4gKiBAcGFyYW0ge1Q9fSBkYXRhIEFuIGFyZ3VtZW50IHBhc3NlZCB0byBmbiB0byByZXByZXNlbnQgRE9NIHN0YXRlLlxuICogQHJldHVybiB7P05vZGV9IFRoZSBub2RlIGlmIGl0IHdhcyB1cGRhdGVkLCBpdHMgcmVwbGFjZWRtZW50IG9yIG51bGwgaWYgaXRcbiAqICAgICB3YXMgcmVtb3ZlZC5cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmNvbnN0IHBhdGNoT3V0ZXIgPSBwYXRjaEZhY3RvcnkoZnVuY3Rpb24obm9kZSwgZm4sIGRhdGEpIHtcbiAgbGV0IHN0YXJ0Tm9kZSA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovKHsgbmV4dFNpYmxpbmc6IG5vZGUgfSk7XG4gIGxldCBleHBlY3RlZE5leHROb2RlID0gbnVsbDtcbiAgbGV0IGV4cGVjdGVkUHJldk5vZGUgPSBudWxsO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZXhwZWN0ZWROZXh0Tm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgZXhwZWN0ZWRQcmV2Tm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICB9XG5cbiAgY3VycmVudE5vZGUgPSBzdGFydE5vZGU7XG4gIGZuKGRhdGEpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0UGF0Y2hFbGVtZW50Tm9FeHRyYXMoc3RhcnROb2RlLCBjdXJyZW50Tm9kZSwgZXhwZWN0ZWROZXh0Tm9kZSxcbiAgICAgICAgZXhwZWN0ZWRQcmV2Tm9kZSk7XG4gIH1cblxuICBpZiAobm9kZSAhPT0gY3VycmVudE5vZGUgJiYgbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgcmVtb3ZlQ2hpbGQoY3VycmVudFBhcmVudCwgbm9kZSwgZ2V0RGF0YShjdXJyZW50UGFyZW50KS5rZXlNYXApO1xuICB9XG5cbiAgcmV0dXJuIChzdGFydE5vZGUgPT09IGN1cnJlbnROb2RlKSA/IG51bGwgOiBjdXJyZW50Tm9kZTtcbn0pO1xuXG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoZSBjdXJyZW50IG5vZGUgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIG5vZGVOYW1lIGFuZFxuICoga2V5LlxuICpcbiAqIEBwYXJhbSB7IU5vZGV9IG1hdGNoTm9kZSBBIG5vZGUgdG8gbWF0Y2ggdGhlIGRhdGEgdG8uXG4gKiBAcGFyYW0gez9zdHJpbmd9IG5vZGVOYW1lIFRoZSBub2RlTmFtZSBmb3IgdGhpcyBub2RlLlxuICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IEFuIG9wdGlvbmFsIGtleSB0aGF0IGlkZW50aWZpZXMgYSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgbm9kZSBtYXRjaGVzLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmNvbnN0IG1hdGNoZXMgPSBmdW5jdGlvbihtYXRjaE5vZGUsIG5vZGVOYW1lLCBrZXkpIHtcbiAgY29uc3QgZGF0YSA9IGdldERhdGEobWF0Y2hOb2RlKTtcblxuICAvLyBLZXkgY2hlY2sgaXMgZG9uZSB1c2luZyBkb3VibGUgZXF1YWxzIGFzIHdlIHdhbnQgdG8gdHJlYXQgYSBudWxsIGtleSB0aGVcbiAgLy8gc2FtZSBhcyB1bmRlZmluZWQuIFRoaXMgc2hvdWxkIGJlIG9rYXkgYXMgdGhlIG9ubHkgdmFsdWVzIGFsbG93ZWQgYXJlXG4gIC8vIHN0cmluZ3MsIG51bGwgYW5kIHVuZGVmaW5lZCBzbyB0aGUgPT0gc2VtYW50aWNzIGFyZSBub3QgdG9vIHdlaXJkLlxuICByZXR1cm4gbm9kZU5hbWUgPT09IGRhdGEubm9kZU5hbWUgJiYga2V5ID09IGRhdGEua2V5O1xufTtcblxuXG4vKipcbiAqIEFsaWducyB0aGUgdmlydHVhbCBFbGVtZW50IGRlZmluaXRpb24gd2l0aCB0aGUgYWN0dWFsIERPTSwgbW92aW5nIHRoZVxuICogY29ycmVzcG9uZGluZyBET00gbm9kZSB0byB0aGUgY29ycmVjdCBsb2NhdGlvbiBvciBjcmVhdGluZyBpdCBpZiBuZWNlc3NhcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWUgRm9yIGFuIEVsZW1lbnQsIHRoaXMgc2hvdWxkIGJlIGEgdmFsaWQgdGFnIHN0cmluZy5cbiAqICAgICBGb3IgYSBUZXh0LCB0aGlzIHNob3VsZCBiZSAjdGV4dC5cbiAqIEBwYXJhbSB7P3N0cmluZz19IGtleSBUaGUga2V5IHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBlbGVtZW50LlxuICovXG5jb25zdCBhbGlnbldpdGhET00gPSBmdW5jdGlvbihub2RlTmFtZSwga2V5KSB7XG4gIGlmIChjdXJyZW50Tm9kZSAmJiBtYXRjaGVzKGN1cnJlbnROb2RlLCBub2RlTmFtZSwga2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHBhcmVudERhdGEgPSBnZXREYXRhKGN1cnJlbnRQYXJlbnQpO1xuICBjb25zdCBjdXJyZW50Tm9kZURhdGEgPSBjdXJyZW50Tm9kZSAmJiBnZXREYXRhKGN1cnJlbnROb2RlKTtcbiAgY29uc3Qga2V5TWFwID0gcGFyZW50RGF0YS5rZXlNYXA7XG4gIGxldCBub2RlO1xuXG4gIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgbm9kZSBoYXMgbW92ZWQgd2l0aGluIHRoZSBwYXJlbnQuXG4gIGlmIChrZXkpIHtcbiAgICBjb25zdCBrZXlOb2RlID0ga2V5TWFwW2tleV07XG4gICAgaWYgKGtleU5vZGUpIHtcbiAgICAgIGlmIChtYXRjaGVzKGtleU5vZGUsIG5vZGVOYW1lLCBrZXkpKSB7XG4gICAgICAgIG5vZGUgPSBrZXlOb2RlO1xuICAgICAgfSBlbHNlIGlmIChrZXlOb2RlID09PSBjdXJyZW50Tm9kZSkge1xuICAgICAgICBjb250ZXh0Lm1hcmtEZWxldGVkKGtleU5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGQoY3VycmVudFBhcmVudCwga2V5Tm9kZSwga2V5TWFwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDcmVhdGUgdGhlIG5vZGUgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgaWYgKCFub2RlKSB7XG4gICAgaWYgKG5vZGVOYW1lID09PSAnI3RleHQnKSB7XG4gICAgICBub2RlID0gY3JlYXRlVGV4dChkb2MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gY3JlYXRlRWxlbWVudChkb2MsIGN1cnJlbnRQYXJlbnQsIG5vZGVOYW1lLCBrZXkpO1xuICAgIH1cblxuICAgIGlmIChrZXkpIHtcbiAgICAgIGtleU1hcFtrZXldID0gbm9kZTtcbiAgICB9XG5cbiAgICBjb250ZXh0Lm1hcmtDcmVhdGVkKG5vZGUpO1xuICB9XG5cbiAgLy8gUmUtb3JkZXIgdGhlIG5vZGUgaW50byB0aGUgcmlnaHQgcG9zaXRpb24sIHByZXNlcnZpbmcgZm9jdXMgaWYgZWl0aGVyXG4gIC8vIG5vZGUgb3IgY3VycmVudE5vZGUgYXJlIGZvY3VzZWQgYnkgbWFraW5nIHN1cmUgdGhhdCB0aGV5IGFyZSBub3QgZGV0YWNoZWRcbiAgLy8gZnJvbSB0aGUgRE9NLlxuICBpZiAoZ2V0RGF0YShub2RlKS5mb2N1c2VkKSB7XG4gICAgLy8gTW92ZSBldmVyeXRoaW5nIGVsc2UgYmVmb3JlIHRoZSBub2RlLlxuICAgIG1vdmVCZWZvcmUoY3VycmVudFBhcmVudCwgbm9kZSwgY3VycmVudE5vZGUpO1xuICB9IGVsc2UgaWYgKGN1cnJlbnROb2RlRGF0YSAmJiBjdXJyZW50Tm9kZURhdGEua2V5ICYmICFjdXJyZW50Tm9kZURhdGEuZm9jdXNlZCkge1xuICAgIC8vIFJlbW92ZSB0aGUgY3VycmVudE5vZGUsIHdoaWNoIGNhbiBhbHdheXMgYmUgYWRkZWQgYmFjayBzaW5jZSB3ZSBob2xkIGFcbiAgICAvLyByZWZlcmVuY2UgdGhyb3VnaCB0aGUga2V5TWFwLiBUaGlzIHByZXZlbnRzIGEgbGFyZ2UgbnVtYmVyIG9mIG1vdmVzIHdoZW5cbiAgICAvLyBhIGtleWVkIGl0ZW0gaXMgcmVtb3ZlZCBvciBtb3ZlZCBiYWNrd2FyZHMgaW4gdGhlIERPTS5cbiAgICBjdXJyZW50UGFyZW50LnJlcGxhY2VDaGlsZChub2RlLCBjdXJyZW50Tm9kZSk7XG4gICAgcGFyZW50RGF0YS5rZXlNYXBWYWxpZCA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGN1cnJlbnRQYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIGN1cnJlbnROb2RlKTtcbiAgfVxuXG4gIGN1cnJlbnROb2RlID0gbm9kZTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0gez9Ob2RlfSBub2RlXG4gKiBAcGFyYW0gez9Ob2RlfSBjaGlsZFxuICogQHBhcmFtIHs/T2JqZWN0PHN0cmluZywgIUVsZW1lbnQ+fSBrZXlNYXBcbiAqL1xuY29uc3QgcmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbihub2RlLCBjaGlsZCwga2V5TWFwKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICBjb250ZXh0Lm1hcmtEZWxldGVkKC8qKiBAdHlwZSB7IU5vZGV9Ki8oY2hpbGQpKTtcblxuICBjb25zdCBrZXkgPSBnZXREYXRhKGNoaWxkKS5rZXk7XG4gIGlmIChrZXkpIHtcbiAgICBkZWxldGUga2V5TWFwW2tleV07XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDbGVhcnMgb3V0IGFueSB1bnZpc2l0ZWQgTm9kZXMsIGFzIHRoZSBjb3JyZXNwb25kaW5nIHZpcnR1YWwgZWxlbWVudFxuICogZnVuY3Rpb25zIHdlcmUgbmV2ZXIgY2FsbGVkIGZvciB0aGVtLlxuICovXG5jb25zdCBjbGVhclVudmlzaXRlZERPTSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBub2RlID0gY3VycmVudFBhcmVudDtcbiAgY29uc3QgZGF0YSA9IGdldERhdGEobm9kZSk7XG4gIGNvbnN0IGtleU1hcCA9IGRhdGEua2V5TWFwO1xuICBjb25zdCBrZXlNYXBWYWxpZCA9IGRhdGEua2V5TWFwVmFsaWQ7XG4gIGxldCBjaGlsZCA9IG5vZGUubGFzdENoaWxkO1xuICBsZXQga2V5O1xuXG4gIGlmIChjaGlsZCA9PT0gY3VycmVudE5vZGUgJiYga2V5TWFwVmFsaWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3aGlsZSAoY2hpbGQgIT09IGN1cnJlbnROb2RlKSB7XG4gICAgcmVtb3ZlQ2hpbGQobm9kZSwgY2hpbGQsIGtleU1hcCk7XG4gICAgY2hpbGQgPSBub2RlLmxhc3RDaGlsZDtcbiAgfVxuXG4gIC8vIENsZWFuIHRoZSBrZXlNYXAsIHJlbW92aW5nIGFueSB1bnVzdWVkIGtleXMuXG4gIGlmICgha2V5TWFwVmFsaWQpIHtcbiAgICBmb3IgKGtleSBpbiBrZXlNYXApIHtcbiAgICAgIGNoaWxkID0ga2V5TWFwW2tleV07XG4gICAgICBpZiAoY2hpbGQucGFyZW50Tm9kZSAhPT0gbm9kZSkge1xuICAgICAgICBjb250ZXh0Lm1hcmtEZWxldGVkKGNoaWxkKTtcbiAgICAgICAgZGVsZXRlIGtleU1hcFtrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRhdGEua2V5TWFwVmFsaWQgPSB0cnVlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ2hhbmdlcyB0byB0aGUgZmlyc3QgY2hpbGQgb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAqL1xuY29uc3QgZW50ZXJOb2RlID0gZnVuY3Rpb24oKSB7XG4gIGN1cnJlbnRQYXJlbnQgPSBjdXJyZW50Tm9kZTtcbiAgY3VycmVudE5vZGUgPSBudWxsO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4gez9Ob2RlfSBUaGUgbmV4dCBOb2RlIHRvIGJlIHBhdGNoZWQuXG4gKi9cbmNvbnN0IGdldE5leHROb2RlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChjdXJyZW50Tm9kZSkge1xuICAgIHJldHVybiBjdXJyZW50Tm9kZS5uZXh0U2libGluZztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3VycmVudFBhcmVudC5maXJzdENoaWxkO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ2hhbmdlcyB0byB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBjdXJyZW50IG5vZGUuXG4gKi9cbmNvbnN0IG5leHROb2RlID0gZnVuY3Rpb24oKSB7XG4gIGN1cnJlbnROb2RlID0gZ2V0TmV4dE5vZGUoKTtcbn07XG5cblxuLyoqXG4gKiBDaGFuZ2VzIHRvIHRoZSBwYXJlbnQgb2YgdGhlIGN1cnJlbnQgbm9kZSwgcmVtb3ZpbmcgYW55IHVudmlzaXRlZCBjaGlsZHJlbi5cbiAqL1xuY29uc3QgZXhpdE5vZGUgPSBmdW5jdGlvbigpIHtcbiAgY2xlYXJVbnZpc2l0ZWRET00oKTtcblxuICBjdXJyZW50Tm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG4gIGN1cnJlbnRQYXJlbnQgPSBjdXJyZW50UGFyZW50LnBhcmVudE5vZGU7XG59O1xuXG5cbi8qKlxuICogTWFrZXMgc3VyZSB0aGF0IHRoZSBjdXJyZW50IG5vZGUgaXMgYW4gRWxlbWVudCB3aXRoIGEgbWF0Y2hpbmcgdGFnTmFtZSBhbmRcbiAqIGtleS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBlbGVtZW50J3MgdGFnLlxuICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IFRoZSBrZXkgdXNlZCB0byBpZGVudGlmeSB0aGlzIGVsZW1lbnQuIFRoaXMgY2FuIGJlIGFuXG4gKiAgICAgZW1wdHkgc3RyaW5nLCBidXQgcGVyZm9ybWFuY2UgbWF5IGJlIGJldHRlciBpZiBhIHVuaXF1ZSB2YWx1ZSBpcyB1c2VkXG4gKiAgICAgd2hlbiBpdGVyYXRpbmcgb3ZlciBhbiBhcnJheSBvZiBpdGVtcy5cbiAqIEByZXR1cm4geyFFbGVtZW50fSBUaGUgY29ycmVzcG9uZGluZyBFbGVtZW50LlxuICovXG5jb25zdCBlbGVtZW50T3BlbiA9IGZ1bmN0aW9uKHRhZywga2V5KSB7XG4gIG5leHROb2RlKCk7XG4gIGFsaWduV2l0aERPTSh0YWcsIGtleSk7XG4gIGVudGVyTm9kZSgpO1xuICByZXR1cm4gLyoqIEB0eXBlIHshRWxlbWVudH0gKi8oY3VycmVudFBhcmVudCk7XG59O1xuXG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjdXJyZW50bHkgb3BlbiBFbGVtZW50LCByZW1vdmluZyBhbnkgdW52aXNpdGVkIGNoaWxkcmVuIGlmXG4gKiBuZWNlc3NhcnkuXG4gKlxuICogQHJldHVybiB7IUVsZW1lbnR9IFRoZSBjb3JyZXNwb25kaW5nIEVsZW1lbnQuXG4gKi9cbmNvbnN0IGVsZW1lbnRDbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHNldEluU2tpcChmYWxzZSk7XG4gIH1cblxuICBleGl0Tm9kZSgpO1xuICByZXR1cm4gLyoqIEB0eXBlIHshRWxlbWVudH0gKi8oY3VycmVudE5vZGUpO1xufTtcblxuXG4vKipcbiAqIE1ha2VzIHN1cmUgdGhlIGN1cnJlbnQgbm9kZSBpcyBhIFRleHQgbm9kZSBhbmQgY3JlYXRlcyBhIFRleHQgbm9kZSBpZiBpdCBpc1xuICogbm90LlxuICpcbiAqIEByZXR1cm4geyFUZXh0fSBUaGUgY29ycmVzcG9uZGluZyBUZXh0IE5vZGUuXG4gKi9cbmNvbnN0IHRleHQgPSBmdW5jdGlvbigpIHtcbiAgbmV4dE5vZGUoKTtcbiAgYWxpZ25XaXRoRE9NKCcjdGV4dCcsIG51bGwpO1xuICByZXR1cm4gLyoqIEB0eXBlIHshVGV4dH0gKi8oY3VycmVudE5vZGUpO1xufTtcblxuXG4vKipcbiAqIEdldHMgdGhlIGN1cnJlbnQgRWxlbWVudCBiZWluZyBwYXRjaGVkLlxuICogQHJldHVybiB7IUVsZW1lbnR9XG4gKi9cbmNvbnN0IGN1cnJlbnRFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0SW5QYXRjaCgnY3VycmVudEVsZW1lbnQnLCBjb250ZXh0KTtcbiAgICBhc3NlcnROb3RJbkF0dHJpYnV0ZXMoJ2N1cnJlbnRFbGVtZW50Jyk7XG4gIH1cbiAgcmV0dXJuIC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovKGN1cnJlbnRQYXJlbnQpO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge05vZGV9IFRoZSBOb2RlIHRoYXQgd2lsbCBiZSBldmFsdWF0ZWQgZm9yIHRoZSBuZXh0IGluc3RydWN0aW9uLlxuICovXG5jb25zdCBjdXJyZW50UG9pbnRlciA9IGZ1bmN0aW9uKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydEluUGF0Y2goJ2N1cnJlbnRQb2ludGVyJywgY29udGV4dCk7XG4gICAgYXNzZXJ0Tm90SW5BdHRyaWJ1dGVzKCdjdXJyZW50UG9pbnRlcicpO1xuICB9XG4gIHJldHVybiBnZXROZXh0Tm9kZSgpO1xufTtcblxuXG4vKipcbiAqIFNraXBzIHRoZSBjaGlsZHJlbiBpbiBhIHN1YnRyZWUsIGFsbG93aW5nIGFuIEVsZW1lbnQgdG8gYmUgY2xvc2VkIHdpdGhvdXRcbiAqIGNsZWFyaW5nIG91dCB0aGUgY2hpbGRyZW4uXG4gKi9cbmNvbnN0IHNraXAgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnROb0NoaWxkcmVuRGVjbGFyZWRZZXQoJ3NraXAnLCBjdXJyZW50Tm9kZSk7XG4gICAgc2V0SW5Ta2lwKHRydWUpO1xuICB9XG4gIGN1cnJlbnROb2RlID0gY3VycmVudFBhcmVudC5sYXN0Q2hpbGQ7XG59O1xuXG5cbi8qKlxuICogU2tpcHMgdGhlIG5leHQgTm9kZSB0byBiZSBwYXRjaGVkLCBtb3ZpbmcgdGhlIHBvaW50ZXIgZm9yd2FyZCB0byB0aGUgbmV4dFxuICogc2libGluZyBvZiB0aGUgY3VycmVudCBwb2ludGVyLlxuICovXG5jb25zdCBza2lwTm9kZSA9IG5leHROb2RlO1xuXG5cbi8qKiAqL1xuZXhwb3J0IHtcbiAgZWxlbWVudE9wZW4sXG4gIGVsZW1lbnRDbG9zZSxcbiAgdGV4dCxcbiAgcGF0Y2hJbm5lcixcbiAgcGF0Y2hPdXRlcixcbiAgY3VycmVudEVsZW1lbnQsXG4gIGN1cnJlbnRQb2ludGVyLFxuICBza2lwLFxuICBza2lwTm9kZVxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUgVGhlIEluY3JlbWVudGFsIERPTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBjb25zdCAqL1xuY29uc3Qgc3ltYm9scyA9IHtcbiAgZGVmYXVsdDogJ19fZGVmYXVsdCdcbn07XG5cbi8qKiAqL1xuZXhwb3J0IHtcbiAgc3ltYm9sc1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUgVGhlIEluY3JlbWVudGFsIERPTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgZ2V0RGF0YSB9IGZyb20gJy4vbm9kZV9kYXRhJztcbmltcG9ydCB7IHN5bWJvbHMgfSBmcm9tICcuL3N5bWJvbHMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlTWFwLFxuICBoYXNcbn0gZnJvbSAnLi91dGlsJztcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBUaGUgbmFtZXNwYWNlIHRvIHVzZSBmb3IgdGhlIGF0dHJpYnV0ZS5cbiAqL1xuY29uc3QgZ2V0TmFtZXNwYWNlID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAobmFtZS5sYXN0SW5kZXhPZigneG1sOicsIDApID09PSAwKSB7XG4gICAgcmV0dXJuICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnO1xuICB9XG5cbiAgaWYgKG5hbWUubGFzdEluZGV4T2YoJ3hsaW5rOicsIDApID09PSAwKSB7XG4gICAgcmV0dXJuICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcbiAgfVxufTtcblxuXG4vKipcbiAqIEFwcGxpZXMgYW4gYXR0cmlidXRlIG9yIHByb3BlcnR5IHRvIGEgZ2l2ZW4gRWxlbWVudC4gSWYgdGhlIHZhbHVlIGlzIG51bGxcbiAqIG9yIHVuZGVmaW5lZCwgaXQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBFbGVtZW50LiBPdGhlcndpc2UsIHRoZSB2YWx1ZSBpcyBzZXRcbiAqIGFzIGFuIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYXR0cmlidXRlJ3MgbmFtZS5cbiAqIEBwYXJhbSB7Pyhib29sZWFufG51bWJlcnxzdHJpbmcpPX0gdmFsdWUgVGhlIGF0dHJpYnV0ZSdzIHZhbHVlLlxuICovXG5jb25zdCBhcHBseUF0dHIgPSBmdW5jdGlvbihlbCwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYXR0ck5TID0gZ2V0TmFtZXNwYWNlKG5hbWUpO1xuICAgIGlmIChhdHRyTlMpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKGF0dHJOUywgbmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBBcHBsaWVzIGEgcHJvcGVydHkgdG8gYSBnaXZlbiBFbGVtZW50LlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBwcm9wZXJ0eSdzIG5hbWUuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwcm9wZXJ0eSdzIHZhbHVlLlxuICovXG5jb25zdCBhcHBseVByb3AgPSBmdW5jdGlvbihlbCwgbmFtZSwgdmFsdWUpIHtcbiAgZWxbbmFtZV0gPSB2YWx1ZTtcbn07XG5cblxuLyoqXG4gKiBBcHBsaWVzIGEgdmFsdWUgdG8gYSBzdHlsZSBkZWNsYXJhdGlvbi4gU3VwcG9ydHMgQ1NTIGN1c3RvbSBwcm9wZXJ0aWVzIGJ5XG4gKiBzZXR0aW5nIHByb3BlcnRpZXMgY29udGFpbmluZyBhIGRhc2ggdXNpbmcgQ1NTU3R5bGVEZWNsYXJhdGlvbi5zZXRQcm9wZXJ0eS5cbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVcbiAqIEBwYXJhbSB7IXN0cmluZ30gcHJvcFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5jb25zdCBzZXRTdHlsZVZhbHVlID0gZnVuY3Rpb24oc3R5bGUsIHByb3AsIHZhbHVlKSB7XG4gIGlmIChwcm9wLmluZGV4T2YoJy0nKSA+PSAwKSB7XG4gICAgc3R5bGUuc2V0UHJvcGVydHkocHJvcCwgLyoqIEB0eXBlIHtzdHJpbmd9ICovKHZhbHVlKSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEFwcGxpZXMgYSBzdHlsZSB0byBhbiBFbGVtZW50LiBObyB2ZW5kb3IgcHJlZml4IGV4cGFuc2lvbiBpcyBkb25lIGZvclxuICogcHJvcGVydHkgbmFtZXMvdmFsdWVzLlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBhdHRyaWJ1dGUncyBuYW1lLlxuICogQHBhcmFtIHsqfSBzdHlsZSBUaGUgc3R5bGUgdG8gc2V0LiBFaXRoZXIgYSBzdHJpbmcgb2YgY3NzIG9yIGFuIG9iamVjdFxuICogICAgIGNvbnRhaW5pbmcgcHJvcGVydHktdmFsdWUgcGFpcnMuXG4gKi9cbmNvbnN0IGFwcGx5U3R5bGUgPSBmdW5jdGlvbihlbCwgbmFtZSwgc3R5bGUpIHtcbiAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICBlbC5zdHlsZS5jc3NUZXh0ID0gc3R5bGU7XG4gIH0gZWxzZSB7XG4gICAgZWwuc3R5bGUuY3NzVGV4dCA9ICcnO1xuICAgIGNvbnN0IGVsU3R5bGUgPSBlbC5zdHlsZTtcbiAgICBjb25zdCBvYmogPSAvKiogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLHN0cmluZz59ICovKHN0eWxlKTtcblxuICAgIGZvciAoY29uc3QgcHJvcCBpbiBvYmopIHtcbiAgICAgIGlmIChoYXMob2JqLCBwcm9wKSkge1xuICAgICAgICBzZXRTdHlsZVZhbHVlKGVsU3R5bGUsIHByb3AsIG9ialtwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogVXBkYXRlcyBhIHNpbmdsZSBhdHRyaWJ1dGUgb24gYW4gRWxlbWVudC5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYXR0cmlidXRlJ3MgbmFtZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGF0dHJpYnV0ZSdzIHZhbHVlLiBJZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IG9yXG4gKiAgICAgZnVuY3Rpb24gaXQgaXMgc2V0IG9uIHRoZSBFbGVtZW50LCBvdGhlcndpc2UsIGl0IGlzIHNldCBhcyBhbiBIVE1MXG4gKiAgICAgYXR0cmlidXRlLlxuICovXG5jb25zdCBhcHBseUF0dHJpYnV0ZVR5cGVkID0gZnVuY3Rpb24oZWwsIG5hbWUsIHZhbHVlKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgaWYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhcHBseVByb3AoZWwsIG5hbWUsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBhcHBseUF0dHIoZWwsIG5hbWUsIC8qKiBAdHlwZSB7Pyhib29sZWFufG51bWJlcnxzdHJpbmcpfSAqLyh2YWx1ZSkpO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ2FsbHMgdGhlIGFwcHJvcHJpYXRlIGF0dHJpYnV0ZSBtdXRhdG9yIGZvciB0aGlzIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYXR0cmlidXRlJ3MgbmFtZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGF0dHJpYnV0ZSdzIHZhbHVlLlxuICovXG5jb25zdCB1cGRhdGVBdHRyaWJ1dGUgPSBmdW5jdGlvbihlbCwgbmFtZSwgdmFsdWUpIHtcbiAgY29uc3QgZGF0YSA9IGdldERhdGEoZWwpO1xuICBjb25zdCBhdHRycyA9IGRhdGEuYXR0cnM7XG5cbiAgaWYgKGF0dHJzW25hbWVdID09PSB2YWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG11dGF0b3IgPSBhdHRyaWJ1dGVzW25hbWVdIHx8IGF0dHJpYnV0ZXNbc3ltYm9scy5kZWZhdWx0XTtcbiAgbXV0YXRvcihlbCwgbmFtZSwgdmFsdWUpO1xuXG4gIGF0dHJzW25hbWVdID0gdmFsdWU7XG59O1xuXG5cbi8qKlxuICogQSBwdWJsaWNseSBtdXRhYmxlIG9iamVjdCB0byBwcm92aWRlIGN1c3RvbSBtdXRhdG9ycyBmb3IgYXR0cmlidXRlcy5cbiAqIEBjb25zdCB7IU9iamVjdDxzdHJpbmcsIGZ1bmN0aW9uKCFFbGVtZW50LCBzdHJpbmcsICopPn1cbiAqL1xuY29uc3QgYXR0cmlidXRlcyA9IGNyZWF0ZU1hcCgpO1xuXG4vLyBTcGVjaWFsIGdlbmVyaWMgbXV0YXRvciB0aGF0J3MgY2FsbGVkIGZvciBhbnkgYXR0cmlidXRlIHRoYXQgZG9lcyBub3Rcbi8vIGhhdmUgYSBzcGVjaWZpYyBtdXRhdG9yLlxuYXR0cmlidXRlc1tzeW1ib2xzLmRlZmF1bHRdID0gYXBwbHlBdHRyaWJ1dGVUeXBlZDtcblxuYXR0cmlidXRlc1snc3R5bGUnXSA9IGFwcGx5U3R5bGU7XG5cblxuLyoqICovXG5leHBvcnQge1xuICB1cGRhdGVBdHRyaWJ1dGUsXG4gIGFwcGx5UHJvcCxcbiAgYXBwbHlBdHRyLFxuICBhdHRyaWJ1dGVzXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSBUaGUgSW5jcmVtZW50YWwgRE9NIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICBlbGVtZW50T3BlbiBhcyBjb3JlRWxlbWVudE9wZW4sXG4gIGVsZW1lbnRDbG9zZSBhcyBjb3JlRWxlbWVudENsb3NlLFxuICB0ZXh0IGFzIGNvcmVUZXh0XG59IGZyb20gJy4vY29yZSc7XG5pbXBvcnQgeyB1cGRhdGVBdHRyaWJ1dGUgfSBmcm9tICcuL2F0dHJpYnV0ZXMnO1xuaW1wb3J0IHsgZ2V0RGF0YSB9IGZyb20gJy4vbm9kZV9kYXRhJztcbmltcG9ydCB7XG4gIGFzc2VydE5vdEluQXR0cmlidXRlcyxcbiAgYXNzZXJ0Tm90SW5Ta2lwLFxuICBhc3NlcnRJbkF0dHJpYnV0ZXMsXG4gIGFzc2VydENsb3NlTWF0Y2hlc09wZW5UYWcsXG4gIHNldEluQXR0cmlidXRlc1xufSBmcm9tICcuL2Fzc2VydGlvbnMnO1xuXG5cbi8qKlxuICogVGhlIG9mZnNldCBpbiB0aGUgdmlydHVhbCBlbGVtZW50IGRlY2xhcmF0aW9uIHdoZXJlIHRoZSBhdHRyaWJ1dGVzIGFyZVxuICogc3BlY2lmaWVkLlxuICogQGNvbnN0XG4gKi9cbmNvbnN0IEFUVFJJQlVURVNfT0ZGU0VUID0gMztcblxuXG4vKipcbiAqIEJ1aWxkcyBhbiBhcnJheSBvZiBhcmd1bWVudHMgZm9yIHVzZSB3aXRoIGVsZW1lbnRPcGVuU3RhcnQsIGF0dHIgYW5kXG4gKiBlbGVtZW50T3BlbkVuZC5cbiAqIEBjb25zdCB7QXJyYXk8Kj59XG4gKi9cbmNvbnN0IGFyZ3NCdWlsZGVyID0gW107XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBlbGVtZW50J3MgdGFnLlxuICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IFRoZSBrZXkgdXNlZCB0byBpZGVudGlmeSB0aGlzIGVsZW1lbnQuIFRoaXMgY2FuIGJlIGFuXG4gKiAgICAgZW1wdHkgc3RyaW5nLCBidXQgcGVyZm9ybWFuY2UgbWF5IGJlIGJldHRlciBpZiBhIHVuaXF1ZSB2YWx1ZSBpcyB1c2VkXG4gKiAgICAgd2hlbiBpdGVyYXRpbmcgb3ZlciBhbiBhcnJheSBvZiBpdGVtcy5cbiAqIEBwYXJhbSB7P0FycmF5PCo+PX0gc3RhdGljcyBBbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBvZiB0aGVcbiAqICAgICBzdGF0aWMgYXR0cmlidXRlcyBmb3IgdGhlIEVsZW1lbnQuIFRoZXNlIHdpbGwgb25seSBiZSBzZXQgb25jZSB3aGVuIHRoZVxuICogICAgIEVsZW1lbnQgaXMgY3JlYXRlZC5cbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MsIEF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzIG9mIHRoZSBkeW5hbWljIGF0dHJpYnV0ZXNcbiAqICAgICBmb3IgdGhlIEVsZW1lbnQuXG4gKiBAcmV0dXJuIHshRWxlbWVudH0gVGhlIGNvcnJlc3BvbmRpbmcgRWxlbWVudC5cbiAqL1xuY29uc3QgZWxlbWVudE9wZW4gPSBmdW5jdGlvbih0YWcsIGtleSwgc3RhdGljcywgdmFyX2FyZ3MpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnROb3RJbkF0dHJpYnV0ZXMoJ2VsZW1lbnRPcGVuJyk7XG4gICAgYXNzZXJ0Tm90SW5Ta2lwKCdlbGVtZW50T3BlbicpO1xuICB9XG5cbiAgY29uc3Qgbm9kZSA9IGNvcmVFbGVtZW50T3Blbih0YWcsIGtleSk7XG4gIGNvbnN0IGRhdGEgPSBnZXREYXRhKG5vZGUpO1xuXG4gIGlmICghZGF0YS5zdGF0aWNzQXBwbGllZCkge1xuICAgIGlmIChzdGF0aWNzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRpY3MubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyhzdGF0aWNzW2ldKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdGF0aWNzW2kgKyAxXTtcbiAgICAgICAgdXBkYXRlQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRG93biB0aGUgcm9hZCwgd2UgbWF5IHdhbnQgdG8ga2VlcCB0cmFjayBvZiB0aGUgc3RhdGljcyBhcnJheSB0byB1c2UgaXRcbiAgICAvLyBhcyBhbiBhZGRpdGlvbmFsIHNpZ25hbCBhYm91dCB3aGV0aGVyIGEgbm9kZSBtYXRjaGVzIG9yIG5vdC4gRm9yIG5vdyxcbiAgICAvLyBqdXN0IHVzZSBhIG1hcmtlciBzbyB0aGF0IHdlIGRvIG5vdCByZWFwcGx5IHN0YXRpY3MuXG4gICAgZGF0YS5zdGF0aWNzQXBwbGllZCA9IHRydWU7XG4gIH1cblxuICAvKlxuICAgKiBDaGVja3MgdG8gc2VlIGlmIG9uZSBvciBtb3JlIGF0dHJpYnV0ZXMgaGF2ZSBjaGFuZ2VkIGZvciBhIGdpdmVuIEVsZW1lbnQuXG4gICAqIFdoZW4gbm8gYXR0cmlidXRlcyBoYXZlIGNoYW5nZWQsIHRoaXMgaXMgbXVjaCBmYXN0ZXIgdGhhbiBjaGVja2luZyBlYWNoXG4gICAqIGluZGl2aWR1YWwgYXJndW1lbnQuIFdoZW4gYXR0cmlidXRlcyBoYXZlIGNoYW5nZWQsIHRoZSBvdmVyaGVhZCBvZiB0aGlzIGlzXG4gICAqIG1pbmltYWwuXG4gICAqL1xuICBjb25zdCBhdHRyc0FyciA9IGRhdGEuYXR0cnNBcnI7XG4gIGNvbnN0IG5ld0F0dHJzID0gZGF0YS5uZXdBdHRycztcbiAgY29uc3QgaXNOZXcgPSAhYXR0cnNBcnIubGVuZ3RoO1xuICBsZXQgaSA9IEFUVFJJQlVURVNfT0ZGU0VUO1xuICBsZXQgaiA9IDA7XG5cbiAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICs9IDIsIGogKz0gMikge1xuICAgIGNvbnN0IGF0dHIgPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBhdHRyc0FycltqXSA9IGF0dHI7XG4gICAgICBuZXdBdHRyc1thdHRyXSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKGF0dHJzQXJyW2pdICE9PSBhdHRyKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgaWYgKGlzTmV3IHx8IGF0dHJzQXJyW2ogKyAxXSAhPT0gdmFsdWUpIHtcbiAgICAgIGF0dHJzQXJyW2ogKyAxXSA9IHZhbHVlO1xuICAgICAgdXBkYXRlQXR0cmlidXRlKG5vZGUsIGF0dHIsIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaSA8IGFyZ3VtZW50cy5sZW5ndGggfHwgaiA8IGF0dHJzQXJyLmxlbmd0aCkge1xuICAgIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPSAxLCBqICs9IDEpIHtcbiAgICAgIGF0dHJzQXJyW2pdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGlmIChqIDwgYXR0cnNBcnIubGVuZ3RoKSB7XG4gICAgICBhdHRyc0Fyci5sZW5ndGggPSBqO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQWN0dWFsbHkgcGVyZm9ybSB0aGUgYXR0cmlidXRlIHVwZGF0ZS5cbiAgICAgKi9cbiAgICBmb3IgKGkgPSAwOyBpIDwgYXR0cnNBcnIubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSAvKiogQHR5cGUge3N0cmluZ30gKi8oYXR0cnNBcnJbaV0pO1xuICAgICAgY29uc3QgdmFsdWUgPSBhdHRyc0FycltpICsgMV07XG4gICAgICBuZXdBdHRyc1tuYW1lXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgYXR0ciBpbiBuZXdBdHRycykge1xuICAgICAgdXBkYXRlQXR0cmlidXRlKG5vZGUsIGF0dHIsIG5ld0F0dHJzW2F0dHJdKTtcbiAgICAgIG5ld0F0dHJzW2F0dHJdID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlO1xufTtcblxuXG4vKipcbiAqIERlY2xhcmVzIGEgdmlydHVhbCBFbGVtZW50IGF0IHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIHRoZSBkb2N1bWVudC4gVGhpc1xuICogY29ycmVzcG9uZHMgdG8gYW4gb3BlbmluZyB0YWcgYW5kIGEgZWxlbWVudENsb3NlIHRhZyBpcyByZXF1aXJlZC4gVGhpcyBpc1xuICogbGlrZSBlbGVtZW50T3BlbiwgYnV0IHRoZSBhdHRyaWJ1dGVzIGFyZSBkZWZpbmVkIHVzaW5nIHRoZSBhdHRyIGZ1bmN0aW9uXG4gKiByYXRoZXIgdGhhbiBiZWluZyBwYXNzZWQgYXMgYXJndW1lbnRzLiBNdXN0IGJlIGZvbGxsb3dlZCBieSAwIG9yIG1vcmUgY2FsbHNcbiAqIHRvIGF0dHIsIHRoZW4gYSBjYWxsIHRvIGVsZW1lbnRPcGVuRW5kLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgZWxlbWVudCdzIHRhZy5cbiAqIEBwYXJhbSB7P3N0cmluZz19IGtleSBUaGUga2V5IHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBlbGVtZW50LiBUaGlzIGNhbiBiZSBhblxuICogICAgIGVtcHR5IHN0cmluZywgYnV0IHBlcmZvcm1hbmNlIG1heSBiZSBiZXR0ZXIgaWYgYSB1bmlxdWUgdmFsdWUgaXMgdXNlZFxuICogICAgIHdoZW4gaXRlcmF0aW5nIG92ZXIgYW4gYXJyYXkgb2YgaXRlbXMuXG4gKiBAcGFyYW0gez9BcnJheTwqPj19IHN0YXRpY3MgQW4gYXJyYXkgb2YgYXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMgb2YgdGhlXG4gKiAgICAgc3RhdGljIGF0dHJpYnV0ZXMgZm9yIHRoZSBFbGVtZW50LiBUaGVzZSB3aWxsIG9ubHkgYmUgc2V0IG9uY2Ugd2hlbiB0aGVcbiAqICAgICBFbGVtZW50IGlzIGNyZWF0ZWQuXG4gKi9cbmNvbnN0IGVsZW1lbnRPcGVuU3RhcnQgPSBmdW5jdGlvbih0YWcsIGtleSwgc3RhdGljcykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE5vdEluQXR0cmlidXRlcygnZWxlbWVudE9wZW5TdGFydCcpO1xuICAgIHNldEluQXR0cmlidXRlcyh0cnVlKTtcbiAgfVxuXG4gIGFyZ3NCdWlsZGVyWzBdID0gdGFnO1xuICBhcmdzQnVpbGRlclsxXSA9IGtleTtcbiAgYXJnc0J1aWxkZXJbMl0gPSBzdGF0aWNzO1xufTtcblxuXG4vKioqXG4gKiBEZWZpbmVzIGEgdmlydHVhbCBhdHRyaWJ1dGUgYXQgdGhpcyBwb2ludCBvZiB0aGUgRE9NLiBUaGlzIGlzIG9ubHkgdmFsaWRcbiAqIHdoZW4gY2FsbGVkIGJldHdlZW4gZWxlbWVudE9wZW5TdGFydCBhbmQgZWxlbWVudE9wZW5FbmQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuY29uc3QgYXR0ciA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0SW5BdHRyaWJ1dGVzKCdhdHRyJyk7XG4gIH1cblxuICBhcmdzQnVpbGRlci5wdXNoKG5hbWUpO1xuICBhcmdzQnVpbGRlci5wdXNoKHZhbHVlKTtcbn07XG5cblxuLyoqXG4gKiBDbG9zZXMgYW4gb3BlbiB0YWcgc3RhcnRlZCB3aXRoIGVsZW1lbnRPcGVuU3RhcnQuXG4gKiBAcmV0dXJuIHshRWxlbWVudH0gVGhlIGNvcnJlc3BvbmRpbmcgRWxlbWVudC5cbiAqL1xuY29uc3QgZWxlbWVudE9wZW5FbmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRJbkF0dHJpYnV0ZXMoJ2VsZW1lbnRPcGVuRW5kJyk7XG4gICAgc2V0SW5BdHRyaWJ1dGVzKGZhbHNlKTtcbiAgfVxuXG4gIGNvbnN0IG5vZGUgPSBlbGVtZW50T3Blbi5hcHBseShudWxsLCBhcmdzQnVpbGRlcik7XG4gIGFyZ3NCdWlsZGVyLmxlbmd0aCA9IDA7XG4gIHJldHVybiBub2RlO1xufTtcblxuXG4vKipcbiAqIENsb3NlcyBhbiBvcGVuIHZpcnR1YWwgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBlbGVtZW50J3MgdGFnLlxuICogQHJldHVybiB7IUVsZW1lbnR9IFRoZSBjb3JyZXNwb25kaW5nIEVsZW1lbnQuXG4gKi9cbmNvbnN0IGVsZW1lbnRDbG9zZSA9IGZ1bmN0aW9uKHRhZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE5vdEluQXR0cmlidXRlcygnZWxlbWVudENsb3NlJyk7XG4gIH1cblxuICBjb25zdCBub2RlID0gY29yZUVsZW1lbnRDbG9zZSgpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0Q2xvc2VNYXRjaGVzT3BlblRhZyhnZXREYXRhKG5vZGUpLm5vZGVOYW1lLCB0YWcpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5cbi8qKlxuICogRGVjbGFyZXMgYSB2aXJ0dWFsIEVsZW1lbnQgYXQgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gdGhlIGRvY3VtZW50IHRoYXQgaGFzXG4gKiBubyBjaGlsZHJlbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGVsZW1lbnQncyB0YWcuXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBrZXkgVGhlIGtleSB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZWxlbWVudC4gVGhpcyBjYW4gYmUgYW5cbiAqICAgICBlbXB0eSBzdHJpbmcsIGJ1dCBwZXJmb3JtYW5jZSBtYXkgYmUgYmV0dGVyIGlmIGEgdW5pcXVlIHZhbHVlIGlzIHVzZWRcbiAqICAgICB3aGVuIGl0ZXJhdGluZyBvdmVyIGFuIGFycmF5IG9mIGl0ZW1zLlxuICogQHBhcmFtIHs/QXJyYXk8Kj49fSBzdGF0aWNzIEFuIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzIG9mIHRoZVxuICogICAgIHN0YXRpYyBhdHRyaWJ1dGVzIGZvciB0aGUgRWxlbWVudC4gVGhlc2Ugd2lsbCBvbmx5IGJlIHNldCBvbmNlIHdoZW4gdGhlXG4gKiAgICAgRWxlbWVudCBpcyBjcmVhdGVkLlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBBdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBvZiB0aGUgZHluYW1pYyBhdHRyaWJ1dGVzXG4gKiAgICAgZm9yIHRoZSBFbGVtZW50LlxuICogQHJldHVybiB7IUVsZW1lbnR9IFRoZSBjb3JyZXNwb25kaW5nIEVsZW1lbnQuXG4gKi9cbmNvbnN0IGVsZW1lbnRWb2lkID0gZnVuY3Rpb24odGFnLCBrZXksIHN0YXRpY3MsIHZhcl9hcmdzKSB7XG4gIGVsZW1lbnRPcGVuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIHJldHVybiBlbGVtZW50Q2xvc2UodGFnKTtcbn07XG5cblxuLyoqXG4gKiBEZWNsYXJlcyBhIHZpcnR1YWwgVGV4dCBhdCB0aGlzIHBvaW50IGluIHRoZSBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8Ym9vbGVhbn0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBUZXh0LlxuICogQHBhcmFtIHsuLi4oZnVuY3Rpb24oKHN0cmluZ3xudW1iZXJ8Ym9vbGVhbikpOnN0cmluZyl9IHZhcl9hcmdzXG4gKiAgICAgRnVuY3Rpb25zIHRvIGZvcm1hdCB0aGUgdmFsdWUgd2hpY2ggYXJlIGNhbGxlZCBvbmx5IHdoZW4gdGhlIHZhbHVlIGhhc1xuICogICAgIGNoYW5nZWQuXG4gKiBAcmV0dXJuIHshVGV4dH0gVGhlIGNvcnJlc3BvbmRpbmcgdGV4dCBub2RlLlxuICovXG5jb25zdCB0ZXh0ID0gZnVuY3Rpb24odmFsdWUsIHZhcl9hcmdzKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0Tm90SW5BdHRyaWJ1dGVzKCd0ZXh0Jyk7XG4gICAgYXNzZXJ0Tm90SW5Ta2lwKCd0ZXh0Jyk7XG4gIH1cblxuICBjb25zdCBub2RlID0gY29yZVRleHQoKTtcbiAgY29uc3QgZGF0YSA9IGdldERhdGEobm9kZSk7XG5cbiAgaWYgKGRhdGEudGV4dCAhPT0gdmFsdWUpIHtcbiAgICBkYXRhLnRleHQgPSAvKiogQHR5cGUge3N0cmluZ30gKi8odmFsdWUpO1xuXG4gICAgbGV0IGZvcm1hdHRlZCA9IHZhbHVlO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAvKlxuICAgICAgICogQ2FsbCB0aGUgZm9ybWF0dGVyIGZ1bmN0aW9uIGRpcmVjdGx5IHRvIHByZXZlbnQgbGVha2luZyBhcmd1bWVudHMuXG4gICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2luY3JlbWVudGFsLWRvbS9wdWxsLzIwNCNpc3N1ZWNvbW1lbnQtMTc4MjIzNTc0XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGZuID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9ybWF0dGVkID0gZm4oZm9ybWF0dGVkKTtcbiAgICB9XG5cbiAgICBub2RlLmRhdGEgPSBmb3JtYXR0ZWQ7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG5cblxuLyoqICovXG5leHBvcnQge1xuICBlbGVtZW50T3BlblN0YXJ0LFxuICBlbGVtZW50T3BlbkVuZCxcbiAgZWxlbWVudE9wZW4sXG4gIGVsZW1lbnRWb2lkLFxuICBlbGVtZW50Q2xvc2UsXG4gIHRleHQsXG4gIGF0dHJcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1IFRoZSBJbmNyZW1lbnRhbCBET00gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCB7XG4gIHBhdGNoSW5uZXIgYXMgcGF0Y2gsXG4gIHBhdGNoSW5uZXIsXG4gIHBhdGNoT3V0ZXIsXG4gIGN1cnJlbnRFbGVtZW50LFxuICBjdXJyZW50UG9pbnRlcixcbiAgc2tpcCxcbiAgc2tpcE5vZGVcbn0gZnJvbSAnLi9zcmMvY29yZSc7XG5leHBvcnQge1xuICBlbGVtZW50Vm9pZCxcbiAgZWxlbWVudE9wZW5TdGFydCxcbiAgZWxlbWVudE9wZW5FbmQsXG4gIGVsZW1lbnRPcGVuLFxuICBlbGVtZW50Q2xvc2UsXG4gIHRleHQsXG4gIGF0dHJcbn0gZnJvbSAnLi9zcmMvdmlydHVhbF9lbGVtZW50cyc7XG5leHBvcnQgeyBzeW1ib2xzIH0gZnJvbSAnLi9zcmMvc3ltYm9scyc7XG5leHBvcnQge1xuICBhdHRyaWJ1dGVzLFxuICBhcHBseUF0dHIsXG4gIGFwcGx5UHJvcFxufSBmcm9tICcuL3NyYy9hdHRyaWJ1dGVzJztcbmV4cG9ydCB7IG5vdGlmaWNhdGlvbnMgfSBmcm9tICcuL3NyYy9ub3RpZmljYXRpb25zJztcbmV4cG9ydCB7IGltcG9ydE5vZGUgfSBmcm9tICcuL3NyYy9ub2RlX2RhdGEnO1xuIiwiLyoqXG4gKiBETkFcbiAqIChjKSAyMDE1LTIwMTYgQ2hpYWxhYiAoaHR0cDovL3d3dy5jaGlhbGFiLmNvbSkgPGRldkBjaGlhbGFiLmlvPlxuICogaHR0cDovL2RuYS5jaGlhbGFiLmlvXG4gKlxuICogSnVzdCBhbm90aGVyIGNvbXBvbmVudHMgcGF0dGVybi5cbiAqIFVzZSB3aXRoIEN1c3RvbSBFbGVtZW50cyBzcGVjcy5cbiAqL1xuaW1wb3J0IHsgbWl4LCBwcm9wLCBzaGltLCBET00sIE1JWElOUyB9IGZyb20gJy4vc3JjL2NvcmUuanMnO1xuaW1wb3J0IHsgcmVnaXN0cnkgfSBmcm9tICcuL3NyYy9saWIvcmVnaXN0cnkuanMnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgRE5BXG4gKi9cbmV4cG9ydCB7IG1peCwgcHJvcCwgc2hpbSwgRE9NLCBNSVhJTlMgfTtcbmV4cG9ydCB7IHJlZ2lzdHJ5IH07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBuZXcgY29tcG9uZW50LlxuICogQG1ldGhvZCBkZWZpbmVcbiAqIEBtZW1iZXJvZiEgRE5BLlxuICogQHN0YXRpY1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBpZCBvZiB0aGUgY29tcG9uZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ3RyIFRoZSBjb21wb25lbnQgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIE9wdGlvbmFsIGNvbXBvbmVudCBjb25maWd1cmF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lKHRhZ05hbWUsIENvbXBvbmVudCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHJlZ2lzdHJ5LmRlZmluZSh0YWdOYW1lLCBDb21wb25lbnQsIGNvbmZpZyk7XG59XG4vKipcbiAqIENyZWF0ZSBhbmQgYXBwZW5kIGEgbmV3IGNvbXBvbmVudCBpbnN0YW5jZS5cbiAqIEBtZXRob2QgcmVuZGVyXG4gKiBAbWVtYmVyb2YhIEROQS5cbiAqIEBzdGF0aWNcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIFRoZSBwYXJlbnQgbm9kZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IENvbXBvbmVudCBUaGUgY29tcG9uZW50IGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIE9wdGlvbmFsIHNldCBvZiBwcm9wZXJ0aWVzIHRvIHNldCB0byB0aGUgY29tcG9uZW50LlxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9IFRoZSBuZXcgY29tcG9uZW50IGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKG5vZGUsIENvbXBvbmVudCwgcHJvcHMpIHtcbiAgICBsZXQgZWxlbWVudCA9IG5ldyBDb21wb25lbnQoKTtcbiAgICBmb3IgKGxldCBrIGluIHByb3BzKSB7XG4gICAgICAgIGVsZW1lbnRba10gPSBwcm9wc1trXTtcbiAgICB9XG4gICAgRE9NLmFwcGVuZENoaWxkKG5vZGUsIGVsZW1lbnQpO1xuICAgIHJldHVybiBlbGVtZW50O1xufVxuXG4vKipcbiAqIFNpbXBsZSBDdXN0b20gQ29tcG9uZW50IHdpdGggc29tZSBiZWhhdmlvcnMuXG4gKiBAY2xhc3MgQmFzZUNvbXBvbmVudFxuICogQGV4dGVuZHMgSFRNTEVsZW1lbnRcbiAqIEBtZW1iZXJvZiBETkEuXG4gKiBAc3RhdGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiAvLyBteS1jb21wb25lbnQuanNcbiAqIGltcG9ydCB7IEJhc2VDb21wb25lbnQgfSBmcm9tICdAZG5hanMvY29yZSc7XG4gKiBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAqICAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gKiAgICAgcmV0dXJuIFsnLi4uJywgJy4uLiddO1xuICogICB9XG4gKiAgIGdldCBjc3MoKSB7XG4gKiAgICAgcmV0dXJuICcuLi4nO1xuICogICB9XG4gKiAgIGdldCBldmVudHMoKSB7XG4gKiAgICAgcmV0dXJuIHtcbiAqICAgICAgICcuLi4nOiAnLi4uJ1xuICogICAgIH07XG4gKiAgIH1cbiAqICAgZ2V0IHRlbXBsYXRlKCkge1xuICogICAgIHJldHVybiAnLi4uJztcbiAqICAgfVxuICogICBnZXQgcHJvcGVydGllcygpIHtcbiAqICAgICByZXR1cm4geyAuLi4gfTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlQ29tcG9uZW50IGV4dGVuZHMgbWl4KFxuICAgIHNoaW0oc2VsZi5IVE1MRWxlbWVudClcbikud2l0aChcbiAgICBNSVhJTlMuQ29tcG9uZW50TWl4aW4sXG4gICAgTUlYSU5TLlByb3BlcnRpZXNNaXhpbixcbiAgICBNSVhJTlMuU3R5bGVNaXhpbixcbiAgICBNSVhJTlMuRXZlbnRzTWl4aW4sXG4gICAgTUlYSU5TLlRlbXBsYXRlTWl4aW5cbikge31cbiJdLCJuYW1lcyI6WyJpc0Z1bmN0aW9uIiwib2JqIiwiaXNTdHJpbmciLCJpc09iamVjdCIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImlzVW5kZWZpbmVkIiwiaXNBcnJheSIsIkFycmF5IiwicmVnaXN0cnkiLCJuYW1lIiwiQ3RyIiwiY29uZmlnIiwiY29tcG9uZW50cyIsInRvTG93ZXJDYXNlIiwiayIsImRlc2MiLCJnZXREZXNjcmlwdG9yIiwiQ09NUE9ORU5UX1NZTUJPTCIsIkNPTk5FQ1RFRCIsIkRJU0NPTk5FQ1RFRCIsIlVQREFURUQiLCJnZXRDb21wb25lbnQiLCJlbGVtZW50IiwiZnVsbCIsIm5vZGUiLCJub2RlVHlwZSIsIk5vZGUiLCJFTEVNRU5UX05PREUiLCJnZXRBdHRyaWJ1dGUiLCJ0YWdOYW1lIiwiZ2V0IiwiaXNDb21wb25lbnQiLCJjb25uZWN0IiwiZGlzY29ubmVjdCIsInVwZGF0ZSIsIm9sZFZhbHVlIiwibmV3VmFsdWUiLCJiaW5kIiwiX19wcm90b19fIiwiZGVmaW5lUHJvcGVydHkiLCJjcmVhdGVFbGVtZW50IiwiaXMiLCJhcHBlbmRDaGlsZCIsInBhcmVudCIsInBhcmVudE5vZGUiLCJsYXN0RWxlbWVudENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJpbnNlcnRCZWZvcmUiLCJyZWZOb2RlIiwibmV4dFNpYmxpbmciLCJyZXBsYWNlQ2hpbGQiLCJzZXRBdHRyaWJ1dGUiLCJ2YWx1ZSIsImF0dHJzIiwiY29uc3RydWN0b3IiLCJvYnNlcnZlZEF0dHJpYnV0ZXMiLCJpbmRleE9mIiwicmVtb3ZlQXR0cmlidXRlIiwiQ29tcG9uZW50TWl4aW4iLCJTdXBlckNsYXNzIiwiY29ubmVjdGVkQ2FsbGJhY2siLCJkaXNjb25uZWN0ZWRDYWxsYmFjayIsImF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayIsImxvY2FsTmFtZSIsIkN1c3RvbUV2ZW50IiwiZXYiLCJzZWxmIiwiZXgiLCJldmVudCIsInBhcmFtcyIsInVuZGVmaW5lZCIsImV2dCIsImRvY3VtZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0Q3VzdG9tRXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImRldGFpbCIsImRpc3BhdGNoIiwiZXZOYW1lIiwiZGF0YSIsIlR5cGVFcnJvciIsImRpc3BhdGNoRXZlbnQiLCJkZWZpbmUiLCJQcm9wZXJ0eSIsImN0cnMiLCJfIiwidmFsaWRhdG9yIiwiX3NldHRlciIsInZhbCIsImdldHRlckZuIiwic2V0dGVyRm4iLCJ2YWxpZGF0ZVR5cGUiLCJjaGFuZ2VkIiwic2NvcGUiLCJvYnNlcnZlIiwiY2FsbGJhY2siLCJwdXNoIiwidW5vYnNlcnZlIiwiaW8iLCJzcGxpY2UiLCJpIiwibGVuIiwibGVuZ3RoIiwiY2xiIiwiYWNjZXB0cyIsIm5hbWVkIiwiYXR0clJlcXVlc3RlZCIsImF0dHJOYW1lIiwiZGVmYXVsdCIsImluaXRWYWx1ZSIsImRlZmF1bHRWYWx1ZSIsImZyZWV6ZSIsImF0dHJpYnV0ZSIsImV2ZW50TmFtZSIsImdldHRlciIsInNldHRlciIsInZhbGlkYXRlIiwiaW5pdCIsInByb3AiLCJTdHJpbmciLCJCb29sZWFuIiwiTnVtYmVyIiwiZ2V0VmFsdWUiLCJwcm9wZXJ0eSIsImF0dHJWYWwiLCJKU09OIiwicGFyc2UiLCJjb250ZXh0IiwiYXR0ciIsImN1cnJlbnRBdHRyVmFsdWUiLCJQcm9wZXJ0aWVzTWl4aW4iLCJwcm9wcyIsInByb3BlcnRpZXMiLCJyZWR1Y2UiLCJyZXMiLCJwYXJ0aWFsUHJvcHMiLCJvYnNlcnZlZCIsImhhc0F0dHJpYnV0ZSIsIm9sZFZhbCIsIm5ld1ZhbCIsIm9ic2VydmVQcm9wZXJ0eSIsInByb3BOYW1lIiwidW5vYnNlcnZlUHJvcGVydHkiLCJFTEVNX1BST1RPIiwiRWxlbWVudCIsIm1hdGNoZXMiLCJtYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsIm9NYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJTUExJVF9TRUxFQ1RPUiIsIkV2ZW50c01peGluIiwiZXZlbnRzIiwicnVsZSIsIm1hdGNoIiwic2VsZWN0b3IiLCJ0cmltIiwiZGVsZWdhdGUiLCJhZGRFdmVudExpc3RlbmVyIiwidGFyZ2V0IiwidHJpZ2dlciIsInJvb3REb2MiLCJjcmVhdGVTdHlsZSIsImRvYyIsIm93bmVyRG9jdW1lbnQiLCJzdHlsZUVsZW0iLCJ0eXBlIiwiaGVhZCIsImZpcnN0RWxlbWVudENoaWxkIiwiU3R5bGVNaXhpbiIsInVwZGF0ZUNTUyIsImNsYXNzTGlzdCIsImFkZCIsInN0eWxlIiwiY3NzIiwidGV4dENvbnRlbnQiLCJUZW1wbGF0ZU1peGluIiwiYXV0b1JlbmRlciIsInRlbXBsYXRlIiwicmVuZGVyIiwidHBsIiwiaW5uZXJIVE1MIiwidCIsImFyZ3VtZW50cyIsIk1peGluIiwic3VwZXJjbGFzcyIsIndpdGgiLCJhcmdzIiwic2xpY2UiLCJjIiwibWl4aW4iLCJtaXgiLCJzdXBlckNsYXNzIiwiaXNOZXciLCJvdXRlckhUTUwiLCJzaGltIiwiT3JpZ2luYWwiLCJQb2x5ZmlsbGVkIiwiZXh0ZW5kcyIsImNyZWF0ZSIsIkRPTSIsIkRPTV9IRUxQRVJTIiwiTUlYSU5TIiwiaGFzT3duUHJvcGVydHkiLCJCbGFuayIsImhhcyIsIm1hcCIsImNyZWF0ZU1hcCIsIk5vZGVEYXRhIiwibm9kZU5hbWUiLCJrZXkiLCJhdHRyc0FyciIsIm5ld0F0dHJzIiwic3RhdGljc0FwcGxpZWQiLCJrZXlNYXAiLCJrZXlNYXBWYWxpZCIsImZvY3VzZWQiLCJ0ZXh0IiwiaW5pdERhdGEiLCJnZXREYXRhIiwiaW1wb3J0Tm9kZSIsImlzRWxlbWVudCIsImF0dHJpYnV0ZXMiLCJjaGlsZCIsImZpcnN0Q2hpbGQiLCJnZXROYW1lc3BhY2VGb3JUYWciLCJ0YWciLCJuYW1lc3BhY2VVUkkiLCJuYW1lc3BhY2UiLCJlbCIsImNyZWF0ZUVsZW1lbnROUyIsImNyZWF0ZVRleHQiLCJjcmVhdGVUZXh0Tm9kZSIsIm5vdGlmaWNhdGlvbnMiLCJDb250ZXh0IiwiY3JlYXRlZCIsIm5vZGVzQ3JlYXRlZCIsImRlbGV0ZWQiLCJub2Rlc0RlbGV0ZWQiLCJtYXJrQ3JlYXRlZCIsIm1hcmtEZWxldGVkIiwibm90aWZ5Q2hhbmdlcyIsImluQXR0cmlidXRlcyIsImluU2tpcCIsImFzc2VydE5vVW5jbG9zZWRUYWdzIiwib3BlbkVsZW1lbnQiLCJyb290IiwiY3VycmVudEVsZW1lbnQiLCJvcGVuVGFncyIsIkVycm9yIiwiam9pbiIsImFzc2VydE5vdEluQXR0cmlidXRlcyIsImZ1bmN0aW9uTmFtZSIsImFzc2VydE5vdEluU2tpcCIsImFzc2VydEluQXR0cmlidXRlcyIsImFzc2VydFZpcnR1YWxBdHRyaWJ1dGVzQ2xvc2VkIiwiYXNzZXJ0Q2xvc2VNYXRjaGVzT3BlblRhZyIsImFzc2VydE5vQ2hpbGRyZW5EZWNsYXJlZFlldCIsInByZXZpb3VzTm9kZSIsImFzc2VydFBhdGNoRWxlbWVudE5vRXh0cmFzIiwic3RhcnROb2RlIiwiY3VycmVudE5vZGUiLCJleHBlY3RlZE5leHROb2RlIiwiZXhwZWN0ZWRQcmV2Tm9kZSIsIndhc1VwZGF0ZWQiLCJwcmV2aW91c1NpYmxpbmciLCJ3YXNDaGFuZ2VkIiwid2FzUmVtb3ZlZCIsInNldEluQXR0cmlidXRlcyIsInByZXZpb3VzIiwic2V0SW5Ta2lwIiwiaXNEb2N1bWVudFJvb3QiLCJEb2N1bWVudCIsIkRvY3VtZW50RnJhZ21lbnQiLCJnZXRBbmNlc3RyeSIsImFuY2VzdHJ5IiwiY3VyIiwiZ2V0Um9vdCIsInByZXYiLCJnZXRBY3RpdmVFbGVtZW50IiwiYWN0aXZlRWxlbWVudCIsImdldEZvY3VzZWRQYXRoIiwiY29udGFpbnMiLCJtb3ZlQmVmb3JlIiwicmVmZXJlbmNlTm9kZSIsImluc2VydFJlZmVyZW5jZU5vZGUiLCJuZXh0IiwiY3VycmVudFBhcmVudCIsIm1hcmtGb2N1c2VkIiwiZm9jdXNQYXRoIiwicGF0Y2hGYWN0b3J5IiwicnVuIiwiZiIsImZuIiwicHJldkNvbnRleHQiLCJwcmV2RG9jIiwicHJldkN1cnJlbnROb2RlIiwicHJldkN1cnJlbnRQYXJlbnQiLCJwcmV2aW91c0luQXR0cmlidXRlcyIsInByZXZpb3VzSW5Ta2lwIiwicmV0VmFsIiwicGF0Y2hJbm5lciIsIm1hdGNoTm9kZSIsImFsaWduV2l0aERPTSIsInBhcmVudERhdGEiLCJjdXJyZW50Tm9kZURhdGEiLCJrZXlOb2RlIiwiY2xlYXJVbnZpc2l0ZWRET00iLCJsYXN0Q2hpbGQiLCJlbnRlck5vZGUiLCJnZXROZXh0Tm9kZSIsIm5leHROb2RlIiwiZXhpdE5vZGUiLCJlbGVtZW50T3BlbiIsImVsZW1lbnRDbG9zZSIsInNraXAiLCJzeW1ib2xzIiwiZ2V0TmFtZXNwYWNlIiwibGFzdEluZGV4T2YiLCJhcHBseUF0dHIiLCJhdHRyTlMiLCJzZXRBdHRyaWJ1dGVOUyIsImFwcGx5UHJvcCIsInNldFN0eWxlVmFsdWUiLCJzZXRQcm9wZXJ0eSIsImFwcGx5U3R5bGUiLCJjc3NUZXh0IiwiZWxTdHlsZSIsImFwcGx5QXR0cmlidXRlVHlwZWQiLCJ1cGRhdGVBdHRyaWJ1dGUiLCJtdXRhdG9yIiwiQVRUUklCVVRFU19PRkZTRVQiLCJhcmdzQnVpbGRlciIsInN0YXRpY3MiLCJ2YXJfYXJncyIsImNvcmVFbGVtZW50T3BlbiIsImoiLCJlbGVtZW50T3BlblN0YXJ0IiwiZWxlbWVudE9wZW5FbmQiLCJhcHBseSIsImNvcmVFbGVtZW50Q2xvc2UiLCJjb3JlVGV4dCIsImZvcm1hdHRlZCIsIkNvbXBvbmVudCIsIkJhc2VDb21wb25lbnQiLCJIVE1MRWxlbWVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7Ozs7OztBQVNBLEFBQU8sU0FBU0EsVUFBVCxDQUFvQkMsR0FBcEIsRUFBeUI7U0FDckIsT0FBT0EsR0FBUCxLQUFlLFVBQXRCOzs7Ozs7Ozs7OztBQVdKLEFBQU8sU0FBU0MsUUFBVCxDQUFrQkQsR0FBbEIsRUFBdUI7U0FDbkIsT0FBT0EsR0FBUCxLQUFlLFFBQXRCOzs7Ozs7Ozs7OztBQVdKLEFBQU8sU0FBU0UsUUFBVCxDQUFrQkYsR0FBbEIsRUFBdUI7U0FDbkJHLE9BQU9DLFNBQVAsQ0FBaUJDLFFBQWpCLENBQTBCQyxJQUExQixDQUErQk4sR0FBL0IsTUFBd0MsaUJBQS9DOzs7Ozs7Ozs7OztBQVdKLEFBQU8sU0FBU08sV0FBVCxDQUFxQlAsR0FBckIsRUFBMEI7U0FDdEIsT0FBT0EsR0FBUCxLQUFlLFdBQXRCOzs7Ozs7Ozs7OztBQVdKLEFBQU8sU0FBU1EsT0FBVCxDQUFpQlIsR0FBakIsRUFBc0I7U0FDbEJTLE1BQU1ELE9BQU4sQ0FBY1IsR0FBZCxDQUFQOzs7QUN4REo7Ozs7Ozs7O0FBUUEsQUFBTyxJQUFNVSxXQUFXOzs7OztnQkFLUixFQUxROzs7Ozs7O1VBQUEsa0JBWWJDLElBWmEsRUFZUEMsR0FaTyxFQVlXO1lBQWJDLE1BQWEsdUVBQUosRUFBSTs7YUFDdEJDLFVBQUwsQ0FBZ0JILEtBQUtJLFdBQUwsRUFBaEIsSUFBc0M7Z0JBQzlCSixJQUQ4QjtvQkFBQTs7U0FBdEM7S0FiZ0I7Ozs7Ozs7O2lCQUFBLHlCQXlCTkEsSUF6Qk0sRUF5QkE7WUFDWlYsU0FBU1UsSUFBVCxDQUFKLEVBQW9CO21CQUNULEtBQUtHLFVBQUwsQ0FBZ0JILEtBQUtJLFdBQUwsRUFBaEIsQ0FBUDtTQURKLE1BRU8sSUFBSWhCLFdBQVdZLElBQVgsQ0FBSixFQUFzQjtpQkFDcEIsSUFBSUssQ0FBVCxJQUFjLEtBQUtGLFVBQW5CLEVBQStCO29CQUN2QkcsT0FBTyxLQUFLSCxVQUFMLENBQWdCRSxDQUFoQixDQUFYO29CQUNJQyxLQUFLTCxHQUFMLEtBQWFELElBQWpCLEVBQXVCOzJCQUNaTSxJQUFQOzs7O0tBaENJOzs7Ozs7O09BQUEsZUEwQ2hCTixJQTFDZ0IsRUEwQ1Y7WUFDRk0sT0FBTyxLQUFLQyxhQUFMLENBQW1CUCxJQUFuQixDQUFYO1lBQ0lNLElBQUosRUFBVTttQkFDQ0EsS0FBS0wsR0FBWjs7O0NBN0NMOztBQ1ZBLElBQU1PLG1CQUFtQixhQUF6Qjs7QUNJUDs7Ozs7OztBQU9BLElBQU1DLFlBQVksbUJBQWxCOzs7Ozs7OztBQVFBLElBQU1DLGVBQWUsc0JBQXJCOzs7Ozs7OztBQVFBLElBQU1DLFVBQVUsMEJBQWhCOzs7Ozs7Ozs7OztBQVdBLEFBQU8sU0FBU0MsWUFBVCxDQUFzQkMsT0FBdEIsRUFBNkM7UUFBZEMsSUFBYyx1RUFBUCxLQUFPOztRQUM1Q0QsUUFBUUUsSUFBWixFQUFrQjtrQkFDSkYsUUFBUUUsSUFBbEI7O1FBRUFGLFFBQVFHLFFBQVIsS0FBcUJDLEtBQUtDLFlBQTlCLEVBQTRDO2tCQUM5QkwsUUFBUU0sWUFBUixDQUFxQixJQUFyQixLQUE4Qk4sUUFBUU8sT0FBaEQ7O1dBRUdOLE9BQU9mLFNBQVNRLGFBQVQsQ0FBdUJNLE9BQXZCLENBQVAsR0FBeUNkLFNBQVNzQixHQUFULENBQWFSLE9BQWIsQ0FBaEQ7Ozs7Ozs7Ozs7O0FBV0osQUFBTyxTQUFTUyxXQUFULENBQXFCVCxPQUFyQixFQUE4QjtRQUM3QlosTUFBTVcsYUFBYUMsT0FBYixDQUFWO1dBQ09aLE9BQVFZLG1CQUFtQlosR0FBbEM7Ozs7Ozs7Ozs7O0FBV0osQUFBTyxTQUFTc0IsT0FBVCxDQUFpQlYsT0FBakIsRUFBMEI7UUFDekJTLFlBQVlULE9BQVosQ0FBSixFQUEwQjtnQkFDZEosU0FBUixFQUFtQmQsSUFBbkIsQ0FBd0JrQixPQUF4QjtlQUNPLElBQVA7Ozs7Ozs7Ozs7OztBQVlSLEFBQU8sU0FBU1csVUFBVCxDQUFvQlgsT0FBcEIsRUFBNkI7UUFDNUJTLFlBQVlULE9BQVosQ0FBSixFQUEwQjtnQkFDZEgsWUFBUixFQUFzQmYsSUFBdEIsQ0FBMkJrQixPQUEzQjtlQUNPLElBQVA7Ozs7Ozs7Ozs7OztBQVlSLEFBQU8sU0FBU1ksTUFBVCxDQUFnQlosT0FBaEIsRUFBeUJiLElBQXpCLEVBQStCMEIsUUFBL0IsRUFBeUNDLFFBQXpDLEVBQW1EO1FBQ2xETCxZQUFZVCxPQUFaLENBQUosRUFBMEI7Z0JBQ2RGLE9BQVIsRUFBaUJoQixJQUFqQixDQUFzQmtCLE9BQXRCLEVBQStCYixJQUEvQixFQUFxQzBCLFFBQXJDLEVBQStDQyxRQUEvQztlQUNPLElBQVA7Ozs7Ozs7Ozs7Ozs7QUFhUixBQUFPLFNBQVNDLElBQVQsQ0FBY2IsSUFBZCxFQUFvQmQsR0FBcEIsRUFBeUI7UUFDeEIsQ0FBQ2IsV0FBV2EsR0FBWCxDQUFMLEVBQXNCO2NBQ1pXLGFBQWFHLElBQWIsQ0FBTjs7UUFFQTNCLFdBQVdhLEdBQVgsQ0FBSixFQUFxQjthQUNaNEIsU0FBTCxHQUFpQjVCLElBQUlSLFNBQXJCO2VBQ09xQyxjQUFQLENBQXNCZixJQUF0QixFQUE0QixhQUE1QixFQUEyQzttQkFDaENkLEdBRGdDOzBCQUV6QixJQUZ5QjtzQkFHN0I7U0FIZDtZQUtJTixJQUFKLENBQVNvQixJQUFUO2VBQ08sSUFBUDs7V0FFRyxLQUFQOzs7Ozs7Ozs7OztBQVdKLEFBQU8sU0FBU2dCLGFBQVQsQ0FBdUJDLEVBQXZCLEVBQTJCO1FBQzFCL0IsTUFBTVcsYUFBYW9CLEVBQWIsQ0FBVjtRQUNJL0IsR0FBSixFQUFTO2VBQ0UsSUFBSUEsR0FBSixFQUFQOzs7Ozs7Ozs7Ozs7Ozs7QUFlUixBQUFPLFNBQVNnQyxXQUFULENBQXFCQyxNQUFyQixFQUE2QnJCLE9BQTdCLEVBQXNDO1FBQ3JDQSxRQUFRRSxJQUFaLEVBQWtCO1lBQ1ZBLE9BQU9GLFFBQVFFLElBQW5CO1lBQ0ltQixXQUFXbkIsS0FBS29CLFVBQWhCLElBQThCRCxPQUFPRSxnQkFBUCxLQUE0QnJCLElBQTlELEVBQW9FO2dCQUM1REEsS0FBS29CLFVBQVQsRUFBcUI7NEJBQ0xwQixLQUFLb0IsVUFBakIsRUFBNkJ0QixPQUE3Qjs7bUJBRUdvQixXQUFQLENBQW1CbEIsSUFBbkI7bUJBQ09RLFFBQVFWLE9BQVIsQ0FBUDs7O1dBR0QsS0FBUDs7Ozs7Ozs7Ozs7O0FBWUosQUFBTyxTQUFTd0IsV0FBVCxDQUFxQkgsTUFBckIsRUFBNkJyQixPQUE3QixFQUFzQztRQUNyQ0EsUUFBUUUsSUFBWixFQUFrQjtlQUNQc0IsV0FBUCxDQUFtQnhCLFFBQVFFLElBQTNCO2VBQ09TLFdBQVdYLE9BQVgsQ0FBUDs7Ozs7Ozs7Ozs7Ozs7OztBQWdCUixBQUFPLFNBQVN5QixZQUFULENBQXNCSixNQUF0QixFQUE4QnJCLE9BQTlCLEVBQXVDMEIsT0FBdkMsRUFBZ0Q7UUFDL0MxQixRQUFRRSxJQUFaLEVBQWtCO1lBQ1ZBLE9BQU9GLFFBQVFFLElBQW5CO1lBQ0lBLEtBQUt5QixXQUFMLEtBQXFCRCxPQUF6QixFQUFrQztnQkFDMUJ4QixLQUFLb0IsVUFBVCxFQUFxQjsyQkFDTnRCLE9BQVg7O21CQUVHeUIsWUFBUCxDQUFvQnZCLElBQXBCLEVBQTBCd0IsT0FBMUI7bUJBQ09oQixRQUFRVixPQUFSLENBQVA7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCWixBQUFPLFNBQVM0QixZQUFULENBQXNCUCxNQUF0QixFQUE4QnJCLE9BQTlCLEVBQXVDMEIsT0FBdkMsRUFBZ0Q7UUFDL0MxQixRQUFRRSxJQUFaLEVBQWtCO1lBQ1ZBLE9BQU9GLFFBQVFFLElBQW5CO1lBQ0lBLEtBQUtvQixVQUFULEVBQXFCO3VCQUNOdEIsT0FBWDs7ZUFFRzRCLFlBQVAsQ0FBb0IxQixJQUFwQixFQUEwQndCLE9BQTFCO1lBQ0lBLFFBQVEvQixnQkFBUixDQUFKLEVBQStCO3VCQUNoQitCLFFBQVEvQixnQkFBUixDQUFYOztlQUVHZSxRQUFRUixJQUFSLENBQVA7Ozs7Ozs7Ozs7Ozs7O0FBY1IsQUFBTyxTQUFTMkIsWUFBVCxDQUFzQjdCLE9BQXRCLEVBQStCYixJQUEvQixFQUFxQzJDLEtBQXJDLEVBQTRDO1FBQzNDOUIsUUFBUUUsSUFBWixFQUFrQjtZQUNWQSxPQUFPRixRQUFRRSxJQUFuQjtZQUNJVyxXQUFXWCxLQUFLSSxZQUFMLENBQWtCbkIsSUFBbEIsQ0FBZjthQUNLMEMsWUFBTCxDQUFrQjFDLElBQWxCLEVBQXdCMkMsS0FBeEI7WUFDSUMsUUFBUS9CLFFBQVFnQyxXQUFSLENBQW9CQyxrQkFBcEIsSUFBMEMsRUFBdEQ7WUFDSUYsTUFBTUcsT0FBTixDQUFjL0MsSUFBZCxNQUF3QixDQUFDLENBQTdCLEVBQWdDO21CQUNyQnlCLE9BQU9aLE9BQVAsRUFBZ0JiLElBQWhCLEVBQXNCMEIsUUFBdEIsRUFBZ0NpQixLQUFoQyxDQUFQOzs7Ozs7Ozs7Ozs7OztBQWNaLEFBQU8sU0FBU0ssZUFBVCxDQUF5Qm5DLE9BQXpCLEVBQWtDYixJQUFsQyxFQUF3QztRQUN2Q2EsUUFBUUUsSUFBWixFQUFrQjtZQUNWQSxPQUFPRixRQUFRRSxJQUFuQjtZQUNJVyxXQUFXWCxLQUFLSSxZQUFMLENBQWtCbkIsSUFBbEIsQ0FBZjthQUNLZ0QsZUFBTCxDQUFxQmhELElBQXJCO1lBQ0k0QyxRQUFRL0IsUUFBUWdDLFdBQVIsQ0FBb0JDLGtCQUFwQixJQUEwQyxFQUF0RDtZQUNJRixNQUFNRyxPQUFOLENBQWMvQyxJQUFkLE1BQXdCLENBQUMsQ0FBN0IsRUFBZ0M7bUJBQ3JCeUIsT0FBT1osT0FBUCxFQUFnQmIsSUFBaEIsRUFBc0IwQixRQUF0QixFQUFnQyxJQUFoQyxDQUFQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwUlo7Ozs7OztBQU1BLEFBQU8sSUFBTXVCLGlCQUFpQixTQUFqQkEsY0FBaUIsQ0FBQ0MsVUFBRDs7Ozs7Ozs7Ozs7Ozs7O3FCQTJCMUJDLGlCQTNCMEIsZ0NBMkJOO1dBQ1hwQyxJQUFMLENBQVVQLGdCQUFWLElBQThCLElBQTlCO0tBNUJzQjs7Ozs7Ozs7O3FCQW9DMUI0QyxvQkFwQzBCLG1DQW9DSCxFQXBDRzs7Ozs7Ozs7Ozs7OztxQkErQzFCQyx3QkEvQzBCLHVDQStDQyxFQS9DRDs7Ozs7Ozs7Ozs7OzBCQVFqQjtlQUNFLENBQUMsS0FBS2xDLFlBQUwsQ0FBa0IsSUFBbEIsS0FBMkIsS0FBS21DLFNBQWpDLEVBQTRDbEQsV0FBNUMsRUFBUDs7Ozs7Ozs7Ozs7OzBCQVNPO2VBQ0EsSUFBUDs7OztJQW5Cb0Q4QyxVQUE5QjtDQUF2Qjs7QUNSUCxJQUFJSyxvQkFBSjs7QUFFQSxJQUFJOztRQUVJQyxLQUFLLElBQUlDLEtBQUtGLFdBQVQsQ0FBcUIsTUFBckIsQ0FBVDtrQkFDY0UsS0FBS0YsV0FBbkI7Q0FISixDQUlFLE9BQU1HLEVBQU4sRUFBVTtrQkFDTSxxQkFBU0MsS0FBVCxFQUFnQkMsTUFBaEIsRUFBd0I7aUJBQ3pCQSxVQUFVO3FCQUNOLEtBRE07d0JBRUgsS0FGRztvQkFHUEM7U0FIWjtZQUtJQyxNQUFNQyxTQUFTQyxXQUFULENBQXFCLGFBQXJCLENBQVY7WUFDSUMsZUFBSixDQUFvQk4sS0FBcEIsRUFBMkJDLE9BQU9NLE9BQWxDLEVBQTJDTixPQUFPTyxVQUFsRCxFQUE4RFAsT0FBT1EsTUFBckU7ZUFDT04sR0FBUDtLQVJKO2dCQVVZckUsU0FBWixHQUF3QmdFLEtBQUtGLFdBQUwsQ0FBaUI5RCxTQUF6QztDQUdKOztBQ2pCQTs7Ozs7Ozs7Ozs7QUFXQSxBQUFPLFNBQVM0RSxVQUFULENBQWtCdEQsSUFBbEIsRUFBd0J1RCxNQUF4QixFQUFnQ0MsSUFBaEMsRUFBeUU7UUFBbkNMLE9BQW1DLHVFQUF6QixJQUF5QjtRQUFuQkMsVUFBbUIsdUVBQU4sSUFBTTs7UUFDeEUsQ0FBQzdFLFNBQVNnRixNQUFULENBQUwsRUFBdUI7Y0FDYixJQUFJRSxTQUFKLENBQWMseUJBQWQsQ0FBTjs7UUFFQWhCLEtBQUssSUFBSUQsV0FBSixDQUFnQmUsTUFBaEIsRUFBd0I7Z0JBQ3JCQyxJQURxQjt3QkFBQTs7S0FBeEIsQ0FBVDtXQUtPeEQsS0FBSzBELGFBQUwsQ0FBbUJqQixFQUFuQixDQUFQOzs7QUNyQko7Ozs7O0FBS0EsSUFBTWtCLFdBQVNsRixPQUFPc0MsY0FBdEI7Ozs7Ozs7O0lBT002Qzs7Ozs7O3NCQU1VQyxJQUFaLEVBQWtCOzs7OzthQUNUQyxDQUFMLEdBQVMsRUFBVDtlQUNPRCxRQUFRLEVBQWY7WUFDSSxDQUFDL0UsUUFBUStFLElBQVIsQ0FBTCxFQUFvQjttQkFDVCxDQUFDQSxJQUFELENBQVA7O2FBRUNBLElBQUwsR0FBWUEsSUFBWjthQUNLRSxTQUFMLEdBQWlCO21CQUFNLElBQU47U0FBakI7YUFDS0MsT0FBTCxHQUFlLFVBQUNDLEdBQUQ7bUJBQVNBLEdBQVQ7U0FBZjthQUNLQyxRQUFMLEdBQWdCO21CQUFNLE1BQUt0QyxLQUFYO1NBQWhCO2FBQ0t1QyxRQUFMLEdBQWdCLFVBQUNGLEdBQUQsRUFBUztrQkFDZixNQUFLRCxPQUFMLENBQWFDLEdBQWIsQ0FBTjtnQkFDS0EsUUFBUSxJQUFSLElBQWdCQSxRQUFRbkIsU0FBekIsSUFDQSxNQUFLc0IsWUFBTCxDQUFrQkgsR0FBbEIsS0FBMEIsTUFBS0YsU0FBTCxDQUFlRSxHQUFmLENBRDlCLEVBQ21EO29CQUMzQ3RELFdBQVcsTUFBS2lCLEtBQXBCO29CQUNJakIsYUFBYXNELEdBQWpCLEVBQXNCOzBCQUNickMsS0FBTCxHQUFhcUMsR0FBYjswQkFDS0ksT0FBTCxDQUFhSixHQUFiLEVBQWtCdEQsUUFBbEI7O2FBTFIsTUFPTzs7c0JBRUcsSUFBSThDLFNBQUosZUFDV1EsR0FEWCxxQkFDZ0MsTUFBS2hGLElBRHJDLHdCQUM4RCxNQUFLcUYsS0FBTCxDQUFXckQsRUFEekUsUUFBTjs7U0FYUjs7Ozs7Ozs7O3VCQXNCSnNELDJCQUFRQyxVQUFVO1lBQ1ZuRyxXQUFXbUcsUUFBWCxLQUF3QmpHLFNBQVNpRyxRQUFULENBQTVCLEVBQWdEO2lCQUN2Q1YsQ0FBTCxDQUFPVyxJQUFQLENBQVlELFFBQVo7O2VBRUcsSUFBUDs7Ozs7Ozs7O3VCQU9KRSwrQkFBVUYsVUFBVTtZQUNaRyxLQUFLLEtBQUtiLENBQUwsQ0FBTzlCLE9BQVAsQ0FBZXdDLFFBQWYsQ0FBVDtZQUNJRyxPQUFPLENBQUMsQ0FBWixFQUFlO2lCQUNOYixDQUFMLENBQU9jLE1BQVAsQ0FBY0QsRUFBZCxFQUFrQixDQUFsQjs7ZUFFRyxJQUFQOzs7Ozs7Ozs7O3VCQVFKTiwyQkFBUXpELFVBQVVELFVBQVU7YUFDbkIsSUFBSWtFLElBQUksQ0FBUixFQUFXQyxNQUFNLEtBQUtoQixDQUFMLENBQU9pQixNQUE3QixFQUFxQ0YsSUFBSUMsR0FBekMsRUFBOENELEdBQTlDLEVBQW1EO2dCQUMzQ0csTUFBTSxLQUFLbEIsQ0FBTCxDQUFPZSxDQUFQLENBQVY7Z0JBQ0l0RyxTQUFTeUcsR0FBVCxDQUFKLEVBQW1CO3FCQUNWVixLQUFMLENBQVdVLEdBQVgsRUFBZ0JwRyxJQUFoQixDQUFxQixLQUFLMEYsS0FBMUIsRUFBaUMsSUFBakMsRUFBdUMxRCxRQUF2QyxFQUFpREQsUUFBakQ7YUFESixNQUVPO29CQUNDLElBQUosRUFBVUMsUUFBVixFQUFvQkQsUUFBcEI7Ozs7Ozs7Ozs7O3VCQVNac0UsMkJBQVEvRixLQUFLO2VBQ0YsS0FBSzJFLElBQUwsQ0FBVTdCLE9BQVYsQ0FBa0I5QyxHQUFsQixNQUEyQixDQUFDLENBQW5DOzs7Ozs7Ozs7Ozt1QkFTSmdHLHVCQUFNakcsTUFBTTthQUNIQSxJQUFMLEdBQVlBLElBQVo7WUFDSSxLQUFLa0csYUFBTCxLQUF1QixJQUEzQixFQUFpQztpQkFDeEJDLFFBQUwsR0FBZ0IsS0FBS25HLElBQXJCOztlQUVHLElBQVA7Ozs7Ozs7Ozt1QkFPSm9HLDRCQUFRQyxXQUFXO2FBQ1ZDLFlBQUwsR0FBb0IvRyxTQUFTOEcsU0FBVCxJQUNoQjdHLE9BQU8rRyxNQUFQLENBQWNGLFNBQWQsQ0FEZ0IsR0FFaEJBLFNBRko7ZUFHTyxJQUFQOzs7Ozs7Ozs7O3VCQVFKRyxpQ0FBMkI7WUFBakJMLFFBQWlCLHVFQUFOLElBQU07O1lBQ25CN0csU0FBUzZHLFFBQVQsQ0FBSixFQUF3QjtpQkFDZkQsYUFBTCxHQUFxQixLQUFyQjtpQkFDS0MsUUFBTCxHQUFnQkEsUUFBaEI7U0FGSixNQUdPO2lCQUNFRCxhQUFMLEdBQXFCLENBQUMsQ0FBQ0MsUUFBdkI7aUJBQ0tBLFFBQUwsR0FBZ0IsS0FBS25HLElBQXJCOztlQUVHLElBQVA7Ozs7Ozs7Ozt1QkFPSnFFLDZCQUFTQyxRQUFRO2FBQ1JtQyxTQUFMLEdBQWlCbkMsTUFBakI7ZUFDTyxJQUFQOzs7Ozs7Ozs7O3VCQVFKb0MseUJBQU9uQixVQUFVOzs7WUFDVG5HLFdBQVdtRyxRQUFYLENBQUosRUFBMEI7aUJBQ2pCTixRQUFMLEdBQWdCO3VCQUFNTSxTQUFTLE9BQUs1QyxLQUFkLENBQU47YUFBaEI7O2VBRUcsSUFBUDs7Ozs7Ozs7Ozs7dUJBU0pnRSx5QkFBT3BCLFVBQVU7WUFDVG5HLFdBQVdtRyxRQUFYLENBQUosRUFBMEI7aUJBQ2pCUixPQUFMLEdBQWVRLFFBQWY7O2VBRUcsSUFBUDs7Ozs7Ozs7Ozs7dUJBU0pxQiw2QkFBU3JCLFVBQVU7WUFDWG5HLFdBQVdtRyxRQUFYLENBQUosRUFBMEI7aUJBQ2pCVCxTQUFMLEdBQWlCUyxRQUFqQjs7ZUFFRyxJQUFQOzs7Ozs7Ozs7O3VCQVFKSixxQ0FBYUgsS0FBSztZQUNWWSxJQUFJLENBQVI7WUFDSWhCLE9BQU8sS0FBS0EsSUFBaEI7WUFDSUEsS0FBS2tCLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7bUJBQ1osSUFBUDs7ZUFFR0YsSUFBSWhCLEtBQUtrQixNQUFoQixFQUF3QjtnQkFDaEJkLGVBQWVKLEtBQUtnQixDQUFMLENBQWYsSUFDQVosSUFBSW5DLFdBQUosSUFBbUJtQyxJQUFJbkMsV0FBSixLQUFvQitCLEtBQUtnQixDQUFMLENBRDNDLEVBRUc7dUJBQ1EsSUFBUDs7OztlQUlELEtBQVA7Ozs7Ozs7Ozt1QkFPSmlCLHFCQUFLeEIsT0FBTzthQUNIQSxLQUFMLEdBQWFBLEtBQWI7aUJBQ09BLEtBQVAsRUFBYyxLQUFLckYsSUFBbkIsRUFBeUI7aUJBQ2hCLEtBQUtpRixRQUFMLENBQWNyRCxJQUFkLENBQW1CLElBQW5CLENBRGdCO2lCQUVoQixLQUFLc0QsUUFBTCxDQUFjdEQsSUFBZCxDQUFtQixJQUFuQixDQUZnQjswQkFHUDtTQUhsQjtZQUtJLENBQUNoQyxZQUFZLEtBQUswRyxZQUFqQixDQUFMLEVBQXFDO2tCQUMzQixLQUFLdEcsSUFBWCxJQUFtQixLQUFLc0csWUFBeEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJaLEFBQU8sU0FBU1EsSUFBVCxDQUFjbEMsSUFBZCxFQUFvQjtRQUNuQkEsZ0JBQWdCRCxRQUFwQixFQUE4QjtlQUNuQkMsSUFBUDs7V0FFRyxJQUFJRCxRQUFKLENBQWFDLElBQWIsQ0FBUDs7OztBQUlKRixTQUFPb0MsSUFBUCxFQUFhLEtBQWIsRUFBb0I7T0FBQSxpQkFBUTtlQUFTQSxNQUFQOztDQUE5QjtBQUNBcEMsU0FBT29DLElBQVAsRUFBYSxRQUFiLEVBQXVCO09BQUEsaUJBQVE7ZUFBU0EsS0FBS0MsTUFBTCxDQUFQOztDQUFqQztBQUNBckMsU0FBT29DLElBQVAsRUFBYSxTQUFiLEVBQXdCO09BQUEsaUJBQVE7ZUFBU0EsS0FBS0UsT0FBTCxDQUFQOztDQUFsQztBQUNBdEMsU0FBT29DLElBQVAsRUFBYSxRQUFiLEVBQXVCO09BQUEsaUJBQVE7ZUFBU0EsS0FBS0csTUFBTCxDQUFQOztDQUFqQzs7QUNsUEE7Ozs7Ozs7O0FBUUEsU0FBU0MsUUFBVCxDQUFrQkMsUUFBbEIsRUFBNEJDLE9BQTVCLEVBQXFDO1FBQzdCQSxZQUFZLEVBQVosSUFBa0JELFNBQVNuQixPQUFULENBQWlCZ0IsT0FBakIsQ0FBdEIsRUFBaUQ7ZUFDdEMsSUFBUDs7UUFFQSxDQUFDRyxTQUFTbkIsT0FBVCxDQUFpQmUsTUFBakIsQ0FBTCxFQUErQjtZQUN2QjttQkFDT00sS0FBS0MsS0FBTCxDQUFXRixPQUFYLENBQVA7U0FESixDQUVFLE9BQU8xRCxFQUFQLEVBQVc7Ozs7V0FJVjBELE9BQVA7Ozs7Ozs7Ozs7O0FBV0osU0FBUzFFLGNBQVQsQ0FBc0I2RSxPQUF0QixFQUErQkMsSUFBL0IsRUFBcUM3RSxLQUFyQyxFQUE0QztRQUNwQzhFLG1CQUFtQkYsUUFBUXBHLFlBQVIsQ0FBcUJxRyxJQUFyQixDQUF2QjtRQUNJQyxxQkFBcUI5RSxLQUF6QixFQUFnQztZQUN4QkEsVUFBVSxJQUFWLElBQWtCQSxVQUFVa0IsU0FBNUIsSUFBeUNsQixVQUFVLEtBQXZELEVBQThEOzJCQUMzQ0EsS0FBZix5Q0FBZUEsS0FBZjtxQkFDSyxRQUFMO3FCQUNLLFFBQUw7NEJBQ1lELFlBQVIsQ0FBcUI4RSxJQUFyQixFQUEyQjdFLEtBQTNCOztxQkFFQyxTQUFMOzRCQUNZRCxZQUFSLENBQXFCOEUsSUFBckIsRUFBMkIsRUFBM0I7O1NBUFIsTUFTTyxJQUFJQyxxQkFBcUIsSUFBekIsRUFBK0I7b0JBQzFCekUsZUFBUixDQUF3QndFLElBQXhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdDWixBQUFPLElBQU1FLGtCQUFrQixTQUFsQkEsZUFBa0IsQ0FBQ3hFLFVBQUQ7Ozs7Ozs7Ozs7MEJBT2I7Ozt3REFDVixzQkFEVTs7Z0JBRU55RSxRQUFRLE1BQUtDLFVBQWpCO2dCQUNJRCxLQUFKLEVBQVc7b0JBQ0gsQ0FBQzlILFFBQVE4SCxLQUFSLENBQUwsRUFBcUI7NEJBQ1QsQ0FBQ0EsS0FBRCxDQUFSOzt3QkFFSUEsTUFBTUUsTUFBTixDQUFhLFVBQUNDLEdBQUQsRUFBTUMsWUFBTixFQUF1Qjt5QkFDbkMsSUFBSTFILENBQVQsSUFBYzBILFlBQWQsRUFBNEI7NEJBQ3BCMUgsQ0FBSixJQUFTeUcsS0FBS2lCLGFBQWExSCxDQUFiLENBQUwsQ0FBVDs7MkJBRUd5SCxHQUFQO2lCQUpJLEVBS0wsRUFMSyxDQUFSO2FBSkosTUFVTzt3QkFDSyxFQUFSOzttQkFFR2hHLGNBQVAsUUFBNEIsWUFBNUIsRUFBMEM7dUJBQy9CNkYsS0FEK0I7MEJBRTVCLEtBRjRCOzhCQUd4QjthQUhsQjtnQkFLSUssV0FBVyxNQUFLbkYsV0FBTCxDQUFpQkMsa0JBQWpCLElBQXVDLEVBQXREOzt1Q0FDU3pDLENBdEJDO29CQXVCRnlHLFVBQU9hLE1BQU10SCxDQUFOLENBQVg7d0JBQ0s0RixLQUFMLENBQVc1RixDQUFYLEVBQWN3RyxJQUFkO29CQUNNVixRQXpCQSxHQXlCd0JXLE9BekJ4QixDQXlCQVgsUUF6QkE7b0JBeUJVTSxTQXpCVixHQXlCd0JLLE9BekJ4QixDQXlCVUwsU0F6QlY7O29CQTBCRixDQUFDTixRQUFELElBQWE2QixTQUFTakYsT0FBVCxDQUFpQjFDLENBQWpCLE1BQXdCLENBQUMsQ0FBMUMsRUFBNkM7NEJBQ3BDbUcsU0FBTDsrQkFDV25HLENBQVg7O29CQUVBOEYsWUFBWU0sU0FBaEIsRUFBMkI7NEJBQ2xCbkIsT0FBTCxDQUFhLFlBQU07NEJBQ1hhLFFBQUosRUFBYzsyQ0FDRyxNQUFLcEYsSUFBbEIsRUFBd0JvRixRQUF4QixFQUFrQyxNQUFLVyxRQUFLOUcsSUFBVixDQUFsQzs7NEJBRUF5RyxTQUFKLEVBQWU7dUNBQ0YsTUFBSzFGLElBQWQsRUFBb0IwRixTQUFwQjs7cUJBTFI7Ozs7aUJBVEgsSUFBSXBHLENBQVQsSUFBY3NILEtBQWQsRUFBcUI7c0JBQVp0SCxDQUFZOzs7Ozs7Ozs7Ozs7eUJBMEJ6QjhDLGlCQXZEMkIsZ0NBdURQO2tDQUNWQSxpQkFBTjtnQkFDSXdFLFFBQVEsS0FBS0MsVUFBakI7aUJBQ0ssSUFBSXZILENBQVQsSUFBY3NILEtBQWQsRUFBcUI7b0JBQ2JiLFFBQU9hLE1BQU10SCxDQUFOLENBQVg7b0JBQ004RixTQUZXLEdBRUVXLEtBRkYsQ0FFWFgsUUFGVzs7b0JBR2JBLFNBQUosRUFBYzt3QkFDTnZHLFlBQVksS0FBS2tILE1BQUs5RyxJQUFWLENBQVosQ0FBSixFQUFrQzs0QkFDMUIsS0FBS2UsSUFBTCxDQUFVa0gsWUFBVixDQUF1QjlCLFNBQXZCLENBQUosRUFBc0M7aUNBQzdCVyxNQUFLOUcsSUFBVixJQUFrQmtILFNBQVNKLEtBQVQsRUFBZSxLQUFLL0YsSUFBTCxDQUFVSSxZQUFWLENBQXVCZ0YsU0FBdkIsQ0FBZixDQUFsQjs7cUJBRlIsTUFJTzt1Q0FDVSxLQUFLcEYsSUFBbEIsRUFBd0JvRixTQUF4QixFQUFrQyxLQUFLVyxNQUFLOUcsSUFBVixDQUFsQzs7OztTQW5FVzs7Ozs7Ozs7Ozs7Ozt5QkFrRjNCcUQsd0JBbEYyQixxQ0FrRkZtRSxJQWxGRSxFQWtGSVUsTUFsRkosRUFrRllDLE1BbEZaLEVBa0ZvQjtrQ0FDckM5RSx3QkFBTixZQUErQm1FLElBQS9CLEVBQXFDVSxNQUFyQyxFQUE2Q0MsTUFBN0M7Z0JBQ0lSLFFBQVEsS0FBS0MsVUFBakI7aUJBQ0ssSUFBSXZILENBQVQsSUFBY3NILEtBQWQsRUFBcUI7b0JBQ2JiLFNBQU9hLE1BQU10SCxDQUFOLENBQVg7b0JBQ0l5RyxPQUFLWCxRQUFMLEtBQWtCcUIsSUFBdEIsRUFBNEI7eUJBQ25CVixPQUFLOUcsSUFBVixJQUFrQmtILFNBQVNKLE1BQVQsRUFBZXFCLE1BQWYsQ0FBbEI7Ozs7U0F4RmU7Ozs7Ozs7Ozs7Ozs7eUJBdUczQkMsZUF2RzJCLDRCQXVHWEMsUUF2R1csRUF1R0Q5QyxRQXZHQyxFQXVHUzttQkFDekIsS0FBS3FDLFVBQUwsQ0FBZ0JTLFFBQWhCLEVBQTBCL0MsT0FBMUIsQ0FBa0NDLFFBQWxDLENBQVA7U0F4R3VCOzs7Ozs7Ozs7Ozs7eUJBbUgzQitDLGlCQW5IMkIsOEJBbUhURCxRQW5IUyxFQW1IQzlDLFFBbkhELEVBbUhXO2lCQUM3QnFDLFVBQUwsQ0FBZ0JTLFFBQWhCLEVBQTBCNUMsU0FBMUIsQ0FBb0NGLFFBQXBDO1NBcEh1Qjs7O01BQThCckMsVUFBOUI7Q0FBeEI7O0FDaEZQLElBQU1xRixhQUFhQyxRQUFRL0ksU0FBM0I7O0FBRUEsQUFBTyxJQUFNZ0osVUFBVUYsV0FBV0UsT0FBWCxJQUNuQkYsV0FBV0csZUFEUSxJQUVuQkgsV0FBV0ksa0JBRlEsSUFHbkJKLFdBQVdLLGlCQUhRLElBSW5CTCxXQUFXTSxnQkFKUSxJQUtuQk4sV0FBV08scUJBTFI7O0FDRVAsSUFBTUMsaUJBQWlCLGVBQXZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQ0EsQUFBTyxJQUFNQyxjQUFjLFNBQWRBLFdBQWMsQ0FBQzlGLFVBQUQ7Ozs7Ozs7Ozs7MEJBT1Q7Ozs7d0RBQ1Ysc0JBRFU7O2dCQUdOK0YsU0FBUyxNQUFLQSxNQUFMLElBQWUsRUFBNUI7O3VDQUNTNUksQ0FKQztvQkFLRmtGLFdBQVdqRyxTQUFTMkosT0FBTzVJLENBQVAsQ0FBVCxJQUNYLE1BQUs0SSxPQUFPNUksQ0FBUCxDQUFMLENBRFcsR0FFWDRJLE9BQU81SSxDQUFQLENBRko7b0JBR0lqQixXQUFXbUcsUUFBWCxDQUFKLEVBQTBCO3dCQUNsQjJELE9BQU83SSxFQUFFOEksS0FBRixDQUFRSixjQUFSLENBQVg7d0JBQ0l6RSxTQUFTNEUsS0FBSyxDQUFMLENBQWI7d0JBQ0lFLFdBQVcsQ0FBQ0YsS0FBSyxDQUFMLEtBQVcsRUFBWixFQUFnQkcsSUFBaEIsRUFBZjt3QkFDSUQsUUFBSixFQUFjOzhCQUNMRSxRQUFMLENBQWNoRixNQUFkLEVBQXNCOEUsUUFBdEIsRUFBZ0M3RCxRQUFoQztxQkFESixNQUVPOzhCQUNFeEUsSUFBTCxDQUFVd0ksZ0JBQVYsQ0FBMkJqRixNQUEzQixFQUFtQyxVQUFDZCxFQUFELEVBQVE7cUNBQzlCN0QsSUFBVCxRQUFvQjZELEVBQXBCO3lCQURKOztpQkFQUixNQVdPOzBCQUNHLElBQUlnQixTQUFKLENBQWMsNkJBQWQsQ0FBTjs7OztpQkFoQkgsSUFBSW5FLENBQVQsSUFBYzRJLE1BQWQsRUFBc0I7c0JBQWI1SSxDQUFhOzs7Ozs7Ozs7Ozs7Ozs7O3lCQThCMUJpSixRQXpDdUIscUJBeUNkaEYsTUF6Q2MsRUF5Q044RSxRQXpDTSxFQXlDSTdELFFBekNKLEVBeUNjOzs7aUJBQzVCeEUsSUFBTCxDQUFVd0ksZ0JBQVYsQ0FBMkJqRixNQUEzQixFQUFtQyxVQUFDWCxLQUFELEVBQVc7b0JBQ3RDNkYsU0FBUzdGLE1BQU02RixNQUFuQjt1QkFDT0EsVUFBVUEsaUJBQWpCLEVBQWtDO3dCQUMxQmYsUUFBUTlJLElBQVIsQ0FBYTZKLE1BQWIsRUFBcUJKLFFBQXJCLENBQUosRUFBb0M7aUNBQ3ZCekosSUFBVCxTQUFvQmdFLEtBQXBCLEVBQTJCNkYsTUFBM0I7OzZCQUVLQSxPQUFPckgsVUFBaEI7O2FBTlI7U0ExQ21COzs7Ozs7Ozs7Ozs7Ozs7eUJBZ0V2QnNILE9BaEV1QixvQkFnRWZuRixNQWhFZSxFQWdFUEMsSUFoRU8sRUFnRWtDO2dCQUFuQ0wsT0FBbUMsdUVBQXpCLElBQXlCO2dCQUFuQkMsVUFBbUIsdUVBQU4sSUFBTTs7bUJBQzlDRSxXQUFTLElBQVQsRUFBZUMsTUFBZixFQUF1QkMsSUFBdkIsRUFBNkJMLE9BQTdCLEVBQXNDQyxVQUF0QyxDQUFQO1NBakVtQjs7O01BQThCakIsVUFBOUI7Q0FBcEI7O0FDeENQLElBQU13RyxVQUFVM0YsUUFBaEI7Ozs7Ozs7O0FBUUEsQUFBTyxTQUFTNEYsV0FBVCxDQUFxQjVJLElBQXJCLEVBQTJCO1FBQzFCNkksTUFBTTdJLEtBQUs4SSxhQUFMLElBQXNCSCxPQUFoQztRQUNJSSxZQUFZRixJQUFJN0gsYUFBSixDQUFrQixPQUFsQixDQUFoQjtjQUNVZ0ksSUFBVixHQUFpQixVQUFqQjtjQUNVckgsWUFBVixDQUF1QixJQUF2QixhQUFzQzNCLEtBQUtpQixFQUEzQztRQUNJZ0ksT0FBT0osSUFBSUksSUFBZjs7UUFFSUEsS0FBS0MsaUJBQVQsRUFBNEI7YUFDbkIzSCxZQUFMLENBQWtCd0gsU0FBbEIsRUFBNkJFLEtBQUtDLGlCQUFsQztLQURKLE1BRU87YUFDRWhJLFdBQUwsQ0FBaUI2SCxTQUFqQjs7V0FFR0EsU0FBUDs7O0FDakJKOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkEsQUFBTyxJQUFNSSxhQUFhLFNBQWJBLFVBQWEsQ0FBQ2hILFVBQUQ7Ozs7Ozs7MEJBSVI7Ozt3REFDVixzQkFEVTs7Z0JBRU4sQ0FBQyxNQUFLTCxXQUFMLENBQWlCaUgsU0FBdEIsRUFBaUM7b0JBQ3pCN0osTUFBTSxNQUFLNEMsV0FBZjt1QkFDT2YsY0FBUCxDQUFzQjdCLEdBQXRCLEVBQTJCLFdBQTNCLEVBQXdDOzJCQUM3QjBKO2lCQURYOztrQkFJQ1EsU0FBTDs7Ozt5QkFHSmhILGlCQWZzQixnQ0FlRjtrQ0FDVkEsaUJBQU47aUJBQ0twQyxJQUFMLENBQVVxSixTQUFWLENBQW9CQyxHQUFwQixDQUF3QixLQUFLckksRUFBN0I7U0FqQmtCOzt5QkFvQnRCbUksU0FwQnNCLHdCQW9CVjtnQkFDSkcsUUFBUSxLQUFLQyxHQUFqQjtnQkFDSWpMLFNBQVNnTCxLQUFULENBQUosRUFBcUI7cUJBQ1p6SCxXQUFMLENBQWlCaUgsU0FBakIsQ0FBMkJVLFdBQTNCLEdBQXlDRixLQUF6Qzs7U0F2QmM7OztNQUE4QnBILFVBQTlCO0NBQW5COztBQzVCUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStCQSxBQUFPLElBQU11SCxnQkFBZ0IsU0FBaEJBLGFBQWdCLENBQUN2SCxVQUFEOzs7Ozs7Ozs7Ozs7O2dDQVFSO3VCQUNOLElBQVA7Ozs7Ozs7Ozs7OzBCQVFVOzs7d0RBQ1Ysc0JBRFU7O2dCQUVOLE1BQUt3SCxVQUFMLElBQW1CLENBQUM5SyxZQUFZLE1BQUsrSyxRQUFqQixDQUF4QixFQUFvRDtvQkFDNUNoRCxRQUFRLE1BQUtDLFVBQWpCO29CQUNJRCxLQUFKLEVBQVc7d0JBQ0hwQyxXQUFXLFNBQVhBLFFBQVcsR0FBTTs4QkFDWnFGLE1BQUw7cUJBREo7eUJBR0ssSUFBSXZLLENBQVQsSUFBY3NILEtBQWQsRUFBcUI7OEJBQ1h0SCxDQUFOLEVBQVNpRixPQUFULENBQWlCQyxRQUFqQjs7Ozs7Ozs7Ozs7Ozs7eUJBV2hCcEMsaUJBckN5QixnQ0FxQ0w7a0NBQ1ZBLGlCQUFOO2dCQUNJLENBQUN2RCxZQUFZLEtBQUsrSyxRQUFqQixDQUFMLEVBQWlDO3FCQUN4QkMsTUFBTDs7U0F4Q2lCOzs7Ozs7Ozs7Ozs7O3lCQXFEekJBLE1BckR5QixtQkFxRGxCQyxHQXJEa0IsRUFxRGI7a0JBQ0ZBLE9BQU8sS0FBS0YsUUFBbEI7Z0JBQ0l2TCxXQUFXeUwsR0FBWCxDQUFKLEVBQXFCO29CQUNibEwsSUFBSixDQUFTLElBQVQ7YUFESixNQUVPLElBQUlMLFNBQVN1TCxHQUFULENBQUosRUFBbUI7cUJBQ2pCOUosSUFBTCxDQUFVK0osU0FBVixHQUFzQkQsR0FBdEI7YUFERyxNQUVBO3NCQUNHLElBQUlyRyxTQUFKLENBQWMsNEJBQWQsQ0FBTjs7U0E1RGlCOzs7TUFBOEJ0QixVQUE5QjtDQUF0Qjs7QUNqQ1A7QUFDQSxBQUFPLElBQU0yRSxTQUFTL0gsTUFBTUwsU0FBTixDQUFnQm9JLE1BQWhCLElBQTBCLFVBQVN0QyxRQUFULHFCQUF1Qzs7O1FBRS9Fd0YsSUFBSSxJQUFSO1FBQ0lsRixNQUFNa0YsRUFBRWpGLE1BQVo7UUFDSXpGLElBQUksQ0FBUjtRQUNJc0MsY0FBSjtRQUNJcUksVUFBVWxGLE1BQVYsS0FBcUIsQ0FBekIsRUFBNEI7Z0JBQ2hCa0YsVUFBVSxDQUFWLENBQVI7S0FESixNQUVPO2VBQ0kzSyxJQUFJd0YsR0FBSixJQUFXLEVBQUV4RixLQUFLMEssQ0FBUCxDQUFsQixFQUE2Qjs7O2dCQUdyQkEsRUFBRTFLLEdBQUYsQ0FBUjs7V0FFR0EsSUFBSXdGLEdBQVgsRUFBZ0J4RixHQUFoQixFQUFxQjtZQUNiQSxLQUFLMEssQ0FBVCxFQUFZO29CQUNBeEYsU0FBUzVDLEtBQVQsRUFBZ0JvSSxFQUFFMUssQ0FBRixDQUFoQixFQUFzQkEsQ0FBdEIsRUFBeUIwSyxDQUF6QixDQUFSOzs7V0FHRHBJLEtBQVA7Q0FuQkc7O0FDRFA7Ozs7QUFJQSxBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBMENNc0k7Ozs7O2lCQUtVQyxVQUFaLEVBQXdCOzs7aUJBQ1BBOzs7Ozs7T0FBYjtTQUNLQSxVQUFMLEdBQWtCQSxVQUFsQjs7Ozs7Ozs7O2tCQU9KQyx3QkFBTzs7UUFFQ0MsT0FBTyxHQUFHQyxLQUFILENBQVMxTCxJQUFULENBQWNxTCxTQUFkLEVBQXlCLENBQXpCLENBQVg7V0FDT25ELE9BQU9sSSxJQUFQLENBQVl5TCxJQUFaLEVBQWtCLFVBQUNFLENBQUQsRUFBSUMsS0FBSjthQUFjQSxNQUFNRCxDQUFOLENBQWQ7S0FBbEIsRUFBMEMsS0FBS0osVUFBL0MsQ0FBUDs7Ozs7Ozs7Ozs7O0FBUVIsQUFBTyxJQUFNTSxNQUFNLFNBQU5BLEdBQU0sQ0FBQ0MsVUFBRDtTQUFnQixJQUFJUixLQUFKLENBQVVRLFVBQVYsQ0FBaEI7Q0FBWjs7QUN0RVA7Ozs7OztBQU1BLFNBQVNDLEtBQVQsQ0FBZTNLLElBQWYsRUFBcUI7UUFDYjtlQUNPLENBQUN6QixTQUFTeUIsS0FBSzRLLFNBQWQsQ0FBUjtLQURKLENBRUUsT0FBT2pJLEVBQVAsRUFBVztlQUNGLElBQVA7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QlIsQUFBTyxTQUFTa0ksSUFBVCxDQUFjQyxRQUFkLEVBQXdCO1FBQ3JCQyxVQURxQixHQUV2QixzQkFBYzs7O1lBQ04sQ0FBQ0osTUFBTSxJQUFOLENBQUwsRUFBa0I7bUJBQ1AsSUFBUDs7WUFFQXBMLE9BQU9QLFNBQVNRLGFBQVQsQ0FBdUIsS0FBS3NDLFdBQTVCLENBQVg7WUFDSTNDLFNBQVNJLEtBQUtKLE1BQWxCOztZQUVJVyxVQUFVa0QsU0FBU2hDLGFBQVQsQ0FDVjdCLE9BQU82TCxPQUFQLEdBQWlCN0wsT0FBTzZMLE9BQXhCLEdBQWtDekwsS0FBSzBCLEVBRDdCLENBQWQ7Z0JBR1FILFNBQVIsR0FBb0J2QixLQUFLTCxHQUFMLENBQVNSLFNBQTdCO1lBQ0lTLE9BQU82TCxPQUFYLEVBQW9CO29CQUNSckosWUFBUixDQUFxQixJQUFyQixFQUEyQnBDLEtBQUswQixFQUFoQzs7ZUFFR25CLE9BQVA7S0FoQm1COzs7O2VBb0JoQnBCLFNBQVgsR0FBdUJELE9BQU93TSxNQUFQLENBQWNILFNBQVNwTSxTQUF2QixFQUFrQztxQkFDeEM7bUJBQ0ZxTSxVQURFOzBCQUVLLElBRkw7c0JBR0M7O0tBSkssQ0FBdkI7V0FPT0EsVUFBUDs7O0FDMURKOzs7Ozs7OztBQVFBLEFBQU8sSUFBTUcsTUFBTUMsV0FBWjs7Ozs7Ozs7QUFRUCxBQUFPLElBQU1DLFNBQVM7Z0NBQUE7a0NBQUE7MEJBQUE7d0JBQUE7O0NBQWYsQ0FPUCxBQUNBLEFBQ0EsQUFDQSxBQUNBOztBQ2xDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQSxJQUFNQyxpQkFBaUI1TSxPQUFPQyxTQUFQLENBQWlCMk0sY0FBeEM7Ozs7OztBQU9BLFNBQVNDLEtBQVQsR0FBaUI7O0FBRWpCQSxNQUFNNU0sU0FBTixHQUFrQkQsT0FBT3dNLE1BQVAsQ0FBYyxJQUFkLENBQWxCOzs7Ozs7OztBQVNBLElBQU1NLE1BQU0sU0FBTkEsR0FBTSxDQUFTQyxHQUFULEVBQWNwRixRQUFkLEVBQXdCO1NBQzNCaUYsZUFBZXpNLElBQWYsQ0FBb0I0TSxHQUFwQixFQUF5QnBGLFFBQXpCLENBQVA7Q0FERjs7Ozs7O0FBU0EsSUFBTXFGLFlBQVksU0FBWkEsU0FBWSxHQUFXO1NBQ3BCLElBQUlILEtBQUosRUFBUDtDQURGLENBS0E7O0FDcERBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLEFBR0E7Ozs7OztBQU1BLFNBQVNJLFFBQVQsQ0FBa0JDLFFBQWxCLEVBQTRCQyxHQUE1QixFQUFpQzs7Ozs7T0FLMUIvSixLQUFMLEdBQWE0SixXQUFiOzs7Ozs7OztPQVFLSSxRQUFMLEdBQWdCLEVBQWhCOzs7Ozs7T0FNS0MsUUFBTCxHQUFnQkwsV0FBaEI7Ozs7OztPQU1LTSxjQUFMLEdBQXNCLEtBQXRCOzs7Ozs7O09BT0tILEdBQUwsR0FBV0EsR0FBWDs7Ozs7O09BTUtJLE1BQUwsR0FBY1AsV0FBZDs7Ozs7O09BTUtRLFdBQUwsR0FBbUIsSUFBbkI7Ozs7OztPQU1LQyxPQUFMLEdBQWUsS0FBZjs7Ozs7O09BTUtQLFFBQUwsR0FBZ0JBLFFBQWhCOzs7OztPQUtLUSxJQUFMLEdBQVksSUFBWjs7Ozs7Ozs7Ozs7QUFZRixJQUFNQyxXQUFXLFNBQVhBLFFBQVcsQ0FBU3BNLElBQVQsRUFBZTJMLFFBQWYsRUFBeUJDLEdBQXpCLEVBQThCO01BQ3ZDcEksT0FBTyxJQUFJa0ksUUFBSixDQUFhQyxRQUFiLEVBQXVCQyxHQUF2QixDQUFiO09BQ0ssc0JBQUwsSUFBK0JwSSxJQUEvQjtTQUNPQSxJQUFQO0NBSEY7Ozs7Ozs7O0FBYUEsSUFBTTZJLFVBQVUsU0FBVkEsT0FBVSxDQUFTck0sSUFBVCxFQUFlO2FBQ2xCQSxJQUFYO1NBQ09BLEtBQUssc0JBQUwsQ0FBUDtDQUZGOzs7Ozs7O0FBV0EsSUFBTXNNLGFBQWEsU0FBYkEsVUFBYSxDQUFTdE0sSUFBVCxFQUFlO01BQzVCQSxLQUFLLHNCQUFMLENBQUosRUFBa0M7Ozs7TUFJNUJ1TSxZQUFZdk0sZ0JBQWdCeUgsT0FBbEM7TUFDTWtFLFdBQVdZLFlBQVl2TSxLQUFLdUMsU0FBakIsR0FBNkJ2QyxLQUFLMkwsUUFBbkQ7TUFDTUMsTUFBTVcsWUFBWXZNLEtBQUtJLFlBQUwsQ0FBa0IsS0FBbEIsQ0FBWixHQUF1QyxJQUFuRDtNQUNNb0QsT0FBTzRJLFNBQVNwTSxJQUFULEVBQWUyTCxRQUFmLEVBQXlCQyxHQUF6QixDQUFiOztNQUVJQSxHQUFKLEVBQVM7WUFDQzVMLEtBQUtvQixVQUFiLEVBQXlCNEssTUFBekIsQ0FBZ0NKLEdBQWhDLElBQXVDNUwsSUFBdkM7OztNQUdFdU0sU0FBSixFQUFlO1FBQ1BDLGFBQWF4TSxLQUFLd00sVUFBeEI7UUFDTTNLLFFBQVEyQixLQUFLM0IsS0FBbkI7UUFDTWlLLFdBQVd0SSxLQUFLc0ksUUFBdEI7UUFDTUQsV0FBV3JJLEtBQUtxSSxRQUF0Qjs7U0FFSyxJQUFJaEgsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMkgsV0FBV3pILE1BQS9CLEVBQXVDRixLQUFLLENBQTVDLEVBQStDO1VBQ3ZDNEIsT0FBTytGLFdBQVczSCxDQUFYLENBQWI7VUFDTTVGLE9BQU93SCxLQUFLeEgsSUFBbEI7VUFDTTJDLFFBQVE2RSxLQUFLN0UsS0FBbkI7O1lBRU0zQyxJQUFOLElBQWMyQyxLQUFkO2VBQ1MzQyxJQUFULElBQWlCNkQsU0FBakI7ZUFDUzJCLElBQVQsQ0FBY3hGLElBQWQ7ZUFDU3dGLElBQVQsQ0FBYzdDLEtBQWQ7Ozs7T0FJQyxJQUFJNkssUUFBUXpNLEtBQUswTSxVQUF0QixFQUFrQ0QsS0FBbEMsRUFBeUNBLFFBQVFBLE1BQU1oTCxXQUF2RCxFQUFvRTtlQUN2RGdMLEtBQVg7O0NBakNKLENBc0NBOztBQ2hLQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSxBQU1BOzs7Ozs7QUFNQSxJQUFNRSxxQkFBcUIsU0FBckJBLGtCQUFxQixDQUFTQyxHQUFULEVBQWN6TCxNQUFkLEVBQXNCO01BQzNDeUwsUUFBUSxLQUFaLEVBQW1CO1dBQ1YsNEJBQVA7OztNQUdFUCxRQUFRbEwsTUFBUixFQUFnQndLLFFBQWhCLEtBQTZCLGVBQWpDLEVBQWtEO1dBQ3pDLElBQVA7OztTQUdLeEssT0FBTzBMLFlBQWQ7Q0FURjs7Ozs7Ozs7OztBQXFCQSxJQUFNN0wsa0JBQWdCLFNBQWhCQSxlQUFnQixDQUFTNkgsR0FBVCxFQUFjMUgsTUFBZCxFQUFzQnlMLEdBQXRCLEVBQTJCaEIsR0FBM0IsRUFBZ0M7TUFDOUNrQixZQUFZSCxtQkFBbUJDLEdBQW5CLEVBQXdCekwsTUFBeEIsQ0FBbEI7TUFDSTRMLFdBQUo7O01BRUlELFNBQUosRUFBZTtTQUNSakUsSUFBSW1FLGVBQUosQ0FBb0JGLFNBQXBCLEVBQStCRixHQUEvQixDQUFMO0dBREYsTUFFTztTQUNBL0QsSUFBSTdILGFBQUosQ0FBa0I0TCxHQUFsQixDQUFMOzs7V0FHT0csRUFBVCxFQUFhSCxHQUFiLEVBQWtCaEIsR0FBbEI7O1NBRU9tQixFQUFQO0NBWkY7Ozs7Ozs7QUFxQkEsSUFBTUUsYUFBYSxTQUFiQSxVQUFhLENBQVNwRSxHQUFULEVBQWM7TUFDekI3SSxPQUFPNkksSUFBSXFFLGNBQUosQ0FBbUIsRUFBbkIsQ0FBYjtXQUNTbE4sSUFBVCxFQUFlLE9BQWYsRUFBd0IsSUFBeEI7U0FDT0EsSUFBUDtDQUhGLENBT0E7O0FDN0VBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxJQUFNbU4sZ0JBQWdCOzs7Ozs7Z0JBTU4sSUFOTTs7Ozs7Ozs7Z0JBY047Q0FkaEIsQ0FpQkE7O0FDbENBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLEFBR0E7Ozs7QUFJQSxTQUFTQyxPQUFULEdBQW1COzs7O09BSVpDLE9BQUwsR0FBZUYsY0FBY0csWUFBZCxJQUE4QixFQUE3Qzs7Ozs7T0FLS0MsT0FBTCxHQUFlSixjQUFjSyxZQUFkLElBQThCLEVBQTdDOzs7Ozs7QUFPRkosUUFBUTFPLFNBQVIsQ0FBa0IrTyxXQUFsQixHQUFnQyxVQUFTek4sSUFBVCxFQUFlO01BQ3pDLEtBQUtxTixPQUFULEVBQWtCO1NBQ1hBLE9BQUwsQ0FBYTVJLElBQWIsQ0FBa0J6RSxJQUFsQjs7Q0FGSjs7Ozs7QUFVQW9OLFFBQVExTyxTQUFSLENBQWtCZ1AsV0FBbEIsR0FBZ0MsVUFBUzFOLElBQVQsRUFBZTtNQUN6QyxLQUFLdU4sT0FBVCxFQUFrQjtTQUNYQSxPQUFMLENBQWE5SSxJQUFiLENBQWtCekUsSUFBbEI7O0NBRko7Ozs7O0FBVUFvTixRQUFRMU8sU0FBUixDQUFrQmlQLGFBQWxCLEdBQWtDLFlBQVc7TUFDdkMsS0FBS04sT0FBTCxJQUFnQixLQUFLQSxPQUFMLENBQWF0SSxNQUFiLEdBQXNCLENBQTFDLEVBQTZDO2tCQUM3QnVJLFlBQWQsQ0FBMkIsS0FBS0QsT0FBaEM7OztNQUdFLEtBQUtFLE9BQUwsSUFBZ0IsS0FBS0EsT0FBTCxDQUFheEksTUFBYixHQUFzQixDQUExQyxFQUE2QztrQkFDN0J5SSxZQUFkLENBQTJCLEtBQUtELE9BQWhDOztDQU5KLENBV0E7O0FDdEVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkEsSUFBSUssZUFBZSxLQUFuQjs7Ozs7OztBQVFBLElBQUlDLFNBQVMsS0FBYjs7QUFHQSxBQVlBOzs7OztBQUtBLElBQU1DLHVCQUF1QixTQUF2QkEsb0JBQXVCLENBQVNDLFdBQVQsRUFBc0JDLElBQXRCLEVBQTRCO01BQ25ERCxnQkFBZ0JDLElBQXBCLEVBQTBCOzs7O01BSXRCQyxpQkFBaUJGLFdBQXJCO01BQ01HLFdBQVcsRUFBakI7U0FDT0Qsa0JBQWtCQSxtQkFBbUJELElBQTVDLEVBQWtEO2FBQ3ZDdkosSUFBVCxDQUFjd0osZUFBZXRDLFFBQWYsQ0FBd0J0TSxXQUF4QixFQUFkO3FCQUNpQjRPLGVBQWU3TSxVQUFoQzs7O1FBR0ksSUFBSStNLEtBQUosQ0FBVSx3Q0FDWkQsU0FBU0UsSUFBVCxDQUFjLElBQWQsQ0FERSxDQUFOO0NBWkY7Ozs7OztBQXFCQSxJQUFNQyx3QkFBd0IsU0FBeEJBLHFCQUF3QixDQUFTQyxZQUFULEVBQXVCO01BQy9DVixZQUFKLEVBQWtCO1VBQ1YsSUFBSU8sS0FBSixDQUFVRyxlQUFlLCtCQUFmLEdBQ1osMENBREUsQ0FBTjs7Q0FGSjs7Ozs7O0FBWUEsSUFBTUMsa0JBQWtCLFNBQWxCQSxlQUFrQixDQUFTRCxZQUFULEVBQXVCO01BQ3pDVCxNQUFKLEVBQVk7VUFDSixJQUFJTSxLQUFKLENBQVVHLGVBQWUseUNBQWYsR0FDWix5QkFERSxDQUFOOztDQUZKOzs7Ozs7QUFZQSxJQUFNRSxxQkFBcUIsU0FBckJBLGtCQUFxQixDQUFTRixZQUFULEVBQXVCO01BQzVDLENBQUNWLFlBQUwsRUFBbUI7VUFDWCxJQUFJTyxLQUFKLENBQVVHLGVBQWUsc0NBQWYsR0FDWixxQkFERSxDQUFOOztDQUZKOzs7OztBQVdBLElBQU1HLGdDQUFnQyxTQUFoQ0EsNkJBQWdDLEdBQVc7TUFDM0NiLFlBQUosRUFBa0I7VUFDVixJQUFJTyxLQUFKLENBQVUsbURBQ1oscUJBREUsQ0FBTjs7Q0FGSjs7Ozs7OztBQWFBLElBQU1PLDRCQUE0QixTQUE1QkEseUJBQTRCLENBQVMvQyxRQUFULEVBQW1CaUIsR0FBbkIsRUFBd0I7TUFDcERqQixhQUFhaUIsR0FBakIsRUFBc0I7VUFDZCxJQUFJdUIsS0FBSixDQUFVLCtCQUErQnZCLEdBQS9CLEdBQXFDLFNBQXJDLEdBQ1pqQixRQURZLEdBQ0QsYUFEVCxDQUFOOztDQUZKOzs7Ozs7OztBQWNBLElBQU1nRCw4QkFBOEIsU0FBOUJBLDJCQUE4QixDQUFTTCxZQUFULEVBQXVCTSxZQUF2QixFQUFxQztNQUNuRUEsaUJBQWlCLElBQXJCLEVBQTJCO1VBQ25CLElBQUlULEtBQUosQ0FBVUcsZUFBZSxnQ0FBZixHQUNaLDBDQURFLENBQU47O0NBRko7Ozs7Ozs7Ozs7OztBQWtCQSxJQUFNTyw2QkFBNkIsU0FBN0JBLDBCQUE2QixDQUMvQkMsU0FEK0IsRUFFL0JDLFdBRitCLEVBRy9CQyxnQkFIK0IsRUFJL0JDLGdCQUorQixFQUliO01BQ2RDLGFBQWFILFlBQVl0TixXQUFaLEtBQTRCdU4sZ0JBQTVCLElBQ0FELFlBQVlJLGVBQVosS0FBZ0NGLGdCQURuRDtNQUVNRyxhQUFhTCxZQUFZdE4sV0FBWixLQUE0QnFOLFVBQVVyTixXQUF0QyxJQUNBc04sWUFBWUksZUFBWixLQUFnQ0YsZ0JBRG5EO01BRU1JLGFBQWFOLGdCQUFnQkQsU0FBbkM7O01BRUksQ0FBQ0ksVUFBRCxJQUFlLENBQUNFLFVBQWhCLElBQThCLENBQUNDLFVBQW5DLEVBQStDO1VBQ3ZDLElBQUlsQixLQUFKLENBQVUsNERBQ1oseUJBREUsQ0FBTjs7Q0FaSjs7Ozs7OztBQXVCQSxJQUFNbUIsa0JBQWtCLFNBQWxCQSxlQUFrQixDQUFTMU4sS0FBVCxFQUFnQjtNQUNoQzJOLFdBQVczQixZQUFqQjtpQkFDZWhNLEtBQWY7U0FDTzJOLFFBQVA7Q0FIRjs7Ozs7OztBQVlBLElBQU1DLFlBQVksU0FBWkEsU0FBWSxDQUFTNU4sS0FBVCxFQUFnQjtNQUMxQjJOLFdBQVcxQixNQUFqQjtXQUNTak0sS0FBVDtTQUNPMk4sUUFBUDtDQUhGLENBT0E7O0FDak1BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQSxJQUFNRSxpQkFBaUIsU0FBakJBLGNBQWlCLENBQVN6UCxJQUFULEVBQWU7Ozs7U0FJN0JBLGdCQUFnQjBQLFFBQWhCLElBQTRCMVAsZ0JBQWdCMlAsZ0JBQW5EO0NBSkY7Ozs7Ozs7QUFhQSxJQUFNQyxjQUFjLFNBQWRBLFdBQWMsQ0FBUzVQLElBQVQsRUFBZWdPLElBQWYsRUFBcUI7TUFDakM2QixXQUFXLEVBQWpCO01BQ0lDLE1BQU05UCxJQUFWOztTQUVPOFAsUUFBUTlCLElBQWYsRUFBcUI7YUFDVnZKLElBQVQsQ0FBY3FMLEdBQWQ7VUFDTUEsSUFBSTFPLFVBQVY7OztTQUdLeU8sUUFBUDtDQVRGOzs7Ozs7QUFpQkEsSUFBTUUsVUFBVSxTQUFWQSxPQUFVLENBQVMvUCxJQUFULEVBQWU7TUFDekI4UCxNQUFNOVAsSUFBVjtNQUNJZ1EsT0FBT0YsR0FBWDs7U0FFT0EsR0FBUCxFQUFZO1dBQ0hBLEdBQVA7VUFDTUEsSUFBSTFPLFVBQVY7OztTQUdLNE8sSUFBUDtDQVRGOzs7Ozs7O0FBa0JBLElBQU1DLG1CQUFtQixTQUFuQkEsZ0JBQW1CLENBQVNqUSxJQUFULEVBQWU7TUFDaENnTyxPQUFPK0IsUUFBUS9QLElBQVIsQ0FBYjtTQUNPeVAsZUFBZXpCLElBQWYsSUFBdUJBLEtBQUtrQyxhQUE1QixHQUE0QyxJQUFuRDtDQUZGOzs7Ozs7Ozs7QUFhQSxJQUFNQyxpQkFBaUIsU0FBakJBLGNBQWlCLENBQVNuUSxJQUFULEVBQWVnTyxJQUFmLEVBQXFCO01BQ3BDa0MsZ0JBQWdCRCxpQkFBaUJqUSxJQUFqQixDQUF0Qjs7TUFFSSxDQUFDa1EsYUFBRCxJQUFrQixDQUFDbFEsS0FBS29RLFFBQUwsQ0FBY0YsYUFBZCxDQUF2QixFQUFxRDtXQUM1QyxFQUFQOzs7U0FHS04sWUFBWU0sYUFBWixFQUEyQmxDLElBQTNCLENBQVA7Q0FQRjs7Ozs7Ozs7O0FBa0JBLElBQU1xQyxhQUFhLFNBQWJBLFVBQWEsQ0FBU2pQLFVBQVQsRUFBcUJwQixJQUFyQixFQUEyQnNRLGFBQTNCLEVBQTBDO01BQ3JEQyxzQkFBc0J2USxLQUFLeUIsV0FBakM7TUFDSXFPLE1BQU1RLGFBQVY7O1NBRU9SLFFBQVE5UCxJQUFmLEVBQXFCO1FBQ2J3USxPQUFPVixJQUFJck8sV0FBakI7ZUFDV0YsWUFBWCxDQUF3QnVPLEdBQXhCLEVBQTZCUyxtQkFBN0I7VUFDTUMsSUFBTjs7Q0FQSixDQVlBOztBQ2hIQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSxBQUlBLEFBQ0EsQUFDQSxBQVVBLEFBTUE7QUFDQSxJQUFJaEssVUFBVSxJQUFkOzs7QUFHQSxJQUFJdUksY0FBYyxJQUFsQjs7O0FBR0EsSUFBSTBCLGdCQUFnQixJQUFwQjs7O0FBR0EsSUFBSTVILE1BQU0sSUFBVjs7Ozs7O0FBT0EsSUFBTTZILGNBQWMsU0FBZEEsV0FBYyxDQUFTQyxTQUFULEVBQW9CekUsT0FBcEIsRUFBNkI7T0FDMUMsSUFBSXJILElBQUksQ0FBYixFQUFnQkEsSUFBSThMLFVBQVU1TCxNQUE5QixFQUFzQ0YsS0FBSyxDQUEzQyxFQUE4QztZQUNwQzhMLFVBQVU5TCxDQUFWLENBQVIsRUFBc0JxSCxPQUF0QixHQUFnQ0EsT0FBaEM7O0NBRko7Ozs7Ozs7OztBQWNBLElBQU0wRSxlQUFlLFNBQWZBLFlBQWUsQ0FBU0MsR0FBVCxFQUFjOzs7Ozs7Ozs7OztNQVczQkMsSUFBSSxTQUFKQSxDQUFJLENBQVM5USxJQUFULEVBQWUrUSxFQUFmLEVBQW1Cdk4sSUFBbkIsRUFBeUI7UUFDM0J3TixjQUFjeEssT0FBcEI7UUFDTXlLLFVBQVVwSSxHQUFoQjtRQUNNcUksa0JBQWtCbkMsV0FBeEI7UUFDTW9DLG9CQUFvQlYsYUFBMUI7UUFDSVcsdUJBQXVCLEtBQTNCO1FBQ0lDLGlCQUFpQixLQUFyQjs7Y0FFVSxJQUFJakUsT0FBSixFQUFWO1VBQ01wTixLQUFLOEksYUFBWDtvQkFDZ0I5SSxLQUFLb0IsVUFBckI7O0lBRUksQUFBSixBQUEyQzs2QkFDbEJrTyxnQkFBZ0IsS0FBaEIsQ0FBdkI7dUJBQ2lCRSxVQUFVLEtBQVYsQ0FBakI7OztRQUdJbUIsWUFBWVIsZUFBZW5RLElBQWYsRUFBcUJ5USxhQUFyQixDQUFsQjtnQkFDWUUsU0FBWixFQUF1QixJQUF2QjtRQUNNVyxTQUFTVCxJQUFJN1EsSUFBSixFQUFVK1EsRUFBVixFQUFjdk4sSUFBZCxDQUFmO2dCQUNZbU4sU0FBWixFQUF1QixLQUF2Qjs7SUFFSSxBQUFKLEFBQTJDOztzQkFFekJTLG9CQUFoQjtnQkFDVUMsY0FBVjs7O1lBR00xRCxhQUFSOztjQUVVcUQsV0FBVjtVQUNNQyxPQUFOO2tCQUNjQyxlQUFkO29CQUNnQkMsaUJBQWhCOztXQUVPRyxNQUFQO0dBbkNGO1NBcUNPUixDQUFQO0NBaERGOzs7Ozs7Ozs7Ozs7O0FBK0RBLElBQU1TLGFBQWFYLGFBQWEsVUFBUzVRLElBQVQsRUFBZStRLEVBQWYsRUFBbUJ2TixJQUFuQixFQUF5QjtnQkFDekN4RCxJQUFkOzs7S0FHR3dELElBQUg7OztFQUdJLEFBQUosQUFBMkM7eUJBQ3BCdUwsV0FBckIsRUFBa0MvTyxJQUFsQzs7O1NBR0tBLElBQVA7Q0FYaUIsQ0FBbkI7O0FBZUEsQUFhRSxBQUNBLEFBQ0EsQUFFSSxBQUFKLEFBQTJDLEFBUXZDLEFBQUosQUFBMkMsQUFhN0M7Ozs7Ozs7OztBQVNBLElBQU0wSCxZQUFVLFNBQVZBLFNBQVUsQ0FBUzhKLFNBQVQsRUFBb0I3RixRQUFwQixFQUE4QkMsR0FBOUIsRUFBbUM7TUFDM0NwSSxPQUFPNkksUUFBUW1GLFNBQVIsQ0FBYjs7Ozs7U0FLTzdGLGFBQWFuSSxLQUFLbUksUUFBbEIsSUFBOEJDLE9BQU9wSSxLQUFLb0ksR0FBakQ7Q0FORjs7Ozs7Ozs7O0FBaUJBLElBQU02RixlQUFlLFNBQWZBLFlBQWUsQ0FBUzlGLFFBQVQsRUFBbUJDLEdBQW5CLEVBQXdCO01BQ3ZDbUQsZUFBZXJILFVBQVFxSCxXQUFSLEVBQXFCcEQsUUFBckIsRUFBK0JDLEdBQS9CLENBQW5CLEVBQXdEOzs7O01BSWxEOEYsYUFBYXJGLFFBQVFvRSxhQUFSLENBQW5CO01BQ01rQixrQkFBa0I1QyxlQUFlMUMsUUFBUTBDLFdBQVIsQ0FBdkM7TUFDTS9DLFNBQVMwRixXQUFXMUYsTUFBMUI7TUFDSWhNLGFBQUo7OztNQUdJNEwsR0FBSixFQUFTO1FBQ0RnRyxVQUFVNUYsT0FBT0osR0FBUCxDQUFoQjtRQUNJZ0csT0FBSixFQUFhO1VBQ1BsSyxVQUFRa0ssT0FBUixFQUFpQmpHLFFBQWpCLEVBQTJCQyxHQUEzQixDQUFKLEVBQXFDO2VBQzVCZ0csT0FBUDtPQURGLE1BRU8sSUFBSUEsWUFBWTdDLFdBQWhCLEVBQTZCO2dCQUMxQnJCLFdBQVIsQ0FBb0JrRSxPQUFwQjtPQURLLE1BRUE7c0JBQ09uQixhQUFaLEVBQTJCbUIsT0FBM0IsRUFBb0M1RixNQUFwQzs7Ozs7O01BTUYsQ0FBQ2hNLElBQUwsRUFBVztRQUNMMkwsYUFBYSxPQUFqQixFQUEwQjthQUNqQnNCLFdBQVdwRSxHQUFYLENBQVA7S0FERixNQUVPO2FBQ0U3SCxnQkFBYzZILEdBQWQsRUFBbUI0SCxhQUFuQixFQUFrQzlFLFFBQWxDLEVBQTRDQyxHQUE1QyxDQUFQOzs7UUFHRUEsR0FBSixFQUFTO2FBQ0FBLEdBQVAsSUFBYzVMLElBQWQ7OztZQUdNeU4sV0FBUixDQUFvQnpOLElBQXBCOzs7Ozs7TUFNRXFNLFFBQVFyTSxJQUFSLEVBQWNrTSxPQUFsQixFQUEyQjs7ZUFFZHVFLGFBQVgsRUFBMEJ6USxJQUExQixFQUFnQytPLFdBQWhDO0dBRkYsTUFHTyxJQUFJNEMsbUJBQW1CQSxnQkFBZ0IvRixHQUFuQyxJQUEwQyxDQUFDK0YsZ0JBQWdCekYsT0FBL0QsRUFBd0U7Ozs7a0JBSS9EeEssWUFBZCxDQUEyQjFCLElBQTNCLEVBQWlDK08sV0FBakM7ZUFDVzlDLFdBQVgsR0FBeUIsS0FBekI7R0FMSyxNQU1BO2tCQUNTMUssWUFBZCxDQUEyQnZCLElBQTNCLEVBQWlDK08sV0FBakM7OztnQkFHWS9PLElBQWQ7Q0F2REY7Ozs7Ozs7QUFnRUEsSUFBTXNCLGdCQUFjLFNBQWRBLGFBQWMsQ0FBU3RCLElBQVQsRUFBZXlNLEtBQWYsRUFBc0JULE1BQXRCLEVBQThCO09BQzNDMUssV0FBTCxDQUFpQm1MLEtBQWpCO1VBQ1FpQixXQUFSLHFCQUF3Q2pCLEtBQXhDOztNQUVNYixNQUFNUyxRQUFRSSxLQUFSLEVBQWViLEdBQTNCO01BQ0lBLEdBQUosRUFBUztXQUNBSSxPQUFPSixHQUFQLENBQVA7O0NBTko7Ozs7OztBQWVBLElBQU1pRyxvQkFBb0IsU0FBcEJBLGlCQUFvQixHQUFXO01BQzdCN1IsT0FBT3lRLGFBQWI7TUFDTWpOLE9BQU82SSxRQUFRck0sSUFBUixDQUFiO01BQ01nTSxTQUFTeEksS0FBS3dJLE1BQXBCO01BQ01DLGNBQWN6SSxLQUFLeUksV0FBekI7TUFDSVEsUUFBUXpNLEtBQUs4UixTQUFqQjtNQUNJbEcsWUFBSjs7TUFFSWEsVUFBVXNDLFdBQVYsSUFBeUI5QyxXQUE3QixFQUEwQzs7OztTQUluQ1EsVUFBVXNDLFdBQWpCLEVBQThCO2tCQUNoQi9PLElBQVosRUFBa0J5TSxLQUFsQixFQUF5QlQsTUFBekI7WUFDUWhNLEtBQUs4UixTQUFiOzs7O01BSUUsQ0FBQzdGLFdBQUwsRUFBa0I7U0FDWEwsR0FBTCxJQUFZSSxNQUFaLEVBQW9CO2NBQ1ZBLE9BQU9KLEdBQVAsQ0FBUjtVQUNJYSxNQUFNckwsVUFBTixLQUFxQnBCLElBQXpCLEVBQStCO2dCQUNyQjBOLFdBQVIsQ0FBb0JqQixLQUFwQjtlQUNPVCxPQUFPSixHQUFQLENBQVA7Ozs7U0FJQ0ssV0FBTCxHQUFtQixJQUFuQjs7Q0EzQko7Ozs7O0FBbUNBLElBQU04RixZQUFZLFNBQVpBLFNBQVksR0FBVztrQkFDWGhELFdBQWhCO2dCQUNjLElBQWQ7Q0FGRjs7Ozs7QUFTQSxJQUFNaUQsY0FBYyxTQUFkQSxXQUFjLEdBQVc7TUFDekJqRCxXQUFKLEVBQWlCO1dBQ1JBLFlBQVl0TixXQUFuQjtHQURGLE1BRU87V0FDRWdQLGNBQWMvRCxVQUFyQjs7Q0FKSjs7Ozs7QUFZQSxJQUFNdUYsV0FBVyxTQUFYQSxRQUFXLEdBQVc7Z0JBQ1pELGFBQWQ7Q0FERjs7Ozs7QUFRQSxJQUFNRSxXQUFXLFNBQVhBLFFBQVcsR0FBVzs7O2dCQUdaekIsYUFBZDtrQkFDZ0JBLGNBQWNyUCxVQUE5QjtDQUpGOzs7Ozs7Ozs7Ozs7QUFrQkEsSUFBTStRLGNBQWMsU0FBZEEsV0FBYyxDQUFTdkYsR0FBVCxFQUFjaEIsR0FBZCxFQUFtQjs7ZUFFeEJnQixHQUFiLEVBQWtCaEIsR0FBbEI7O1NBRU8sd0JBQXdCNkU7O0NBSmpDOzs7Ozs7OztBQWNBLElBQU0yQixlQUFlLFNBQWZBLFlBQWUsR0FBVztFQUMxQixBQUFKLEFBQTJDO2NBQy9CLEtBQVY7Ozs7U0FJSyx3QkFBd0JyRDs7Q0FOakM7Ozs7Ozs7O0FBZ0JBLElBQU01QyxPQUFPLFNBQVBBLElBQU8sR0FBVzs7ZUFFVCxPQUFiLEVBQXNCLElBQXRCO1NBQ08scUJBQXFCNEM7O0NBSDlCOztBQU9BLEFBS00sQUFBSixBQUEyQyxBQVE3QyxBQUlNLEFBQUosQUFBMkMsQUFRN0M7Ozs7QUFJQSxJQUFNc0QsT0FBTyxTQUFQQSxJQUFPLEdBQVc7RUFDbEIsQUFBSixBQUEyQztnQ0FDYixNQUE1QixFQUFvQ3RELFdBQXBDO2NBQ1UsSUFBVjs7Z0JBRVkwQixjQUFjcUIsU0FBNUI7Q0FMRixDQVNBLEFBT0E7O0FDdGNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxJQUFNUSxVQUFVO1dBQ0w7Q0FEWCxDQUlBOztBQ3JCQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSxBQUNBLEFBQ0EsQUFNQTs7OztBQUlBLElBQU1DLGVBQWUsU0FBZkEsWUFBZSxDQUFTdFQsSUFBVCxFQUFlO01BQzlCQSxLQUFLdVQsV0FBTCxDQUFpQixNQUFqQixFQUF5QixDQUF6QixNQUFnQyxDQUFwQyxFQUF1QztXQUM5QixzQ0FBUDs7O01BR0V2VCxLQUFLdVQsV0FBTCxDQUFpQixRQUFqQixFQUEyQixDQUEzQixNQUFrQyxDQUF0QyxFQUF5QztXQUNoQyw4QkFBUDs7Q0FOSjs7Ozs7Ozs7OztBQW1CQSxJQUFNQyxZQUFZLFNBQVpBLFNBQVksQ0FBUzFGLEVBQVQsRUFBYTlOLElBQWIsRUFBbUIyQyxLQUFuQixFQUEwQjtNQUN0Q0EsU0FBUyxJQUFiLEVBQW1CO09BQ2RLLGVBQUgsQ0FBbUJoRCxJQUFuQjtHQURGLE1BRU87UUFDQ3lULFNBQVNILGFBQWF0VCxJQUFiLENBQWY7UUFDSXlULE1BQUosRUFBWTtTQUNQQyxjQUFILENBQWtCRCxNQUFsQixFQUEwQnpULElBQTFCLEVBQWdDMkMsS0FBaEM7S0FERixNQUVPO1NBQ0ZELFlBQUgsQ0FBZ0IxQyxJQUFoQixFQUFzQjJDLEtBQXRCOzs7Q0FSTjs7Ozs7Ozs7QUFtQkEsSUFBTWdSLFlBQVksU0FBWkEsU0FBWSxDQUFTN0YsRUFBVCxFQUFhOU4sSUFBYixFQUFtQjJDLEtBQW5CLEVBQTBCO0tBQ3ZDM0MsSUFBSCxJQUFXMkMsS0FBWDtDQURGOzs7Ozs7Ozs7QUFZQSxJQUFNaVIsZ0JBQWdCLFNBQWhCQSxhQUFnQixDQUFTdEosS0FBVCxFQUFnQnhELElBQWhCLEVBQXNCbkUsS0FBdEIsRUFBNkI7TUFDN0NtRSxLQUFLL0QsT0FBTCxDQUFhLEdBQWIsS0FBcUIsQ0FBekIsRUFBNEI7VUFDcEI4USxXQUFOLENBQWtCL00sSUFBbEIsdUJBQThDbkUsS0FBOUM7R0FERixNQUVPO1VBQ0NtRSxJQUFOLElBQWNuRSxLQUFkOztDQUpKOzs7Ozs7Ozs7O0FBaUJBLElBQU1tUixhQUFhLFNBQWJBLFVBQWEsQ0FBU2hHLEVBQVQsRUFBYTlOLElBQWIsRUFBbUJzSyxLQUFuQixFQUEwQjtNQUN2QyxPQUFPQSxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO09BQzFCQSxLQUFILENBQVN5SixPQUFULEdBQW1CekosS0FBbkI7R0FERixNQUVPO09BQ0ZBLEtBQUgsQ0FBU3lKLE9BQVQsR0FBbUIsRUFBbkI7UUFDTUMsVUFBVWxHLEdBQUd4RCxLQUFuQjtRQUNNakwsMkNBQTRDaUwsS0FBbEQ7O1NBRUssSUFBTXhELElBQVgsSUFBbUJ6SCxHQUFuQixFQUF3QjtVQUNsQmlOLElBQUlqTixHQUFKLEVBQVN5SCxJQUFULENBQUosRUFBb0I7c0JBQ0prTixPQUFkLEVBQXVCbE4sSUFBdkIsRUFBNkJ6SCxJQUFJeUgsSUFBSixDQUE3Qjs7OztDQVZSOzs7Ozs7Ozs7O0FBeUJBLElBQU1tTixzQkFBc0IsU0FBdEJBLG1CQUFzQixDQUFTbkcsRUFBVCxFQUFhOU4sSUFBYixFQUFtQjJDLEtBQW5CLEVBQTBCO01BQzlDb0gsY0FBY3BILEtBQWQseUNBQWNBLEtBQWQsQ0FBTjs7TUFFSW9ILFNBQVMsUUFBVCxJQUFxQkEsU0FBUyxVQUFsQyxFQUE4QztjQUNsQytELEVBQVYsRUFBYzlOLElBQWQsRUFBb0IyQyxLQUFwQjtHQURGLE1BRU87Y0FDS21MLEVBQVYsRUFBYzlOLElBQWQseUNBQTREMkMsS0FBNUQ7O0NBTko7Ozs7Ozs7O0FBaUJBLElBQU11UixrQkFBa0IsU0FBbEJBLGVBQWtCLENBQVNwRyxFQUFULEVBQWE5TixJQUFiLEVBQW1CMkMsS0FBbkIsRUFBMEI7TUFDMUM0QixPQUFPNkksUUFBUVUsRUFBUixDQUFiO01BQ01sTCxRQUFRMkIsS0FBSzNCLEtBQW5COztNQUVJQSxNQUFNNUMsSUFBTixNQUFnQjJDLEtBQXBCLEVBQTJCOzs7O01BSXJCd1IsVUFBVTVHLFdBQVd2TixJQUFYLEtBQW9CdU4sV0FBVzhGLFFBQVFqTixPQUFuQixDQUFwQztVQUNRMEgsRUFBUixFQUFZOU4sSUFBWixFQUFrQjJDLEtBQWxCOztRQUVNM0MsSUFBTixJQUFjMkMsS0FBZDtDQVhGOzs7Ozs7QUFtQkEsSUFBTTRLLGFBQWFmLFdBQW5COzs7O0FBSUFlLFdBQVc4RixRQUFRak4sT0FBbkIsSUFBOEI2TixtQkFBOUI7O0FBRUExRyxXQUFXLE9BQVgsSUFBc0J1RyxVQUF0QixDQUdBOztBQ3JLQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSxBQUtBLEFBQ0EsQUFDQSxBQVNBOzs7OztBQUtBLElBQU1NLG9CQUFvQixDQUExQjs7Ozs7OztBQVFBLElBQU1DLGNBQWMsRUFBcEI7Ozs7Ozs7Ozs7Ozs7O0FBZUEsSUFBTW5CLGdCQUFjLFNBQWRBLGFBQWMsQ0FBU3ZGLEdBQVQsRUFBY2hCLEdBQWQsRUFBbUIySCxPQUFuQixFQUE0QkMsUUFBNUIsRUFBc0M7RUFDcEQsQUFBSixBQUEyQzswQkFDbkIsYUFBdEI7b0JBQ2dCLGFBQWhCOzs7TUFHSXhULE9BQU95VCxZQUFnQjdHLEdBQWhCLEVBQXFCaEIsR0FBckIsQ0FBYjtNQUNNcEksT0FBTzZJLFFBQVFyTSxJQUFSLENBQWI7O01BRUksQ0FBQ3dELEtBQUt1SSxjQUFWLEVBQTBCO1FBQ3BCd0gsT0FBSixFQUFhO1dBQ04sSUFBSTFPLEtBQUksQ0FBYixFQUFnQkEsS0FBSTBPLFFBQVF4TyxNQUE1QixFQUFvQ0YsTUFBSyxDQUF6QyxFQUE0QztZQUNwQzVGLDRCQUE2QnNVLFFBQVExTyxFQUFSLENBQW5DO1lBQ01qRCxRQUFRMlIsUUFBUTFPLEtBQUksQ0FBWixDQUFkO3dCQUNnQjdFLElBQWhCLEVBQXNCZixJQUF0QixFQUE0QjJDLEtBQTVCOzs7Ozs7U0FNQ21LLGNBQUwsR0FBc0IsSUFBdEI7Ozs7Ozs7OztNQVNJRixXQUFXckksS0FBS3FJLFFBQXRCO01BQ01DLFdBQVd0SSxLQUFLc0ksUUFBdEI7TUFDTW5CLFFBQVEsQ0FBQ2tCLFNBQVM5RyxNQUF4QjtNQUNJRixJQUFJd08saUJBQVI7TUFDSUssSUFBSSxDQUFSOztTQUVPN08sSUFBSW9GLFVBQVVsRixNQUFyQixFQUE2QkYsS0FBSyxDQUFMLEVBQVE2TyxLQUFLLENBQTFDLEVBQTZDO1FBQ3JDak4sUUFBT3dELFVBQVVwRixDQUFWLENBQWI7UUFDSThGLEtBQUosRUFBVztlQUNBK0ksQ0FBVCxJQUFjak4sS0FBZDtlQUNTQSxLQUFULElBQWlCM0QsU0FBakI7S0FGRixNQUdPLElBQUkrSSxTQUFTNkgsQ0FBVCxNQUFnQmpOLEtBQXBCLEVBQTBCOzs7O1FBSTNCN0UsU0FBUXFJLFVBQVVwRixJQUFJLENBQWQsQ0FBZDtRQUNJOEYsU0FBU2tCLFNBQVM2SCxJQUFJLENBQWIsTUFBb0I5UixNQUFqQyxFQUF3QztlQUM3QjhSLElBQUksQ0FBYixJQUFrQjlSLE1BQWxCO3NCQUNnQjVCLElBQWhCLEVBQXNCeUcsS0FBdEIsRUFBNEI3RSxNQUE1Qjs7OztNQUlBaUQsSUFBSW9GLFVBQVVsRixNQUFkLElBQXdCMk8sSUFBSTdILFNBQVM5RyxNQUF6QyxFQUFpRDtXQUN4Q0YsSUFBSW9GLFVBQVVsRixNQUFyQixFQUE2QkYsS0FBSyxDQUFMLEVBQVE2TyxLQUFLLENBQTFDLEVBQTZDO2VBQ2xDQSxDQUFULElBQWN6SixVQUFVcEYsQ0FBVixDQUFkOzs7UUFHRTZPLElBQUk3SCxTQUFTOUcsTUFBakIsRUFBeUI7ZUFDZEEsTUFBVCxHQUFrQjJPLENBQWxCOzs7Ozs7U0FNRzdPLElBQUksQ0FBVCxFQUFZQSxJQUFJZ0gsU0FBUzlHLE1BQXpCLEVBQWlDRixLQUFLLENBQXRDLEVBQXlDO1VBQ2pDNUYsNkJBQTZCNE0sU0FBU2hILENBQVQsQ0FBbkM7VUFDTWpELFVBQVFpSyxTQUFTaEgsSUFBSSxDQUFiLENBQWQ7ZUFDUzVGLEtBQVQsSUFBaUIyQyxPQUFqQjs7O1NBR0csSUFBTTZFLE1BQVgsSUFBbUJxRixRQUFuQixFQUE2QjtzQkFDWDlMLElBQWhCLEVBQXNCeUcsTUFBdEIsRUFBNEJxRixTQUFTckYsTUFBVCxDQUE1QjtlQUNTQSxNQUFULElBQWlCM0QsU0FBakI7Ozs7U0FJRzlDLElBQVA7Q0EzRUY7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2RkEsSUFBTTJULG1CQUFtQixTQUFuQkEsZ0JBQW1CLENBQVMvRyxHQUFULEVBQWNoQixHQUFkLEVBQW1CMkgsT0FBbkIsRUFBNEI7RUFDL0MsQUFBSixBQUEyQzswQkFDbkIsa0JBQXRCO29CQUNnQixJQUFoQjs7O2NBR1UsQ0FBWixJQUFpQjNHLEdBQWpCO2NBQ1ksQ0FBWixJQUFpQmhCLEdBQWpCO2NBQ1ksQ0FBWixJQUFpQjJILE9BQWpCO0NBUkY7Ozs7Ozs7OztBQW1CQSxJQUFNOU0sT0FBTyxTQUFQQSxJQUFPLENBQVN4SCxJQUFULEVBQWUyQyxLQUFmLEVBQXNCO0VBQzdCLEFBQUosQUFBMkM7dUJBQ3RCLE1BQW5COzs7Y0FHVTZDLElBQVosQ0FBaUJ4RixJQUFqQjtjQUNZd0YsSUFBWixDQUFpQjdDLEtBQWpCO0NBTkY7Ozs7OztBQWNBLElBQU1nUyxpQkFBaUIsU0FBakJBLGNBQWlCLEdBQVc7RUFDNUIsQUFBSixBQUEyQzt1QkFDdEIsZ0JBQW5CO29CQUNnQixLQUFoQjs7O01BR0k1VCxPQUFPbVMsY0FBWTBCLEtBQVosQ0FBa0IsSUFBbEIsRUFBd0JQLFdBQXhCLENBQWI7Y0FDWXZPLE1BQVosR0FBcUIsQ0FBckI7U0FDTy9FLElBQVA7Q0FSRjs7Ozs7Ozs7QUFrQkEsSUFBTW9TLGlCQUFlLFNBQWZBLGNBQWUsQ0FBU3hGLEdBQVQsRUFBYztFQUM3QixBQUFKLEFBQTJDOzBCQUNuQixjQUF0Qjs7O01BR0k1TSxPQUFPOFQsY0FBYjs7RUFFSSxBQUFKLEFBQTJDOzhCQUNmekgsUUFBUXJNLElBQVIsRUFBYzJMLFFBQXhDLEVBQWtEaUIsR0FBbEQ7OztTQUdLNU0sSUFBUDtDQVhGOztBQWVBLEFBZ0JTb1MsQUFJVDs7Ozs7Ozs7O0FBU0EsSUFBTWpHLFNBQU8sU0FBUEEsTUFBTyxDQUFTdkssS0FBVCxFQUFnQjRSLFFBQWhCLEVBQTBCO0VBQ2pDLEFBQUosQUFBMkM7MEJBQ25CLE1BQXRCO29CQUNnQixNQUFoQjs7O01BR0l4VCxPQUFPK1QsTUFBYjtNQUNNdlEsT0FBTzZJLFFBQVFyTSxJQUFSLENBQWI7O01BRUl3RCxLQUFLMkksSUFBTCxLQUFjdkssS0FBbEIsRUFBeUI7U0FDbEJ1SyxJQUFMLHdCQUFrQ3ZLLEtBQWxDOztRQUVJb1MsWUFBWXBTLEtBQWhCO1NBQ0ssSUFBSWlELElBQUksQ0FBYixFQUFnQkEsSUFBSW9GLFVBQVVsRixNQUE5QixFQUFzQ0YsS0FBSyxDQUEzQyxFQUE4Qzs7Ozs7VUFLdENrTSxLQUFLOUcsVUFBVXBGLENBQVYsQ0FBWDtrQkFDWWtNLEdBQUdpRCxTQUFILENBQVo7OztTQUdHeFEsSUFBTCxHQUFZd1EsU0FBWjs7O1NBR0toVSxJQUFQO0NBekJGLENBNkJBOztBQ3JSQTs7Ozs7Ozs7Ozs7Ozs7R0FnQkEsQUFTQSxBQVNBLEFBQ0EsQUFLQSxBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekNBOzs7Ozs7OztBQVFBLEFBQ0EsQUFFQSxBQUlBLEFBRUE7Ozs7Ozs7Ozs7QUFVQSxBQUFPLFNBQVMyRCxRQUFULENBQWdCdEQsT0FBaEIsRUFBeUI0VCxTQUF6QixFQUFvQzlVLE1BQXBDLEVBQTRDO1NBQ3hDSCxTQUFTMkUsTUFBVCxDQUFnQnRELE9BQWhCLEVBQXlCNFQsU0FBekIsRUFBb0M5VSxNQUFwQyxDQUFQOzs7Ozs7Ozs7Ozs7O0FBYUosQUFBTyxTQUFTMEssUUFBVCxDQUFnQjdKLElBQWhCLEVBQXNCaVUsU0FBdEIsRUFBaUNyTixLQUFqQyxFQUF3QztNQUN2QzlHLFVBQVUsSUFBSW1VLFNBQUosRUFBZDtPQUNLLElBQUkzVSxDQUFULElBQWNzSCxLQUFkLEVBQXFCO1lBQ1R0SCxDQUFSLElBQWFzSCxNQUFNdEgsQ0FBTixDQUFiOztNQUVBNEIsV0FBSixDQUFnQmxCLElBQWhCLEVBQXNCRixPQUF0QjtTQUNPQSxPQUFQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1DSixJQUFhb1UsZUFBYjs7Ozs7Ozs7O0VBQW1DekosSUFDL0JJLEtBQUtuSSxLQUFLeVIsV0FBVixDQUQrQixFQUVqQy9KLElBRmlDLENBRy9CZ0IsT0FBT2xKLGNBSHdCLEVBSS9Ca0osT0FBT3pFLGVBSndCLEVBSy9CeUUsT0FBT2pDLFVBTHdCLEVBTS9CaUMsT0FBT25ELFdBTndCLEVBTy9CbUQsT0FBTzFCLGFBUHdCLENBQW5DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7In0="}