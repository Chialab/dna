{"version":3,"file":"dna-custom-elements-v1.js","sources":["node_modules/@dnajs/core/src/lib/typeof.js","node_modules/@dnajs/core/src/lib/registry.js","node_modules/@dnajs/core/src/lib/symbols.js","node_modules/@dnajs/core/src/lib/dom.js","node_modules/@dnajs/core/src/mixins/component.js","node_modules/@dnajs/core/src/polyfills/custom-event.js","node_modules/@dnajs/core/src/lib/dispatch.js","node_modules/@dnajs/core/src/lib/property.js","node_modules/@dnajs/core/src/mixins/properties-component.js","node_modules/@dnajs/core/src/polyfills/matches.js","node_modules/@dnajs/core/src/mixins/events-component.js","node_modules/@dnajs/core/src/lib/style.js","node_modules/@dnajs/core/src/mixins/style-component.js","node_modules/@dnajs/core/src/mixins/template-component.js","node_modules/@dnajs/core/src/polyfills/reduce.js","node_modules/@dnajs/core/src/lib/mixins.js","node_modules/@dnajs/core/src/lib/shim.js","node_modules/@dnajs/core/src/core.js"],"sourcesContent":["/**\n * Check if an value is a function.\n * @method isFunction\n * @memberof! DNA.\n * @static\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isFunction(obj) {\n    return typeof obj === 'function';\n}\n/**\n * Check if an value is a string.\n * @method isString\n * @memberof! DNA.\n * @static\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isString(obj) {\n    return typeof obj === 'string';\n}\n/**\n * Check if an value is an object.\n * @method isObject\n * @memberof! DNA.\n * @static\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isObject(obj) {\n    return Object.prototype.toString.call(obj) === '[object Object]';\n}\n/**\n * Check if an value is undefined.\n * @method isUndefined\n * @memberof! DNA.\n * @static\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isUndefined(obj) {\n    return typeof obj === 'undefined';\n}\n/**\n * Check if an value is an array.\n * @method isArray\n * @memberof! DNA.\n * @static\n *\n * @param {*} obj The value to check.\n * @return {Boolean}\n */\nexport function isArray(obj) {\n    return Array.isArray(obj);\n}\n","import { isFunction, isString } from './typeof.js';\n\n/**\n * A custom components registry.\n * It replicates the [CustomElementRegistry interface](https://www.w3.org/TR/custom-elements/#custom-elements-api).\n * @name registry\n * @namespace registry\n * @memberof! DNA.\n * @static\n */\nexport const registry = {\n    /**\n     * The list of defined components.\n     * @type {Object}\n     */\n    components: {},\n    /**\n     * Register a new component.\n     * @param {String} name The id of the component.\n     * @param {Function} Ctr The component constructor.\n     * @param {Object} config Optional component configuration.\n     */\n    define(name, Ctr, config = {}) {\n        this.components[name.toLowerCase()] = {\n            is: name,\n            Ctr,\n            config,\n        };\n    },\n    /**\n     * Retrieve a component descriptor by id.\n     * @private\n     * @param {String} name The component id.\n     * @return {Object} The component descriptor.\n     */\n    getDescriptor(name) {\n        if (isString(name)) {\n            return this.components[name.toLowerCase()];\n        } else if (isFunction(name)) {\n            for (let k in this.components) {\n                let desc = this.components[k];\n                if (desc.Ctr === name) {\n                    return desc;\n                }\n            }\n        }\n    },\n    /**\n     * Retrieve a component constructor by id.\n     * @param {String} name The component id.\n     * @return {Function} The component constructor.\n     */\n    get(name) {\n        let desc = this.getDescriptor(name);\n        if (desc) {\n            return desc.Ctr;\n        }\n    },\n};\n","export const COMPONENT_SYMBOL = '__component';\n","import { isFunction } from './typeof.js';\nimport { registry } from './registry.js';\nimport { COMPONENT_SYMBOL } from './symbols.js';\n\n/**\n * The `connectedCallback` name.\n * @private\n *\n * @type {String}\n * @see [W3C spec](https://www.w3.org/TR/custom-elements/#custom-element-reactions)\n */\nconst CONNECTED = 'connectedCallback';\n/**\n * The `disconnectedCallback` name.\n * @private\n *\n * @type {String}\n * @see [W3C spec](https://www.w3.org/TR/custom-elements/#custom-element-reactions)\n */\nconst DISCONNECTED = 'disconnectedCallback';\n/**\n * The `attributeChangedCallback` name.\n * @private\n *\n * @type {String}\n * @see [W3C spec](https://www.w3.org/TR/custom-elements/#custom-element-reactions)\n */\nconst UPDATED = 'attributeChangedCallback';\n/**\n * Retrieve a component constructor from an Element or from a tag name.\n * @method getComponent\n * @memberof DNA.DOM\n * @static\n *\n * @param {Component|String} element The element or the tag name.\n * @param {Boolean} full Retrieve full component information.\n * @return {Function} The component constructor for the given param.\n */\nexport function getComponent(element, full = false) {\n    if (element.node) {\n        element = element.node;\n    }\n    if (element.nodeType === Node.ELEMENT_NODE) {\n        element = element.getAttribute('is') || element.tagName;\n    }\n    return full ? registry.getDescriptor(element) : registry.get(element);\n}\n/**\n * Check if a node is an instance of a component.\n * @method isComponent\n * @memberof DNA.DOM\n * @static\n *\n * @param {Component} element The element to check.\n * @return {Boolean}\n */\nexport function isComponent(element) {\n    let Ctr = getComponent(element);\n    return Ctr && (element instanceof Ctr);\n}\n/**\n * An helper for dynamically trigger the `connectedCallback` reaction on components.\n * @method connect\n * @memberof DNA.DOM\n * @static\n *\n * @param {Component} element The attached node.\n * @return {Boolean} The callback has been triggered.\n */\nexport function connect(element) {\n    if (isComponent(element)) {\n        element[CONNECTED].call(element);\n        return true;\n    }\n}\n/**\n * An helper for dynamically trigger the `disconnectedCallback` reaction on components.\n * @method disconnect\n * @memberof DNA.DOM\n * @static\n *\n * @param {Component} element The detached node.\n * @return {Boolean} The callback has been triggered.\n */\nexport function disconnect(element) {\n    if (isComponent(element)) {\n        element[DISCONNECTED].call(element);\n        return true;\n    }\n}\n/**\n * An helper for dynamically trigger the `attributeChangedCallback` reaction on components.\n * @method update\n * @memberof DNA.DOM\n * @static\n *\n * @param {Component} element The updated element.\n * @return {Boolean} The callback has been triggered.\n */\nexport function update(element, name, oldValue, newValue) {\n    if (isComponent(element)) {\n        element[UPDATED].call(element, name, oldValue, newValue);\n        return true;\n    }\n}\n/**\n * Attach a component prototype to an already instantiated HTMLElement.\n * @method bind\n * @memberof DNA.DOM\n * @static\n *\n * @param {HTMLElement} node The node to update.\n * @param {Function} Ctr The component class to use (leave empty for auto detect).\n * @return {Boolean} The prototype has been attached.\n */\nexport function bind(node, Ctr) {\n    if (!isFunction(Ctr)) {\n        Ctr = getComponent(node);\n    }\n    if (isFunction(Ctr)) {\n        node.__proto__ = Ctr.prototype;\n        Object.defineProperty(node, 'constructor', {\n            value: Ctr,\n            configurable: true,\n            writable: true,\n        });\n        Ctr.call(node);\n        return true;\n    }\n    return false;\n}\n/**\n * Create a component instance.\n * @method createElement\n * @memberof DNA.DOM\n * @static\n *\n * @param {String} is The component tag name.\n * @return {HTMLElement} The component instance.\n */\nexport function createElement(is) {\n    let Ctr = getComponent(is);\n    if (Ctr) {\n        return new Ctr();\n    }\n}\n/**\n * Dynamically append a node and call the `connectedCallback`.\n * - disconnect the node if already in the tree\n * - connect the node after the insertion\n * @method appendChild\n * @memberof DNA.DOM\n * @static\n *\n * @param {HTMLElement} parent The parent element.\n * @param {Component} element The element to append.\n * @return {Boolean} The node has been appended.\n */\nexport function appendChild(parent, element) {\n    if (element.node) {\n        let node = element.node;\n        if (parent !== node.parentNode || parent.lastElementChild !== node) {\n            if (node.parentNode) {\n                removeChild(node.parentNode, element);\n            }\n            parent.appendChild(node);\n            return connect(element);\n        }\n    }\n    return false;\n}\n/**\n * Dynamically remove a node and call the `disconnectedCallback`.\n * @method removeChild\n * @memberof DNA.DOM\n * @static\n *\n * @param {HTMLElement} parent The parent element.\n * @param {Component} element The element to remove.\n * @return {Boolean} The node has been removed.\n */\nexport function removeChild(parent, element) {\n    if (element.node) {\n        parent.removeChild(element.node);\n        return disconnect(element);\n    }\n}\n/**\n * Dynamically insert a node before another and call all the reactions.\n * - disconnect the node if already in the tree\n * - connect the node after the insertion\n * @method insertBefore\n * @memberof DNA.DOM\n * @static\n *\n * @param {HTMLElement} parent The parent element.\n * @param {Component} element The element to insert.\n * @param {HTMLElement} refNode The node for positioning.\n * @return {Boolean} The node has been appended.\n */\nexport function insertBefore(parent, element, refNode) {\n    if (element.node) {\n        let node = element.node;\n        if (node.nextSibling !== refNode) {\n            if (node.parentNode) {\n                disconnect(element);\n            }\n            parent.insertBefore(node, refNode);\n            return connect(element);\n        }\n    }\n}\n/**\n * Dynamically replace a node with another and call all the reactions.\n * - disconnect the node if already in the tree\n * - disconnect the replaced node\n * - connect the first node after the insertion\n * @method replaceChild\n * @memberof DNA.DOM\n * @static\n *\n * @param {HTMLElement} parent The parent element.\n * @param {Component} element The element to insert.\n * @param {HTMLElement} refNode The node to replace.\n * @return {Boolean} The node has been appended.\n */\nexport function replaceChild(parent, element, refNode) {\n    if (element.node) {\n        let node = element.node;\n        if (node.parentNode) {\n            disconnect(element);\n        }\n        parent.replaceChild(node, refNode);\n        if (refNode[COMPONENT_SYMBOL]) {\n            disconnect(refNode[COMPONENT_SYMBOL]);\n        }\n        return connect(node);\n    }\n}\n/**\n * Dynamically update a node attribute and call all the reactions.\n * @method setAttribute\n * @memberof DNA.DOM\n * @static\n *\n * @param {Component} element The element to update.\n * @param {String} name The attribute name.\n * @param {String} value The attribute value.\n * @return {Boolean} The node has been updated.\n */\nexport function setAttribute(element, name, value) {\n    if (element.node) {\n        let node = element.node;\n        let oldValue = node.getAttribute(name);\n        node.setAttribute(name, value);\n        let attrs = element.constructor.observedAttributes || [];\n        if (attrs.indexOf(name) !== -1) {\n            return update(element, name, oldValue, value);\n        }\n    }\n}\n/**\n * Dynamically remove a node attribute and call all the reactions.\n * @method removeAttribute\n * @memberof DNA.DOM\n * @static\n *\n * @param {Component} element The element to update.\n * @param {String} name The attribute name.\n * @return {Boolean} The node has been updated.\n */\nexport function removeAttribute(element, name) {\n    if (element.node) {\n        let node = element.node;\n        let oldValue = node.getAttribute(name);\n        node.removeAttribute(name);\n        let attrs = element.constructor.observedAttributes || [];\n        if (attrs.indexOf(name) !== -1) {\n            return update(element, name, oldValue, null);\n        }\n    }\n}\n","import { COMPONENT_SYMBOL } from '../lib/symbols.js';\n\n/**\n * THe base custom component mixins. Just add life cycles callback and `is` getter.\n * @mixin ComponentMixin\n * @memberof DNA.MIXINS\n * @static\n */\nexport const ComponentMixin = (SuperClass) => class extends SuperClass {\n    /**\n     * @property {String} is Get component id.\n     * @name is\n     * @type {String}\n     * @memberof DNA.MIXINS.ComponentMixin\n     * @instance\n     */\n    get is() {\n        return (this.getAttribute('is') || this.localName).toLowerCase();\n    }\n    /**\n     * @property {HTMLElement} node Get component node reference.\n     * @name node\n     * @type {HTMLElement}\n     * @memberof DNA.MIXINS.ComponentMixin\n     * @instance\n     */\n    get node() {\n        return this;\n    }\n    /**\n     * Fires when an instance was inserted into the document.\n     * @method connectedCallback\n     * @memberof DNA.MIXINS.ComponentMixin\n     * @instance\n     */\n    connectedCallback() {\n        this.node[COMPONENT_SYMBOL] = this;\n    }\n    /**\n     * Fires when an instance was detached from the document.\n     * @method disconnectedCallback\n     * @memberof DNA.MIXINS.ComponentMixin\n     * @instance\n     */\n    disconnectedCallback() {}\n    /**\n     * Fires when an attribute was added, removed, or updated.\n     * @method attributeChangedCallback\n     * @memberof DNA.MIXINS.ComponentMixin\n     * @instance\n     *\n     * @param {String} attrName The changed attribute name.\n     * @param {String} oldVal The value of the attribute before the change.\n     * @param {String} newVal The value of the attribute after the change.\n     */\n    attributeChangedCallback() {}\n};\n","let CustomEvent;\n\ntry {\n    // eslint-disable-next-line\n    let ev = new self.CustomEvent('test');\n    CustomEvent = self.CustomEvent;\n} catch(ex) {\n    CustomEvent = function(event, params) {\n        params = params || {\n            bubbles: false,\n            cancelable: false,\n            detail: undefined,\n        };\n        let evt = document.createEvent('CustomEvent');\n        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n        return evt;\n    };\n    CustomEvent.prototype = self.CustomEvent.prototype;\n}\n\nexport { CustomEvent };\n","import { isString } from './typeof.js';\nimport { CustomEvent } from '../polyfills/custom-event.js';\n\n/**\n * Trigger a custom DOM Event.\n * @private\n *\n * @param {Node} node The event target.\n * @param {String} evName The custom event name.\n * @param {Object} data Extra data to pass to the event.\n * @param {Boolean} bubbles Enable event bubbling.\n * @param {Boolean} cancelable Make event cancelable.\n * @return {Boolean} True if event propagation has not be stopped.\n */\nexport function dispatch(node, evName, data, bubbles = true, cancelable = true) {\n    if (!isString(evName)) {\n        throw new TypeError('Event name is undefined');\n    }\n    let ev = new CustomEvent(evName, {\n        detail: data,\n        bubbles,\n        cancelable,\n    });\n    return node.dispatchEvent(ev);\n}\n","import { isUndefined, isFunction, isArray, isObject, isString } from './typeof.js';\n\n/**\n * Shortcut to `Object.defineProperty`.\n * @type {Function}\n * @private\n */\nconst define = Object.defineProperty;\n\n/**\n * Power to the component's properties.\n * Type checking, validation, callbacks, events and attribute syncing.\n * @private\n */\nclass Property {\n    /**\n     * Create a Property instance.\n     * @param {Function|Array} A single or a list of valid constructors for the property value.\n     * @return {Property}\n     */\n    constructor(ctrs) {\n        this._ = [];\n        ctrs = ctrs || [];\n        if (!isArray(ctrs)) {\n            ctrs = [ctrs];\n        }\n        this.ctrs = ctrs;\n        this.validator = () => true;\n        this._setter = (val) => val;\n        this.getterFn = () => this.value;\n        this.setterFn = (val) => {\n            val = this._setter(val);\n            if ((val === null || val === undefined) ||\n                this.validateType(val) && this.validator(val)) {\n                let oldValue = this.value;\n                if (oldValue !== val) {\n                    this.value = val;\n                    this.changed(val, oldValue);\n                }\n            } else {\n                // eslint-disable-next-line\n                throw new TypeError(\n                    `Invalid \\`${val}\\` value for \\`${this.name}\\` property for \\`${this.scope.is}\\`.`\n                );\n            }\n        };\n    }\n    /**\n     * Add a callback when the property changes.\n     * @param {Function} callback The callback to trigger.\n     * @return {Property} The property instance for chaining.\n     */\n    observe(callback) {\n        if (isFunction(callback) || isString(callback)) {\n            this._.push(callback);\n        }\n        return this;\n    }\n    /**\n     * Remove a callback on property changes.\n     * @param {Function} callback The callback to remove.\n     * @return {Property} The property instance for chaining.\n     */\n    unobserve(callback) {\n        let io = this._.indexOf(callback);\n        if (io !== -1) {\n            this._.splice(io, 1);\n        }\n        return this;\n    }\n    /**\n     * Trigger callbacks after a change.\n     * @private\n     * @param {*} newValue The current property value.\n     * @param {*} oldValue The previous property value.\n     */\n    changed(newValue, oldValue) {\n        for (let i = 0, len = this._.length; i < len; i++) {\n            let clb = this._[i];\n            if (isString(clb)) {\n                this.scope[clb].call(this.scope, this, newValue, oldValue);\n            } else {\n                clb(this, newValue, oldValue);\n            }\n        }\n    }\n    /**\n     * Check if a property accepts a given type as value.\n     * @param {Function} Ctr The constructor for the given type.\n     * @return {Boolean}\n     */\n    accepts(Ctr) {\n        return this.ctrs.indexOf(Ctr) !== -1;\n    }\n    /**\n     * Set the property name.\n     * It also set the attrName if `.attribute` method as been previously\n     * invoked without arguments.\n     * @param {String} name The property name.\n     * @return {Property} The property instance for chaining.\n     */\n    named(name) {\n        this.name = name;\n        if (this.attrRequested === true) {\n            this.attrName = this.name;\n        }\n        return this;\n    }\n    /**\n     * Set the property initial value.\n     * @param {*} initValue The property initial value.\n     * @return {Property} The property instance for chaining.\n     */\n    default(initValue) {\n        this.defaultValue = isObject(initValue) ?\n            Object.freeze(initValue) :\n            initValue;\n        return this;\n    }\n    /**\n     * Set the attribute name to sync.\n     * Invoked without arguments, it retrieve the name of the property.\n     * @param {String} attrName The attribute name.\n     * @return {Property} The property instance for chaining.\n     */\n    attribute(attrName = true) {\n        if (isString(attrName)) {\n            this.attrRequested = false;\n            this.attrName = attrName;\n        } else {\n            this.attrRequested = !!attrName;\n            this.attrName = this.name;\n        }\n        return this;\n    }\n    /**\n     * Add a DOM event name to dispatch on changes.\n     * @param {String} evName The event name.\n     * @return {Property} The property instance for chaining.\n     */\n    dispatch(evName) {\n        this.eventName = evName;\n        return this;\n    }\n    /**\n     * Set a getter function for the property.\n     * By default, the property value will be return.\n     * @param {Function} callback The property getter.\n     * @return {Property} The property instance for chaining.\n     */\n    getter(callback) {\n        if (isFunction(callback)) {\n            this.getterFn = () => callback(this.value);\n        }\n        return this;\n    }\n    /**\n     * Set a setter function for the property.\n     * By default, the property value will be updated with given value\n     * without any modification.\n     * @param {Function} callback The property setter.\n     * @return {Property} The property instance for chaining.\n     */\n    setter(callback) {\n        if (isFunction(callback)) {\n            this._setter = callback;\n        }\n        return this;\n    }\n    /**\n     * Set the property validator.\n     * A validator should return `true` if the value is acceptable\n     * or `false` if unaccaptable.\n     * @param {Function} callback The property validtor.\n     * @return {Property} The property instance for chaining.\n     */\n    validate(callback) {\n        if (isFunction(callback)) {\n            this.validator = callback;\n        }\n        return this;\n    }\n    /**\n     * Check if the given value is a valid type.\n     * @private\n     * @param {*} val The value to check.\n     * @return {Boolean}\n     */\n    validateType(val) {\n        let i = 0;\n        let ctrs = this.ctrs;\n        if (ctrs.length === 0) {\n            return true;\n        }\n        while (i < ctrs.length) {\n            if (val instanceof ctrs[i] || (\n                val.constructor && val.constructor === ctrs[i]\n            )) {\n                return true;\n            }\n            i++;\n        }\n        return false;\n    }\n    /**\n     * Attach the property to a scope (a component instance).\n     * Set the default value if provided.\n     * @param {Object} scope The scope which needs to be bound with the property.\n     */\n    init(scope) {\n        this.scope = scope;\n        define(scope, this.name, {\n            get: this.getterFn.bind(this),\n            set: this.setterFn.bind(this),\n            configurable: true,\n        });\n        if (!isUndefined(this.defaultValue)) {\n            scope[this.name] = this.defaultValue;\n        }\n    }\n}\n\n/**\n * Helper method for Property creation.\n * @method prop\n * @memberof! DNA.\n * @static\n *\n * @property {Property} ANY A property without type validation.\n * @property {Property} STRING A property which accepts only strings.\n * @property {Property} BOOLEAN A property which accepts only booleans.\n * @property {Property} NUMBER A property which accepts only numbers.\n *\n * @param {Property|Function|Array} ctrs A Property to clone or a single or a list of valid constructors for the property value.\n * @return {Property} The new property.\n */\nexport function prop(ctrs) {\n    if (ctrs instanceof Property) {\n        return ctrs;\n    }\n    return new Property(ctrs);\n}\n\n// Define some helpers for default types\ndefine(prop, 'ANY', { get() { return prop(); } });\ndefine(prop, 'STRING', { get() { return prop(String); } });\ndefine(prop, 'BOOLEAN', { get() { return prop(Boolean); } });\ndefine(prop, 'NUMBER', { get() { return prop(Number); } });\n","import { isArray } from '../lib/typeof.js';\nimport { dispatch } from '../lib/dispatch.js';\nimport { isUndefined } from '../lib/typeof.js';\nimport { prop } from '../lib/property.js';\n\n/**\n * Try to parse attribute value checking the property validation types.\n * @private\n *\n * @param {Property} property The property to update.\n * @param {String} attrVal The attribute value.\n * @return {*} The parsed value.\n */\nfunction getValue(property, attrVal) {\n    if (attrVal === '' && property.accepts(Boolean)) {\n        return true;\n    }\n    if (!property.accepts(String)) {\n        try {\n            return JSON.parse(attrVal);\n        } catch (ex) {\n            //\n        }\n    }\n    return attrVal;\n}\n\n/**\n * Set an attribute value checking its type.\n * @private\n *\n * @param {HTMLElement} context The node to update.\n * @param {String} attr The attribute name to update.\n * @param {*} value The value to set.\n */\nfunction setAttribute(context, attr, value) {\n    let currentAttrValue = context.getAttribute(attr);\n    if (currentAttrValue !== value) {\n        if (value !== null && value !== undefined && value !== false) {\n            switch (typeof value) {\n            case 'string':\n            case 'number':\n                context.setAttribute(attr, value);\n                break;\n            case 'boolean':\n                context.setAttribute(attr, '');\n            }\n        } else if (currentAttrValue !== null) {\n            context.removeAttribute(attr);\n        }\n    }\n}\n\n/**\n * Simple Custom Component for properties initialization via attributes.\n * @mixin PropertiesMixin\n * @memberof DNA.MIXINS\n * @static\n *\n * @example\n * ```js\n * // my-component.js\n * import { BaseComponent } from '@dnajs/core';\n * export class MyComponent extends BaseComponent {\n *   get properties() {\n *     return { name: String };\n *   }\n * }\n * ```\n * ```js\n * // app.js\n * import { define } from '@dnajs/core';\n * import { MyComponent } from './my-component.js';\n * define('my-component', MyComponent);\n * var temp = document.createElement('div');\n * temp.innerHTML = '<my-component name=\"Albert\"></my-component>';\n * var element = temp.firstChild;\n * console.log(element.name); // logs \"Albert\"\n * ```\n */\nexport const PropertiesMixin = (SuperClass) => class extends SuperClass {\n    /**\n     * Attach properties on component creation.\n     * @method constructor\n     * @memberof DNA.MIXINS.PropertiesMixin\n     * @instance\n     */\n    constructor() {\n        super();\n        let props = this.properties;\n        if (props) {\n            if (!isArray(props)) {\n                props = [props];\n            }\n            props = props.reduce((res, partialProps) => {\n                for (let k in partialProps) {\n                    res[k] = prop(partialProps[k]);\n                }\n                return res;\n            }, {});\n        } else {\n            props = {};\n        }\n        Object.defineProperty(this, 'properties', {\n            value: props,\n            writable: false,\n            configurable: true,\n        });\n        let observed = this.constructor.observedAttributes || [];\n        for (let k in props) {\n            let prop = props[k];\n            prop.named(k).init(this);\n            let { attrName, eventName } = prop;\n            if (!attrName && observed.indexOf(k) !== -1) {\n                prop.attribute();\n                attrName = k;\n            }\n            if (attrName || eventName) {\n                prop.observe(() => {\n                    if (attrName) {\n                        setAttribute(this.node, attrName, this[prop.name]);\n                    }\n                    if (eventName) {\n                        dispatch(this.node, eventName);\n                    }\n                });\n            }\n        }\n    }\n    /**\n     * Sync initial attributes with properties.\n     * @method connectedCallback\n     * @memberof DNA.MIXINS.PropertiesMixin\n     * @instance\n     */\n    connectedCallback() {\n        super.connectedCallback();\n        let props = this.properties;\n        for (let k in props) {\n            let prop = props[k];\n            let { attrName } = prop;\n            if (attrName) {\n                if (isUndefined(this[prop.name])) {\n                    if (this.node.hasAttribute(attrName)) {\n                        this[prop.name] = getValue(prop, this.node.getAttribute(attrName));\n                    }\n                } else {\n                    setAttribute(this.node, attrName, this[prop.name]);\n                }\n            }\n        }\n    }\n    /**\n     * Sync attributes with properties.\n     * @method attributeChangedCallback\n     * @memberof DNA.MIXINS.PropertiesMixin\n     * @instance\n     *\n     * @param {String} attrName The changed attribute name.\n     * @param {String} oldVal The value of the attribute before the change.\n     * @param {String} newVal The value of the attribute after the change.\n     */\n    attributeChangedCallback(attr, oldVal, newVal) {\n        super.attributeChangedCallback(attr, oldVal, newVal);\n        let props = this.properties;\n        for (let k in props) {\n            let prop = props[k];\n            if (prop.attrName === attr) {\n                this[prop.name] = getValue(prop, newVal);\n                return;\n            }\n        }\n    }\n    /**\n     * Create a listener for node's property changes.\n     * @method observeProperty\n     * @memberof DNA.MIXINS.PropertiesMixin\n     * @instance\n     *\n     * @param {string} propName The property name to observe.\n     * @param {Function} callback The callback to fire.\n     * @return {Object} An object with `cancel` method.\n     */\n    observeProperty(propName, callback) {\n        return this.properties[propName].observe(callback);\n    }\n    /**\n     * Remove a listener for node's property changes.\n     * @method unobserveProperty\n     * @memberof DNA.MIXINS.PropertiesMixin\n     * @instance\n     *\n     * @param {string} propName The property name to unobserve.\n     * @param {Function} callback The callback to remove.\n     */\n    unobserveProperty(propName, callback) {\n        this.properties[propName].unobserve(callback);\n    }\n};\n","const ELEM_PROTO = Element.prototype;\n\nexport const matches = ELEM_PROTO.matches ||\n    ELEM_PROTO.matchesSelector ||\n    ELEM_PROTO.mozMatchesSelector ||\n    ELEM_PROTO.msMatchesSelector ||\n    ELEM_PROTO.oMatchesSelector ||\n    ELEM_PROTO.webkitMatchesSelector;\n","import { isString, isFunction } from '../lib/typeof.js';\nimport { matches } from '../polyfills/matches.js';\nimport { dispatch } from '../lib/dispatch.js';\n\nconst SPLIT_SELECTOR = /([^\\s]+)(.*)?/;\n\n/**\n * Simple Custom Component with events delegation,\n * It also implement a `dispatchEvent` wrapper named `trigger`.\n * @mixin EventsMixin\n * @memberof DNA.MIXINS.\n * @static\n *\n * @example\n * ```js\n * // my-component.js\n * import { BaseComponent } from '@dnajs/core';\n * export class MyComponent extends BaseComponent {\n *   get events() {\n *     return {\n *       'click button': 'onButtonClick'\n *     }\n *   }\n *   onButtonClick() {\n *     console.log('button clicked');\n *   }\n * }\n * ```\n * ```js\n * // app.js\n * import { define } from '@dnajs/core';\n * import { MyComponent } from './my-component.js';\n * define('my-component', MyComponent);\n * var element = new MyComponent();\n * var button = document.createElement('button');\n * button.innerText = 'Click me';\n * element.appendChild(button);\n * button.click(); // logs \"button clicked\"\n * ```\n */\nexport const EventsMixin = (SuperClass) => class extends SuperClass {\n    /**\n     * Attach and delegate events to the component.\n     * @method constructor\n     * @memberof DNA.MIXINS.EventsMixin\n     * @instance\n     */\n    constructor() {\n        super();\n        // bind events\n        let events = this.events || {};\n        for (let k in events) {\n            let callback = isString(events[k]) ?\n                this[events[k]] :\n                events[k];\n            if (isFunction(callback)) {\n                let rule = k.match(SPLIT_SELECTOR);\n                let evName = rule[1];\n                let selector = (rule[2] || '').trim();\n                if (selector) {\n                    this.delegate(evName, selector, callback);\n                } else {\n                    this.node.addEventListener(evName, (ev) => {\n                        callback.call(this, ev, this);\n                    });\n                }\n            } else {\n                throw new TypeError('Invalid callback for event.');\n            }\n        }\n    }\n    /**\n     * Delegate events to the component descendents.\n     * @method delegate\n     * @memberof DNA.MIXINS.EventsMixin\n     * @instance\n     *\n     * @param {String} evName The name of the event to delegate.\n     * @param {String} selector A CSS selector for descendents.\n     * @param {Function} callback The callback to fire when the event fires.\n     */\n    delegate(evName, selector, callback) {\n        this.node.addEventListener(evName, (event) => {\n            let target = event.target;\n            while (target && target !== this) {\n                if (matches.call(target, selector)) {\n                    callback.call(this, event, target);\n                }\n                target = target.parentNode;\n            }\n        });\n    }\n    /**\n     * `Node.prototype.dispatchEvent` wrapper.\n     * @method trigger\n     * @memberof DNA.MIXINS.EventsMixin\n     * @instance\n     *\n     * @param {String} evName The name of the event to fire.\n     * @param {Object} data A set of custom data to pass to the event.\n     * @param {Boolean} bubbles Should the event bubble throw the DOM tree.\n     * @param {Boolean} cancelable Can be the event cancel by a callback.\n     * @return {Boolean} True if event propagation has not be stopped.\n     */\n    trigger(evName, data, bubbles = true, cancelable = true) {\n        return dispatch(this, evName, data, bubbles, cancelable);\n    }\n};\n","const rootDoc = document;\n/**\n * Create and attach a style element for a component.\n * @private\n *\n * @param {HTMLElement} node A component instance.\n * @return {HTMLElement} The created style element.\n */\nexport function createStyle(node) {\n    let doc = node.ownerDocument || rootDoc;\n    let styleElem = doc.createElement('style');\n    styleElem.type = 'text/css';\n    styleElem.setAttribute('id', `style-${node.is}`);\n    let head = doc.head;\n    /* istanbul ignore else */\n    if (head.firstElementChild) {\n        head.insertBefore(styleElem, head.firstElementChild);\n    } else {\n        head.appendChild(styleElem);\n    }\n    return styleElem;\n}\n","import { isString } from '../lib/typeof.js';\nimport { createStyle } from '../lib/style.js';\n\n/**\n * Simple Custom Component with css style handling using the `css` property.\n * @mixin StyleMixin\n * @memberof DNA.MIXINS\n * @static\n *\n * @example\n * ```js\n * // my-component.js\n * import { BaseComponent } from '@dnajs/core';\n * export class MyComponent extends BaseComponent {\n *   get css() {\n *     return '.my-component p { color: red; }'\n *   }\n * }\n * ```\n * ```js\n * // app.js\n * import { define } from '@dnajs/core';\n * import { MyComponent } from './my-component.js';\n * define('my-component', MyComponent);\n * var element = new MyComponent();\n * var p = document.createElement('p');\n * p.innerText = 'Paragraph';\n * element.appendChild(p); // text inside `p` gets the red color\n * ```\n */\nexport const StyleMixin = (SuperClass) => class extends SuperClass {\n    /**\n     * Fires when an instance of the element is created.\n     */\n    constructor() {\n        super();\n        if (!this.constructor.styleElem) {\n            let Ctr = this.constructor;\n            Object.defineProperty(Ctr, 'styleElem', {\n                value: createStyle(this),\n            });\n        }\n        this.updateCSS();\n    }\n\n    connectedCallback() {\n        super.connectedCallback();\n        this.node.classList.add(this.is);\n    }\n\n    updateCSS() {\n        let style = this.css;\n        if (isString(style)) {\n            this.constructor.styleElem.textContent = style;\n        }\n    }\n};\n","import { isUndefined, isFunction, isString } from '../lib/typeof.js';\n\n/**\n * Simple Custom Component with template handling using the `template` property.\n * @memberof DNA.MIXINS\n * @mixin TemplateMixin\n * @static\n *\n * @param {Function} SuperClass The class to extend.\n * @return {Function} The extended class.\n *\n * @example\n * ```js\n * // my-component.js\n * import { BaseComponent } from '@dnajs/core';\n * export class MyComponent extends BaseComponent {\n *   get template() {\n *     return `<h1>${this.name}</h1>`;\n *   }\n *   get name() {\n *     return 'Newton';\n *   }\n * }\n * ```\n * ```js\n * // app.js\n * import { define } from '@dnajs/core';\n * import { MyComponent } from './my-component.js';\n * define('my-component', MyComponent);\n * var element = new MyComponent();\n * console.log(element.innerHTML); // logs \"<h1>Newton</h1>\"\n * ```\n */\nexport const TemplateMixin = (SuperClass) => class extends SuperClass {\n    /**\n     * @property {Boolean} autoRender Should the component re-render on properties changes.\n     * @name autoRender\n     * @type {Boolean}\n     * @memberof DNA.MIXINS.TemplateMixin\n     * @instance\n     */\n    get autoRender() {\n        return true;\n    }\n    /**\n     * Attach properties observers in order to update children.\n     * @method constructor\n     * @memberof DNA.MIXINS.TemplateMixin\n     * @instance\n     */\n    constructor() {\n        super();\n        if (this.autoRender && !isUndefined(this.template)) {\n            let props = this.properties;\n            if (props) {\n                let callback = () => {\n                    this.render();\n                };\n                for (let k in props) {\n                    props[k].observe(callback);\n                }\n            }\n        }\n    }\n    /**\n     * Render the component when connected.\n     * @method connectedCallback\n     * @memberof DNA.MIXINS.TemplateMixin\n     * @instance\n     */\n    connectedCallback() {\n        super.connectedCallback();\n        if (!isUndefined(this.template)) {\n            this.render();\n        }\n    }\n    /**\n     * Update Component child nodes.\n     * @method render\n     * @memberof DNA.MIXINS.TemplateMixin\n     * @instance\n     *\n     * @param {Function|string} tpl A template to use instead of `this.template`.\n     *\n     * @throws {TypeError} Will throw if the template type is not supported.\n     */\n    render(tpl) {\n        tpl = tpl || this.template;\n        if (isFunction(tpl)) {\n            tpl.call(this);\n        } else if (isString(tpl)) {\n            this.node.innerHTML = tpl;\n        } else {\n            throw new TypeError('Invalid template property.');\n        }\n    }\n};\n","/* eslint-disable prefer-rest-params */\nexport const reduce = Array.prototype.reduce || function(callback /*, initialValue*/ ) {\n    'use strict';\n    let t = this;\n    let len = t.length;\n    let k = 0;\n    let value;\n    if (arguments.length === 2) {\n        value = arguments[1];\n    } else {\n        while (k < len && !(k in t)) {\n            k++;\n        }\n        value = t[k++];\n    }\n    for (; k < len; k++) {\n        if (k in t) {\n            value = callback(value, t[k], k, t);\n        }\n    }\n    return value;\n};\n","/**\n * @author Justin Fagnani\n * @see https://github.com/justinfagnani/mixwith.js\n */\nimport { reduce } from '../polyfills/reduce.js';\n\n/**\n * Mix a class with a mixin.\n * @method mix(...).with(...)\n * @memberof! DNA.\n * @static\n *\n * @param {Function} superClass The class to extend.\n * @return {Function} A mixed class.\n *\n * @example\n * ```js\n * // my-super.js\n * export class MySuperClass {\n *     constructor() {\n *         // do something\n *     }\n * }\n * ```\n * ```js\n * // mixin.js\n * export const Mixin = (superClass) => class extend superClass {\n *     constructor() {\n *         super();\n *         // do something else\n *     }\n * };\n * ```\n * ```js\n * import { mix } from '@dnajs/core';\n * import { MySuperClass } from './my-super.js';\n * import { Mixin } from './mixin.js';\n *\n * export class MixedClass extends mix(MySuperClass).with(Mixin) {\n *     ...\n * }\n * ```\n */\n\n/**\n * A Mixin helper class.\n * @ignore\n */\nclass Mixin {\n    /**\n     * Create a mixable class.\n     * @param {Function} superClass The class to extend.\n     */\n    constructor(superclass) {\n        superclass = superclass || class {};\n        this.superclass = superclass;\n    }\n    /**\n     * Mix the super class with a list of mixins.\n     * @param {...Function} mixins *N* mixin functions.\n     * @return {Function} The extended class.\n     */\n    with() {\n        // eslint-disable-next-line\n        let args = [].slice.call(arguments, 0);\n        return reduce.call(args, (c, mixin) => mixin(c), this.superclass);\n    }\n}\n\n/**\n * Create a Mixin instance.\n * @ignore\n */\nexport const mix = (superClass) => new Mixin(superClass);\n","import { registry } from './registry.js';\nimport { isString } from './typeof.js';\n\n/**\n * Check if a node is already instantiated HTMLElement for programmatically `constructor` calls.\n * @private\n * @param {HTMLElement} node The node to check.\n * @return {Boolean} The node should be instantiated.\n */\nfunction isNew(node) {\n    try {\n        return !isString(node.outerHTML);\n    } catch (ex) {\n        return true;\n    }\n}\n\n/**\n * Shim original Element constructors in order to be used with `new`.\n * @method shim\n * @memberof! DNA.\n * @static\n *\n * @param {Function} Original The original constructor to shim.\n * @return {Function} The shimmed constructor.\n *\n * @example\n * ```js\n * // shim audio element\n * import { shim } from '@dnajs/core';\n *\n * class MyAudio extends shim(HTMLAudioElement) {\n *     ...\n * }\n *\n * let audio = new MyAudio();\n * ```\n */\nexport function shim(Original) {\n    class Polyfilled {\n        constructor() {\n            if (!isNew(this)) {\n                return this;\n            }\n            let desc = registry.getDescriptor(this.constructor);\n            let config = desc.config;\n            // Find the tagname of the constructor and create a new element with it\n            let element = document.createElement(\n                config.extends ? config.extends : desc.is\n            );\n            element.__proto__ = desc.Ctr.prototype;\n            if (config.extends) {\n                element.setAttribute('is', desc.is);\n            }\n            return element;\n        }\n    }\n    // Clone the prototype overriding the constructor.\n    Polyfilled.prototype = Object.create(Original.prototype, {\n        constructor: {\n            value: Polyfilled,\n            configurable: true,\n            writable: true,\n        },\n    });\n    return Polyfilled;\n}\n","import * as DOM_HELPERS from './lib/dom.js';\nimport { ComponentMixin } from './mixins/component.js';\nimport { PropertiesMixin } from './mixins/properties-component.js';\nimport { EventsMixin } from './mixins/events-component.js';\nimport { StyleMixin } from './mixins/style-component.js';\nimport { TemplateMixin } from './mixins/template-component.js';\n\n/**\n * A set of DOM helpers for callbacks trigger when Custom Elements\n * are not supported by the browser.\n * @name DOM\n * @namespace DOM\n * @memberof! DNA.\n * @static\n */\nexport const DOM = DOM_HELPERS;\n/**\n * A set of core mixins.\n * @name MIXINS\n * @namespace MIXINS\n * @memberof! DNA.\n * @static\n */\nexport const MIXINS = {\n    ComponentMixin,\n    PropertiesMixin,\n    EventsMixin,\n    StyleMixin,\n    TemplateMixin,\n};\nexport { mix } from './lib/mixins.js';\nexport { prop } from './lib/property.js';\nexport { shim } from './lib/shim.js';\nexport * from './lib/symbols.js';\nexport * from './lib/typeof.js';\n"],"names":["isFunction","obj","isString","isObject","Object","prototype","toString","call","isUndefined","isArray","Array","registry","name","Ctr","config","components","toLowerCase","k","desc","getDescriptor","COMPONENT_SYMBOL","getComponent","element","full","node","nodeType","Node","ELEMENT_NODE","getAttribute","tagName","get","ComponentMixin","SuperClass","connectedCallback","disconnectedCallback","attributeChangedCallback","localName","CustomEvent","ev","self","ex","event","params","undefined","evt","document","createEvent","initCustomEvent","bubbles","cancelable","detail","dispatch","evName","data","TypeError","dispatchEvent","define","defineProperty","Property","ctrs","_","validator","_setter","val","getterFn","value","setterFn","validateType","oldValue","changed","scope","is","observe","callback","push","unobserve","io","indexOf","splice","newValue","i","len","length","clb","accepts","named","attrRequested","attrName","default","initValue","defaultValue","freeze","attribute","eventName","getter","setter","validate","constructor","init","bind","prop","String","Boolean","Number","getValue","property","attrVal","JSON","parse","setAttribute","context","attr","currentAttrValue","removeAttribute","PropertiesMixin","props","properties","reduce","res","partialProps","observed","observedAttributes","hasAttribute","oldVal","newVal","observeProperty","propName","unobserveProperty","ELEM_PROTO","Element","matches","matchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","SPLIT_SELECTOR","EventsMixin","events","rule","match","selector","trim","delegate","addEventListener","target","parentNode","trigger","rootDoc","createStyle","doc","ownerDocument","styleElem","createElement","type","head","firstElementChild","insertBefore","appendChild","StyleMixin","updateCSS","classList","add","style","css","textContent","TemplateMixin","autoRender","template","render","tpl","innerHTML","t","arguments","Mixin","superclass","with","args","slice","c","mixin","mix","superClass","isNew","outerHTML","MIXINS"],"mappings":"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","preExisting":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbIi9Vc2Vycy9lZG9hcmRvL0RldmVsb3BtZW50L2RuYS9kbmEtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvQGRuYWpzL2NvcmUvc3JjL2xpYi90eXBlb2YuanMiLCIvVXNlcnMvZWRvYXJkby9EZXZlbG9wbWVudC9kbmEvZG5hLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL0BkbmFqcy9jb3JlL3NyYy9saWIvcmVnaXN0cnkuanMiLCIvVXNlcnMvZWRvYXJkby9EZXZlbG9wbWVudC9kbmEvZG5hLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL0BkbmFqcy9jb3JlL3NyYy9saWIvc3ltYm9scy5qcyIsIi9Vc2Vycy9lZG9hcmRvL0RldmVsb3BtZW50L2RuYS9kbmEtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvQGRuYWpzL2NvcmUvc3JjL2xpYi9kb20uanMiLCIvVXNlcnMvZWRvYXJkby9EZXZlbG9wbWVudC9kbmEvZG5hLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL0BkbmFqcy9jb3JlL3NyYy9taXhpbnMvY29tcG9uZW50LmpzIiwiL1VzZXJzL2Vkb2FyZG8vRGV2ZWxvcG1lbnQvZG5hL2RuYS1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9AZG5hanMvY29yZS9zcmMvcG9seWZpbGxzL2N1c3RvbS1ldmVudC5qcyIsIi9Vc2Vycy9lZG9hcmRvL0RldmVsb3BtZW50L2RuYS9kbmEtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvQGRuYWpzL2NvcmUvc3JjL2xpYi9kaXNwYXRjaC5qcyIsIi9Vc2Vycy9lZG9hcmRvL0RldmVsb3BtZW50L2RuYS9kbmEtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvQGRuYWpzL2NvcmUvc3JjL2xpYi9wcm9wZXJ0eS5qcyIsIi9Vc2Vycy9lZG9hcmRvL0RldmVsb3BtZW50L2RuYS9kbmEtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvQGRuYWpzL2NvcmUvc3JjL21peGlucy9wcm9wZXJ0aWVzLWNvbXBvbmVudC5qcyIsIi9Vc2Vycy9lZG9hcmRvL0RldmVsb3BtZW50L2RuYS9kbmEtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvQGRuYWpzL2NvcmUvc3JjL3BvbHlmaWxscy9tYXRjaGVzLmpzIiwiL1VzZXJzL2Vkb2FyZG8vRGV2ZWxvcG1lbnQvZG5hL2RuYS1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9AZG5hanMvY29yZS9zcmMvbWl4aW5zL2V2ZW50cy1jb21wb25lbnQuanMiLCIvVXNlcnMvZWRvYXJkby9EZXZlbG9wbWVudC9kbmEvZG5hLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL0BkbmFqcy9jb3JlL3NyYy9saWIvc3R5bGUuanMiLCIvVXNlcnMvZWRvYXJkby9EZXZlbG9wbWVudC9kbmEvZG5hLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL0BkbmFqcy9jb3JlL3NyYy9taXhpbnMvc3R5bGUtY29tcG9uZW50LmpzIiwiL1VzZXJzL2Vkb2FyZG8vRGV2ZWxvcG1lbnQvZG5hL2RuYS1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9AZG5hanMvY29yZS9zcmMvbWl4aW5zL3RlbXBsYXRlLWNvbXBvbmVudC5qcyIsIi9Vc2Vycy9lZG9hcmRvL0RldmVsb3BtZW50L2RuYS9kbmEtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvQGRuYWpzL2NvcmUvc3JjL3BvbHlmaWxscy9yZWR1Y2UuanMiLCIvVXNlcnMvZWRvYXJkby9EZXZlbG9wbWVudC9kbmEvZG5hLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL0BkbmFqcy9jb3JlL3NyYy9saWIvbWl4aW5zLmpzIiwiL1VzZXJzL2Vkb2FyZG8vRGV2ZWxvcG1lbnQvZG5hL2RuYS1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9AZG5hanMvY29yZS9zcmMvbGliL3NoaW0uanMiLCIvVXNlcnMvZWRvYXJkby9EZXZlbG9wbWVudC9kbmEvZG5hLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL0BkbmFqcy9jb3JlL3NyYy9jb3JlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2hlY2sgaWYgYW4gdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAqIEBtZXRob2QgaXNGdW5jdGlvblxuICogQG1lbWJlcm9mISBETkEuXG4gKiBAc3RhdGljXG4gKlxuICogQHBhcmFtIHsqfSBvYmogVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIENoZWNrIGlmIGFuIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQG1ldGhvZCBpc1N0cmluZ1xuICogQG1lbWJlcm9mISBETkEuXG4gKiBAc3RhdGljXG4gKlxuICogQHBhcmFtIHsqfSBvYmogVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJztcbn1cbi8qKlxuICogQ2hlY2sgaWYgYW4gdmFsdWUgaXMgYW4gb2JqZWN0LlxuICogQG1ldGhvZCBpc09iamVjdFxuICogQG1lbWJlcm9mISBETkEuXG4gKiBAc3RhdGljXG4gKlxuICogQHBhcmFtIHsqfSBvYmogVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG4vKipcbiAqIENoZWNrIGlmIGFuIHZhbHVlIGlzIHVuZGVmaW5lZC5cbiAqIEBtZXRob2QgaXNVbmRlZmluZWRcbiAqIEBtZW1iZXJvZiEgRE5BLlxuICogQHN0YXRpY1xuICpcbiAqIEBwYXJhbSB7Kn0gb2JqIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1VuZGVmaW5lZChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCc7XG59XG4vKipcbiAqIENoZWNrIGlmIGFuIHZhbHVlIGlzIGFuIGFycmF5LlxuICogQG1ldGhvZCBpc0FycmF5XG4gKiBAbWVtYmVyb2YhIEROQS5cbiAqIEBzdGF0aWNcbiAqXG4gKiBAcGFyYW0geyp9IG9iaiBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopO1xufVxuIiwiaW1wb3J0IHsgaXNGdW5jdGlvbiwgaXNTdHJpbmcgfSBmcm9tICcuL3R5cGVvZi5qcyc7XG5cbi8qKlxuICogQSBjdXN0b20gY29tcG9uZW50cyByZWdpc3RyeS5cbiAqIEl0IHJlcGxpY2F0ZXMgdGhlIFtDdXN0b21FbGVtZW50UmVnaXN0cnkgaW50ZXJmYWNlXShodHRwczovL3d3dy53My5vcmcvVFIvY3VzdG9tLWVsZW1lbnRzLyNjdXN0b20tZWxlbWVudHMtYXBpKS5cbiAqIEBuYW1lIHJlZ2lzdHJ5XG4gKiBAbmFtZXNwYWNlIHJlZ2lzdHJ5XG4gKiBAbWVtYmVyb2YhIEROQS5cbiAqIEBzdGF0aWNcbiAqL1xuZXhwb3J0IGNvbnN0IHJlZ2lzdHJ5ID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSBsaXN0IG9mIGRlZmluZWQgY29tcG9uZW50cy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGNvbXBvbmVudHM6IHt9LFxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgbmV3IGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgaWQgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdHIgVGhlIGNvbXBvbmVudCBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIE9wdGlvbmFsIGNvbXBvbmVudCBjb25maWd1cmF0aW9uLlxuICAgICAqL1xuICAgIGRlZmluZShuYW1lLCBDdHIsIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50c1tuYW1lLnRvTG93ZXJDYXNlKCldID0ge1xuICAgICAgICAgICAgaXM6IG5hbWUsXG4gICAgICAgICAgICBDdHIsXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhIGNvbXBvbmVudCBkZXNjcmlwdG9yIGJ5IGlkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGNvbXBvbmVudCBpZC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb21wb25lbnQgZGVzY3JpcHRvci5cbiAgICAgKi9cbiAgICBnZXREZXNjcmlwdG9yKG5hbWUpIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRzW25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihuYW1lKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgayBpbiB0aGlzLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGVzYyA9IHRoaXMuY29tcG9uZW50c1trXTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzYy5DdHIgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBieSBpZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgY29tcG9uZW50IGlkLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY29tcG9uZW50IGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGdldChuYW1lKSB7XG4gICAgICAgIGxldCBkZXNjID0gdGhpcy5nZXREZXNjcmlwdG9yKG5hbWUpO1xuICAgICAgICBpZiAoZGVzYykge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2MuQ3RyO1xuICAgICAgICB9XG4gICAgfSxcbn07XG4iLCJleHBvcnQgY29uc3QgQ09NUE9ORU5UX1NZTUJPTCA9ICdfX2NvbXBvbmVudCc7XG4iLCJpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi90eXBlb2YuanMnO1xuaW1wb3J0IHsgcmVnaXN0cnkgfSBmcm9tICcuL3JlZ2lzdHJ5LmpzJztcbmltcG9ydCB7IENPTVBPTkVOVF9TWU1CT0wgfSBmcm9tICcuL3N5bWJvbHMuanMnO1xuXG4vKipcbiAqIFRoZSBgY29ubmVjdGVkQ2FsbGJhY2tgIG5hbWUuXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAc2VlIFtXM0Mgc3BlY10oaHR0cHM6Ly93d3cudzMub3JnL1RSL2N1c3RvbS1lbGVtZW50cy8jY3VzdG9tLWVsZW1lbnQtcmVhY3Rpb25zKVxuICovXG5jb25zdCBDT05ORUNURUQgPSAnY29ubmVjdGVkQ2FsbGJhY2snO1xuLyoqXG4gKiBUaGUgYGRpc2Nvbm5lY3RlZENhbGxiYWNrYCBuYW1lLlxuICogQHByaXZhdGVcbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQHNlZSBbVzNDIHNwZWNdKGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jdXN0b20tZWxlbWVudHMvI2N1c3RvbS1lbGVtZW50LXJlYWN0aW9ucylcbiAqL1xuY29uc3QgRElTQ09OTkVDVEVEID0gJ2Rpc2Nvbm5lY3RlZENhbGxiYWNrJztcbi8qKlxuICogVGhlIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgIG5hbWUuXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAc2VlIFtXM0Mgc3BlY10oaHR0cHM6Ly93d3cudzMub3JnL1RSL2N1c3RvbS1lbGVtZW50cy8jY3VzdG9tLWVsZW1lbnQtcmVhY3Rpb25zKVxuICovXG5jb25zdCBVUERBVEVEID0gJ2F0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayc7XG4vKipcbiAqIFJldHJpZXZlIGEgY29tcG9uZW50IGNvbnN0cnVjdG9yIGZyb20gYW4gRWxlbWVudCBvciBmcm9tIGEgdGFnIG5hbWUuXG4gKiBAbWV0aG9kIGdldENvbXBvbmVudFxuICogQG1lbWJlcm9mIEROQS5ET01cbiAqIEBzdGF0aWNcbiAqXG4gKiBAcGFyYW0ge0NvbXBvbmVudHxTdHJpbmd9IGVsZW1lbnQgVGhlIGVsZW1lbnQgb3IgdGhlIHRhZyBuYW1lLlxuICogQHBhcmFtIHtCb29sZWFufSBmdWxsIFJldHJpZXZlIGZ1bGwgY29tcG9uZW50IGluZm9ybWF0aW9uLlxuICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBjb21wb25lbnQgY29uc3RydWN0b3IgZm9yIHRoZSBnaXZlbiBwYXJhbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbXBvbmVudChlbGVtZW50LCBmdWxsID0gZmFsc2UpIHtcbiAgICBpZiAoZWxlbWVudC5ub2RlKSB7XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50Lm5vZGU7XG4gICAgfVxuICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lzJykgfHwgZWxlbWVudC50YWdOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gZnVsbCA/IHJlZ2lzdHJ5LmdldERlc2NyaXB0b3IoZWxlbWVudCkgOiByZWdpc3RyeS5nZXQoZWxlbWVudCk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgbm9kZSBpcyBhbiBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudC5cbiAqIEBtZXRob2QgaXNDb21wb25lbnRcbiAqIEBtZW1iZXJvZiBETkEuRE9NXG4gKiBAc3RhdGljXG4gKlxuICogQHBhcmFtIHtDb21wb25lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDb21wb25lbnQoZWxlbWVudCkge1xuICAgIGxldCBDdHIgPSBnZXRDb21wb25lbnQoZWxlbWVudCk7XG4gICAgcmV0dXJuIEN0ciAmJiAoZWxlbWVudCBpbnN0YW5jZW9mIEN0cik7XG59XG4vKipcbiAqIEFuIGhlbHBlciBmb3IgZHluYW1pY2FsbHkgdHJpZ2dlciB0aGUgYGNvbm5lY3RlZENhbGxiYWNrYCByZWFjdGlvbiBvbiBjb21wb25lbnRzLlxuICogQG1ldGhvZCBjb25uZWN0XG4gKiBAbWVtYmVyb2YgRE5BLkRPTVxuICogQHN0YXRpY1xuICpcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBlbGVtZW50IFRoZSBhdHRhY2hlZCBub2RlLlxuICogQHJldHVybiB7Qm9vbGVhbn0gVGhlIGNhbGxiYWNrIGhhcyBiZWVuIHRyaWdnZXJlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbm5lY3QoZWxlbWVudCkge1xuICAgIGlmIChpc0NvbXBvbmVudChlbGVtZW50KSkge1xuICAgICAgICBlbGVtZW50W0NPTk5FQ1RFRF0uY2FsbChlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBoZWxwZXIgZm9yIGR5bmFtaWNhbGx5IHRyaWdnZXIgdGhlIGBkaXNjb25uZWN0ZWRDYWxsYmFja2AgcmVhY3Rpb24gb24gY29tcG9uZW50cy5cbiAqIEBtZXRob2QgZGlzY29ubmVjdFxuICogQG1lbWJlcm9mIEROQS5ET01cbiAqIEBzdGF0aWNcbiAqXG4gKiBAcGFyYW0ge0NvbXBvbmVudH0gZWxlbWVudCBUaGUgZGV0YWNoZWQgbm9kZS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRoZSBjYWxsYmFjayBoYXMgYmVlbiB0cmlnZ2VyZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNjb25uZWN0KGVsZW1lbnQpIHtcbiAgICBpZiAoaXNDb21wb25lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgZWxlbWVudFtESVNDT05ORUNURURdLmNhbGwoZWxlbWVudCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbi8qKlxuICogQW4gaGVscGVyIGZvciBkeW5hbWljYWxseSB0cmlnZ2VyIHRoZSBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCByZWFjdGlvbiBvbiBjb21wb25lbnRzLlxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBtZW1iZXJvZiBETkEuRE9NXG4gKiBAc3RhdGljXG4gKlxuICogQHBhcmFtIHtDb21wb25lbnR9IGVsZW1lbnQgVGhlIHVwZGF0ZWQgZWxlbWVudC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRoZSBjYWxsYmFjayBoYXMgYmVlbiB0cmlnZ2VyZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGUoZWxlbWVudCwgbmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgaWYgKGlzQ29tcG9uZW50KGVsZW1lbnQpKSB7XG4gICAgICAgIGVsZW1lbnRbVVBEQVRFRF0uY2FsbChlbGVtZW50LCBuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4vKipcbiAqIEF0dGFjaCBhIGNvbXBvbmVudCBwcm90b3R5cGUgdG8gYW4gYWxyZWFkeSBpbnN0YW50aWF0ZWQgSFRNTEVsZW1lbnQuXG4gKiBAbWV0aG9kIGJpbmRcbiAqIEBtZW1iZXJvZiBETkEuRE9NXG4gKiBAc3RhdGljXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBUaGUgbm9kZSB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdHIgVGhlIGNvbXBvbmVudCBjbGFzcyB0byB1c2UgKGxlYXZlIGVtcHR5IGZvciBhdXRvIGRldGVjdCkuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUaGUgcHJvdG90eXBlIGhhcyBiZWVuIGF0dGFjaGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZChub2RlLCBDdHIpIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oQ3RyKSkge1xuICAgICAgICBDdHIgPSBnZXRDb21wb25lbnQobm9kZSk7XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uKEN0cikpIHtcbiAgICAgICAgbm9kZS5fX3Byb3RvX18gPSBDdHIucHJvdG90eXBlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgJ2NvbnN0cnVjdG9yJywge1xuICAgICAgICAgICAgdmFsdWU6IEN0cixcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgQ3RyLmNhbGwobm9kZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIENyZWF0ZSBhIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAqIEBtZXRob2QgY3JlYXRlRWxlbWVudFxuICogQG1lbWJlcm9mIEROQS5ET01cbiAqIEBzdGF0aWNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaXMgVGhlIGNvbXBvbmVudCB0YWcgbmFtZS5cbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBUaGUgY29tcG9uZW50IGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudChpcykge1xuICAgIGxldCBDdHIgPSBnZXRDb21wb25lbnQoaXMpO1xuICAgIGlmIChDdHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDdHIoKTtcbiAgICB9XG59XG4vKipcbiAqIER5bmFtaWNhbGx5IGFwcGVuZCBhIG5vZGUgYW5kIGNhbGwgdGhlIGBjb25uZWN0ZWRDYWxsYmFja2AuXG4gKiAtIGRpc2Nvbm5lY3QgdGhlIG5vZGUgaWYgYWxyZWFkeSBpbiB0aGUgdHJlZVxuICogLSBjb25uZWN0IHRoZSBub2RlIGFmdGVyIHRoZSBpbnNlcnRpb25cbiAqIEBtZXRob2QgYXBwZW5kQ2hpbGRcbiAqIEBtZW1iZXJvZiBETkEuRE9NXG4gKiBAc3RhdGljXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50IFRoZSBwYXJlbnQgZWxlbWVudC5cbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGFwcGVuZC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRoZSBub2RlIGhhcyBiZWVuIGFwcGVuZGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kQ2hpbGQocGFyZW50LCBlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQubm9kZSkge1xuICAgICAgICBsZXQgbm9kZSA9IGVsZW1lbnQubm9kZTtcbiAgICAgICAgaWYgKHBhcmVudCAhPT0gbm9kZS5wYXJlbnROb2RlIHx8IHBhcmVudC5sYXN0RWxlbWVudENoaWxkICE9PSBub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2hpbGQobm9kZS5wYXJlbnROb2RlLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0KGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogRHluYW1pY2FsbHkgcmVtb3ZlIGEgbm9kZSBhbmQgY2FsbCB0aGUgYGRpc2Nvbm5lY3RlZENhbGxiYWNrYC5cbiAqIEBtZXRob2QgcmVtb3ZlQ2hpbGRcbiAqIEBtZW1iZXJvZiBETkEuRE9NXG4gKiBAc3RhdGljXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50IFRoZSBwYXJlbnQgZWxlbWVudC5cbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRoZSBub2RlIGhhcyBiZWVuIHJlbW92ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDaGlsZChwYXJlbnQsIGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5ub2RlKSB7XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChlbGVtZW50Lm5vZGUpO1xuICAgICAgICByZXR1cm4gZGlzY29ubmVjdChlbGVtZW50KTtcbiAgICB9XG59XG4vKipcbiAqIER5bmFtaWNhbGx5IGluc2VydCBhIG5vZGUgYmVmb3JlIGFub3RoZXIgYW5kIGNhbGwgYWxsIHRoZSByZWFjdGlvbnMuXG4gKiAtIGRpc2Nvbm5lY3QgdGhlIG5vZGUgaWYgYWxyZWFkeSBpbiB0aGUgdHJlZVxuICogLSBjb25uZWN0IHRoZSBub2RlIGFmdGVyIHRoZSBpbnNlcnRpb25cbiAqIEBtZXRob2QgaW5zZXJ0QmVmb3JlXG4gKiBAbWVtYmVyb2YgRE5BLkRPTVxuICogQHN0YXRpY1xuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudCBUaGUgcGFyZW50IGVsZW1lbnQuXG4gKiBAcGFyYW0ge0NvbXBvbmVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZOb2RlIFRoZSBub2RlIGZvciBwb3NpdGlvbmluZy5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRoZSBub2RlIGhhcyBiZWVuIGFwcGVuZGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxlbWVudCwgcmVmTm9kZSkge1xuICAgIGlmIChlbGVtZW50Lm5vZGUpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBlbGVtZW50Lm5vZGU7XG4gICAgICAgIGlmIChub2RlLm5leHRTaWJsaW5nICE9PSByZWZOb2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgcmVmTm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogRHluYW1pY2FsbHkgcmVwbGFjZSBhIG5vZGUgd2l0aCBhbm90aGVyIGFuZCBjYWxsIGFsbCB0aGUgcmVhY3Rpb25zLlxuICogLSBkaXNjb25uZWN0IHRoZSBub2RlIGlmIGFscmVhZHkgaW4gdGhlIHRyZWVcbiAqIC0gZGlzY29ubmVjdCB0aGUgcmVwbGFjZWQgbm9kZVxuICogLSBjb25uZWN0IHRoZSBmaXJzdCBub2RlIGFmdGVyIHRoZSBpbnNlcnRpb25cbiAqIEBtZXRob2QgcmVwbGFjZUNoaWxkXG4gKiBAbWVtYmVyb2YgRE5BLkRPTVxuICogQHN0YXRpY1xuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudCBUaGUgcGFyZW50IGVsZW1lbnQuXG4gKiBAcGFyYW0ge0NvbXBvbmVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZOb2RlIFRoZSBub2RlIHRvIHJlcGxhY2UuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUaGUgbm9kZSBoYXMgYmVlbiBhcHBlbmRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VDaGlsZChwYXJlbnQsIGVsZW1lbnQsIHJlZk5vZGUpIHtcbiAgICBpZiAoZWxlbWVudC5ub2RlKSB7XG4gICAgICAgIGxldCBub2RlID0gZWxlbWVudC5ub2RlO1xuICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBkaXNjb25uZWN0KGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQobm9kZSwgcmVmTm9kZSk7XG4gICAgICAgIGlmIChyZWZOb2RlW0NPTVBPTkVOVF9TWU1CT0xdKSB7XG4gICAgICAgICAgICBkaXNjb25uZWN0KHJlZk5vZGVbQ09NUE9ORU5UX1NZTUJPTF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25uZWN0KG5vZGUpO1xuICAgIH1cbn1cbi8qKlxuICogRHluYW1pY2FsbHkgdXBkYXRlIGEgbm9kZSBhdHRyaWJ1dGUgYW5kIGNhbGwgYWxsIHRoZSByZWFjdGlvbnMuXG4gKiBAbWV0aG9kIHNldEF0dHJpYnV0ZVxuICogQG1lbWJlcm9mIEROQS5ET01cbiAqIEBzdGF0aWNcbiAqXG4gKiBAcGFyYW0ge0NvbXBvbmVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgYXR0cmlidXRlIG5hbWUuXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIGF0dHJpYnV0ZSB2YWx1ZS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRoZSBub2RlIGhhcyBiZWVuIHVwZGF0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoZWxlbWVudC5ub2RlKSB7XG4gICAgICAgIGxldCBub2RlID0gZWxlbWVudC5ub2RlO1xuICAgICAgICBsZXQgb2xkVmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICBsZXQgYXR0cnMgPSBlbGVtZW50LmNvbnN0cnVjdG9yLm9ic2VydmVkQXR0cmlidXRlcyB8fCBbXTtcbiAgICAgICAgaWYgKGF0dHJzLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlKGVsZW1lbnQsIG5hbWUsIG9sZFZhbHVlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIER5bmFtaWNhbGx5IHJlbW92ZSBhIG5vZGUgYXR0cmlidXRlIGFuZCBjYWxsIGFsbCB0aGUgcmVhY3Rpb25zLlxuICogQG1ldGhvZCByZW1vdmVBdHRyaWJ1dGVcbiAqIEBtZW1iZXJvZiBETkEuRE9NXG4gKiBAc3RhdGljXG4gKlxuICogQHBhcmFtIHtDb21wb25lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lLlxuICogQHJldHVybiB7Qm9vbGVhbn0gVGhlIG5vZGUgaGFzIGJlZW4gdXBkYXRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCBuYW1lKSB7XG4gICAgaWYgKGVsZW1lbnQubm9kZSkge1xuICAgICAgICBsZXQgbm9kZSA9IGVsZW1lbnQubm9kZTtcbiAgICAgICAgbGV0IG9sZFZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICBsZXQgYXR0cnMgPSBlbGVtZW50LmNvbnN0cnVjdG9yLm9ic2VydmVkQXR0cmlidXRlcyB8fCBbXTtcbiAgICAgICAgaWYgKGF0dHJzLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlKGVsZW1lbnQsIG5hbWUsIG9sZFZhbHVlLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IENPTVBPTkVOVF9TWU1CT0wgfSBmcm9tICcuLi9saWIvc3ltYm9scy5qcyc7XG5cbi8qKlxuICogVEhlIGJhc2UgY3VzdG9tIGNvbXBvbmVudCBtaXhpbnMuIEp1c3QgYWRkIGxpZmUgY3ljbGVzIGNhbGxiYWNrIGFuZCBgaXNgIGdldHRlci5cbiAqIEBtaXhpbiBDb21wb25lbnRNaXhpblxuICogQG1lbWJlcm9mIEROQS5NSVhJTlNcbiAqIEBzdGF0aWNcbiAqL1xuZXhwb3J0IGNvbnN0IENvbXBvbmVudE1peGluID0gKFN1cGVyQ2xhc3MpID0+IGNsYXNzIGV4dGVuZHMgU3VwZXJDbGFzcyB7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IGlzIEdldCBjb21wb25lbnQgaWQuXG4gICAgICogQG5hbWUgaXNcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBtZW1iZXJvZiBETkEuTUlYSU5TLkNvbXBvbmVudE1peGluXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZ2V0IGlzKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZ2V0QXR0cmlidXRlKCdpcycpIHx8IHRoaXMubG9jYWxOYW1lKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBub2RlIEdldCBjb21wb25lbnQgbm9kZSByZWZlcmVuY2UuXG4gICAgICogQG5hbWUgbm9kZVxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKiBAbWVtYmVyb2YgRE5BLk1JWElOUy5Db21wb25lbnRNaXhpblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGdldCBub2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiBhbiBpbnN0YW5jZSB3YXMgaW5zZXJ0ZWQgaW50byB0aGUgZG9jdW1lbnQuXG4gICAgICogQG1ldGhvZCBjb25uZWN0ZWRDYWxsYmFja1xuICAgICAqIEBtZW1iZXJvZiBETkEuTUlYSU5TLkNvbXBvbmVudE1peGluXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHRoaXMubm9kZVtDT01QT05FTlRfU1lNQk9MXSA9IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gYW4gaW5zdGFuY2Ugd2FzIGRldGFjaGVkIGZyb20gdGhlIGRvY3VtZW50LlxuICAgICAqIEBtZXRob2QgZGlzY29ubmVjdGVkQ2FsbGJhY2tcbiAgICAgKiBAbWVtYmVyb2YgRE5BLk1JWElOUy5Db21wb25lbnRNaXhpblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge31cbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIGFuIGF0dHJpYnV0ZSB3YXMgYWRkZWQsIHJlbW92ZWQsIG9yIHVwZGF0ZWQuXG4gICAgICogQG1ldGhvZCBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tcbiAgICAgKiBAbWVtYmVyb2YgRE5BLk1JWElOUy5Db21wb25lbnRNaXhpblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJOYW1lIFRoZSBjaGFuZ2VkIGF0dHJpYnV0ZSBuYW1lLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRWYWwgVGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgYmVmb3JlIHRoZSBjaGFuZ2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5ld1ZhbCBUaGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBhZnRlciB0aGUgY2hhbmdlLlxuICAgICAqL1xuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygpIHt9XG59O1xuIiwibGV0IEN1c3RvbUV2ZW50O1xuXG50cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGxldCBldiA9IG5ldyBzZWxmLkN1c3RvbUV2ZW50KCd0ZXN0Jyk7XG4gICAgQ3VzdG9tRXZlbnQgPSBzZWxmLkN1c3RvbUV2ZW50O1xufSBjYXRjaChleCkge1xuICAgIEN1c3RvbUV2ZW50ID0gZnVuY3Rpb24oZXZlbnQsIHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge1xuICAgICAgICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGRldGFpbDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XG4gICAgICAgIHJldHVybiBldnQ7XG4gICAgfTtcbiAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSBzZWxmLkN1c3RvbUV2ZW50LnByb3RvdHlwZTtcbn1cblxuZXhwb3J0IHsgQ3VzdG9tRXZlbnQgfTtcbiIsImltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSAnLi90eXBlb2YuanMnO1xuaW1wb3J0IHsgQ3VzdG9tRXZlbnQgfSBmcm9tICcuLi9wb2x5ZmlsbHMvY3VzdG9tLWV2ZW50LmpzJztcblxuLyoqXG4gKiBUcmlnZ2VyIGEgY3VzdG9tIERPTSBFdmVudC5cbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZOYW1lIFRoZSBjdXN0b20gZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEV4dHJhIGRhdGEgdG8gcGFzcyB0byB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGJ1YmJsZXMgRW5hYmxlIGV2ZW50IGJ1YmJsaW5nLlxuICogQHBhcmFtIHtCb29sZWFufSBjYW5jZWxhYmxlIE1ha2UgZXZlbnQgY2FuY2VsYWJsZS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgZXZlbnQgcHJvcGFnYXRpb24gaGFzIG5vdCBiZSBzdG9wcGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzcGF0Y2gobm9kZSwgZXZOYW1lLCBkYXRhLCBidWJibGVzID0gdHJ1ZSwgY2FuY2VsYWJsZSA9IHRydWUpIHtcbiAgICBpZiAoIWlzU3RyaW5nKGV2TmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXZlbnQgbmFtZSBpcyB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgbGV0IGV2ID0gbmV3IEN1c3RvbUV2ZW50KGV2TmFtZSwge1xuICAgICAgICBkZXRhaWw6IGRhdGEsXG4gICAgICAgIGJ1YmJsZXMsXG4gICAgICAgIGNhbmNlbGFibGUsXG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGUuZGlzcGF0Y2hFdmVudChldik7XG59XG4iLCJpbXBvcnQgeyBpc1VuZGVmaW5lZCwgaXNGdW5jdGlvbiwgaXNBcnJheSwgaXNPYmplY3QsIGlzU3RyaW5nIH0gZnJvbSAnLi90eXBlb2YuanMnO1xuXG4vKipcbiAqIFNob3J0Y3V0IHRvIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgLlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgZGVmaW5lID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG4vKipcbiAqIFBvd2VyIHRvIHRoZSBjb21wb25lbnQncyBwcm9wZXJ0aWVzLlxuICogVHlwZSBjaGVja2luZywgdmFsaWRhdGlvbiwgY2FsbGJhY2tzLCBldmVudHMgYW5kIGF0dHJpYnV0ZSBzeW5jaW5nLlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUHJvcGVydHkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFByb3BlcnR5IGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258QXJyYXl9IEEgc2luZ2xlIG9yIGEgbGlzdCBvZiB2YWxpZCBjb25zdHJ1Y3RvcnMgZm9yIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9wZXJ0eX1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjdHJzKSB7XG4gICAgICAgIHRoaXMuXyA9IFtdO1xuICAgICAgICBjdHJzID0gY3RycyB8fCBbXTtcbiAgICAgICAgaWYgKCFpc0FycmF5KGN0cnMpKSB7XG4gICAgICAgICAgICBjdHJzID0gW2N0cnNdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3RycyA9IGN0cnM7XG4gICAgICAgIHRoaXMudmFsaWRhdG9yID0gKCkgPT4gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2V0dGVyID0gKHZhbCkgPT4gdmFsO1xuICAgICAgICB0aGlzLmdldHRlckZuID0gKCkgPT4gdGhpcy52YWx1ZTtcbiAgICAgICAgdGhpcy5zZXR0ZXJGbiA9ICh2YWwpID0+IHtcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuX3NldHRlcih2YWwpO1xuICAgICAgICAgICAgaWYgKCh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVR5cGUodmFsKSAmJiB0aGlzLnZhbGlkYXRvcih2YWwpKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAob2xkVmFsdWUgIT09IHZhbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWQodmFsLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgSW52YWxpZCBcXGAke3ZhbH1cXGAgdmFsdWUgZm9yIFxcYCR7dGhpcy5uYW1lfVxcYCBwcm9wZXJ0eSBmb3IgXFxgJHt0aGlzLnNjb3BlLmlzfVxcYC5gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgY2FsbGJhY2sgd2hlbiB0aGUgcHJvcGVydHkgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gdHJpZ2dlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9wZXJ0eX0gVGhlIHByb3BlcnR5IGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBvYnNlcnZlKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSB8fCBpc1N0cmluZyhjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIHRoaXMuXy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgY2FsbGJhY2sgb24gcHJvcGVydHkgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm4ge1Byb3BlcnR5fSBUaGUgcHJvcGVydHkgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHVub2JzZXJ2ZShjYWxsYmFjaykge1xuICAgICAgICBsZXQgaW8gPSB0aGlzLl8uaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgIGlmIChpbyAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuXy5zcGxpY2UoaW8sIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIGNhbGxiYWNrcyBhZnRlciBhIGNoYW5nZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gbmV3VmFsdWUgVGhlIGN1cnJlbnQgcHJvcGVydHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZSBUaGUgcHJldmlvdXMgcHJvcGVydHkgdmFsdWUuXG4gICAgICovXG4gICAgY2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuXy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbGV0IGNsYiA9IHRoaXMuX1tpXTtcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhjbGIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY29wZVtjbGJdLmNhbGwodGhpcy5zY29wZSwgdGhpcywgbmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xiKHRoaXMsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBwcm9wZXJ0eSBhY2NlcHRzIGEgZ2l2ZW4gdHlwZSBhcyB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdHIgVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgZ2l2ZW4gdHlwZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGFjY2VwdHMoQ3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN0cnMuaW5kZXhPZihDdHIpICE9PSAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwcm9wZXJ0eSBuYW1lLlxuICAgICAqIEl0IGFsc28gc2V0IHRoZSBhdHRyTmFtZSBpZiBgLmF0dHJpYnV0ZWAgbWV0aG9kIGFzIGJlZW4gcHJldmlvdXNseVxuICAgICAqIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIHByb3BlcnR5IG5hbWUuXG4gICAgICogQHJldHVybiB7UHJvcGVydHl9IFRoZSBwcm9wZXJ0eSBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgbmFtZWQobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBpZiAodGhpcy5hdHRyUmVxdWVzdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHJOYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHByb3BlcnR5IGluaXRpYWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBpbml0VmFsdWUgVGhlIHByb3BlcnR5IGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybiB7UHJvcGVydHl9IFRoZSBwcm9wZXJ0eSBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgZGVmYXVsdChpbml0VmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBpc09iamVjdChpbml0VmFsdWUpID9cbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUoaW5pdFZhbHVlKSA6XG4gICAgICAgICAgICBpbml0VmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGF0dHJpYnV0ZSBuYW1lIHRvIHN5bmMuXG4gICAgICogSW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgaXQgcmV0cmlldmUgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUuXG4gICAgICogQHJldHVybiB7UHJvcGVydHl9IFRoZSBwcm9wZXJ0eSBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgYXR0cmlidXRlKGF0dHJOYW1lID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNTdHJpbmcoYXR0ck5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHJSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYXR0ck5hbWUgPSBhdHRyTmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXR0clJlcXVlc3RlZCA9ICEhYXR0ck5hbWU7XG4gICAgICAgICAgICB0aGlzLmF0dHJOYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBET00gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBvbiBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldk5hbWUgVGhlIGV2ZW50IG5hbWUuXG4gICAgICogQHJldHVybiB7UHJvcGVydHl9IFRoZSBwcm9wZXJ0eSBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgZGlzcGF0Y2goZXZOYW1lKSB7XG4gICAgICAgIHRoaXMuZXZlbnROYW1lID0gZXZOYW1lO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGEgZ2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgcHJvcGVydHkuXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIHByb3BlcnR5IHZhbHVlIHdpbGwgYmUgcmV0dXJuLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBwcm9wZXJ0eSBnZXR0ZXIuXG4gICAgICogQHJldHVybiB7UHJvcGVydHl9IFRoZSBwcm9wZXJ0eSBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgZ2V0dGVyKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5nZXR0ZXJGbiA9ICgpID0+IGNhbGxiYWNrKHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSBzZXR0ZXIgZnVuY3Rpb24gZm9yIHRoZSBwcm9wZXJ0eS5cbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgcHJvcGVydHkgdmFsdWUgd2lsbCBiZSB1cGRhdGVkIHdpdGggZ2l2ZW4gdmFsdWVcbiAgICAgKiB3aXRob3V0IGFueSBtb2RpZmljYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIHByb3BlcnR5IHNldHRlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9wZXJ0eX0gVGhlIHByb3BlcnR5IGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBzZXR0ZXIoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR0ZXIgPSBjYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwcm9wZXJ0eSB2YWxpZGF0b3IuXG4gICAgICogQSB2YWxpZGF0b3Igc2hvdWxkIHJldHVybiBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGFjY2VwdGFibGVcbiAgICAgKiBvciBgZmFsc2VgIGlmIHVuYWNjYXB0YWJsZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgcHJvcGVydHkgdmFsaWR0b3IuXG4gICAgICogQHJldHVybiB7UHJvcGVydHl9IFRoZSBwcm9wZXJ0eSBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgdmFsaWRhdGUoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRvciA9IGNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB0eXBlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgdmFsaWRhdGVUeXBlKHZhbCkge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBjdHJzID0gdGhpcy5jdHJzO1xuICAgICAgICBpZiAoY3Rycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpIDwgY3Rycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBjdHJzW2ldIHx8IChcbiAgICAgICAgICAgICAgICB2YWwuY29uc3RydWN0b3IgJiYgdmFsLmNvbnN0cnVjdG9yID09PSBjdHJzW2ldXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggdGhlIHByb3BlcnR5IHRvIGEgc2NvcGUgKGEgY29tcG9uZW50IGluc3RhbmNlKS5cbiAgICAgKiBTZXQgdGhlIGRlZmF1bHQgdmFsdWUgaWYgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIFRoZSBzY29wZSB3aGljaCBuZWVkcyB0byBiZSBib3VuZCB3aXRoIHRoZSBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBpbml0KHNjb3BlKSB7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICAgICAgZGVmaW5lKHNjb3BlLCB0aGlzLm5hbWUsIHtcbiAgICAgICAgICAgIGdldDogdGhpcy5nZXR0ZXJGbi5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgc2V0OiB0aGlzLnNldHRlckZuLmJpbmQodGhpcyksXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICAgICAgc2NvcGVbdGhpcy5uYW1lXSA9IHRoaXMuZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBtZXRob2QgZm9yIFByb3BlcnR5IGNyZWF0aW9uLlxuICogQG1ldGhvZCBwcm9wXG4gKiBAbWVtYmVyb2YhIEROQS5cbiAqIEBzdGF0aWNcbiAqXG4gKiBAcHJvcGVydHkge1Byb3BlcnR5fSBBTlkgQSBwcm9wZXJ0eSB3aXRob3V0IHR5cGUgdmFsaWRhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7UHJvcGVydHl9IFNUUklORyBBIHByb3BlcnR5IHdoaWNoIGFjY2VwdHMgb25seSBzdHJpbmdzLlxuICogQHByb3BlcnR5IHtQcm9wZXJ0eX0gQk9PTEVBTiBBIHByb3BlcnR5IHdoaWNoIGFjY2VwdHMgb25seSBib29sZWFucy5cbiAqIEBwcm9wZXJ0eSB7UHJvcGVydHl9IE5VTUJFUiBBIHByb3BlcnR5IHdoaWNoIGFjY2VwdHMgb25seSBudW1iZXJzLlxuICpcbiAqIEBwYXJhbSB7UHJvcGVydHl8RnVuY3Rpb258QXJyYXl9IGN0cnMgQSBQcm9wZXJ0eSB0byBjbG9uZSBvciBhIHNpbmdsZSBvciBhIGxpc3Qgb2YgdmFsaWQgY29uc3RydWN0b3JzIGZvciB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKiBAcmV0dXJuIHtQcm9wZXJ0eX0gVGhlIG5ldyBwcm9wZXJ0eS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3AoY3Rycykge1xuICAgIGlmIChjdHJzIGluc3RhbmNlb2YgUHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIGN0cnM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvcGVydHkoY3Rycyk7XG59XG5cbi8vIERlZmluZSBzb21lIGhlbHBlcnMgZm9yIGRlZmF1bHQgdHlwZXNcbmRlZmluZShwcm9wLCAnQU5ZJywgeyBnZXQoKSB7IHJldHVybiBwcm9wKCk7IH0gfSk7XG5kZWZpbmUocHJvcCwgJ1NUUklORycsIHsgZ2V0KCkgeyByZXR1cm4gcHJvcChTdHJpbmcpOyB9IH0pO1xuZGVmaW5lKHByb3AsICdCT09MRUFOJywgeyBnZXQoKSB7IHJldHVybiBwcm9wKEJvb2xlYW4pOyB9IH0pO1xuZGVmaW5lKHByb3AsICdOVU1CRVInLCB7IGdldCgpIHsgcmV0dXJuIHByb3AoTnVtYmVyKTsgfSB9KTtcbiIsImltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICcuLi9saWIvdHlwZW9mLmpzJztcbmltcG9ydCB7IGRpc3BhdGNoIH0gZnJvbSAnLi4vbGliL2Rpc3BhdGNoLmpzJztcbmltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnLi4vbGliL3R5cGVvZi5qcyc7XG5pbXBvcnQgeyBwcm9wIH0gZnJvbSAnLi4vbGliL3Byb3BlcnR5LmpzJztcblxuLyoqXG4gKiBUcnkgdG8gcGFyc2UgYXR0cmlidXRlIHZhbHVlIGNoZWNraW5nIHRoZSBwcm9wZXJ0eSB2YWxpZGF0aW9uIHR5cGVzLlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge1Byb3BlcnR5fSBwcm9wZXJ0eSBUaGUgcHJvcGVydHkgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJWYWwgVGhlIGF0dHJpYnV0ZSB2YWx1ZS5cbiAqIEByZXR1cm4geyp9IFRoZSBwYXJzZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKHByb3BlcnR5LCBhdHRyVmFsKSB7XG4gICAgaWYgKGF0dHJWYWwgPT09ICcnICYmIHByb3BlcnR5LmFjY2VwdHMoQm9vbGVhbikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghcHJvcGVydHkuYWNjZXB0cyhTdHJpbmcpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShhdHRyVmFsKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF0dHJWYWw7XG59XG5cbi8qKlxuICogU2V0IGFuIGF0dHJpYnV0ZSB2YWx1ZSBjaGVja2luZyBpdHMgdHlwZS5cbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGV4dCBUaGUgbm9kZSB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0ciBUaGUgYXR0cmlidXRlIG5hbWUgdG8gdXBkYXRlLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUoY29udGV4dCwgYXR0ciwgdmFsdWUpIHtcbiAgICBsZXQgY3VycmVudEF0dHJWYWx1ZSA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgIGlmIChjdXJyZW50QXR0clZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNldEF0dHJpYnV0ZShhdHRyLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEF0dHJWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogU2ltcGxlIEN1c3RvbSBDb21wb25lbnQgZm9yIHByb3BlcnRpZXMgaW5pdGlhbGl6YXRpb24gdmlhIGF0dHJpYnV0ZXMuXG4gKiBAbWl4aW4gUHJvcGVydGllc01peGluXG4gKiBAbWVtYmVyb2YgRE5BLk1JWElOU1xuICogQHN0YXRpY1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogLy8gbXktY29tcG9uZW50LmpzXG4gKiBpbXBvcnQgeyBCYXNlQ29tcG9uZW50IH0gZnJvbSAnQGRuYWpzL2NvcmUnO1xuICogZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gKiAgIGdldCBwcm9wZXJ0aWVzKCkge1xuICogICAgIHJldHVybiB7IG5hbWU6IFN0cmluZyB9O1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqIGBgYGpzXG4gKiAvLyBhcHAuanNcbiAqIGltcG9ydCB7IGRlZmluZSB9IGZyb20gJ0BkbmFqcy9jb3JlJztcbiAqIGltcG9ydCB7IE15Q29tcG9uZW50IH0gZnJvbSAnLi9teS1jb21wb25lbnQuanMnO1xuICogZGVmaW5lKCdteS1jb21wb25lbnQnLCBNeUNvbXBvbmVudCk7XG4gKiB2YXIgdGVtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICogdGVtcC5pbm5lckhUTUwgPSAnPG15LWNvbXBvbmVudCBuYW1lPVwiQWxiZXJ0XCI+PC9teS1jb21wb25lbnQ+JztcbiAqIHZhciBlbGVtZW50ID0gdGVtcC5maXJzdENoaWxkO1xuICogY29uc29sZS5sb2coZWxlbWVudC5uYW1lKTsgLy8gbG9ncyBcIkFsYmVydFwiXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IFByb3BlcnRpZXNNaXhpbiA9IChTdXBlckNsYXNzKSA9PiBjbGFzcyBleHRlbmRzIFN1cGVyQ2xhc3Mge1xuICAgIC8qKlxuICAgICAqIEF0dGFjaCBwcm9wZXJ0aWVzIG9uIGNvbXBvbmVudCBjcmVhdGlvbi5cbiAgICAgKiBAbWV0aG9kIGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEROQS5NSVhJTlMuUHJvcGVydGllc01peGluXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGxldCBwcm9wcyA9IHRoaXMucHJvcGVydGllcztcbiAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoIWlzQXJyYXkocHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMgPSBbcHJvcHNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcHMgPSBwcm9wcy5yZWR1Y2UoKHJlcywgcGFydGlhbFByb3BzKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayBpbiBwYXJ0aWFsUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW2tdID0gcHJvcChwYXJ0aWFsUHJvcHNba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Byb3BlcnRpZXMnLCB7XG4gICAgICAgICAgICB2YWx1ZTogcHJvcHMsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgb2JzZXJ2ZWQgPSB0aGlzLmNvbnN0cnVjdG9yLm9ic2VydmVkQXR0cmlidXRlcyB8fCBbXTtcbiAgICAgICAgZm9yIChsZXQgayBpbiBwcm9wcykge1xuICAgICAgICAgICAgbGV0IHByb3AgPSBwcm9wc1trXTtcbiAgICAgICAgICAgIHByb3AubmFtZWQoaykuaW5pdCh0aGlzKTtcbiAgICAgICAgICAgIGxldCB7IGF0dHJOYW1lLCBldmVudE5hbWUgfSA9IHByb3A7XG4gICAgICAgICAgICBpZiAoIWF0dHJOYW1lICYmIG9ic2VydmVkLmluZGV4T2YoaykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcHJvcC5hdHRyaWJ1dGUoKTtcbiAgICAgICAgICAgICAgICBhdHRyTmFtZSA9IGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXR0ck5hbWUgfHwgZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgcHJvcC5vYnNlcnZlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBdHRyaWJ1dGUodGhpcy5ub2RlLCBhdHRyTmFtZSwgdGhpc1twcm9wLm5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCh0aGlzLm5vZGUsIGV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTeW5jIGluaXRpYWwgYXR0cmlidXRlcyB3aXRoIHByb3BlcnRpZXMuXG4gICAgICogQG1ldGhvZCBjb25uZWN0ZWRDYWxsYmFja1xuICAgICAqIEBtZW1iZXJvZiBETkEuTUlYSU5TLlByb3BlcnRpZXNNaXhpblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgICBsZXQgcHJvcHMgPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgICAgIGZvciAobGV0IGsgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGxldCBwcm9wID0gcHJvcHNba107XG4gICAgICAgICAgICBsZXQgeyBhdHRyTmFtZSB9ID0gcHJvcDtcbiAgICAgICAgICAgIGlmIChhdHRyTmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzW3Byb3AubmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGUuaGFzQXR0cmlidXRlKGF0dHJOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wLm5hbWVdID0gZ2V0VmFsdWUocHJvcCwgdGhpcy5ub2RlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QXR0cmlidXRlKHRoaXMubm9kZSwgYXR0ck5hbWUsIHRoaXNbcHJvcC5uYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmMgYXR0cmlidXRlcyB3aXRoIHByb3BlcnRpZXMuXG4gICAgICogQG1ldGhvZCBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tcbiAgICAgKiBAbWVtYmVyb2YgRE5BLk1JWElOUy5Qcm9wZXJ0aWVzTWl4aW5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyTmFtZSBUaGUgY2hhbmdlZCBhdHRyaWJ1dGUgbmFtZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsIFRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIGJlZm9yZSB0aGUgY2hhbmdlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuZXdWYWwgVGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgYWZ0ZXIgdGhlIGNoYW5nZS5cbiAgICAgKi9cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ciwgb2xkVmFsLCBuZXdWYWwpIHtcbiAgICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHIsIG9sZFZhbCwgbmV3VmFsKTtcbiAgICAgICAgbGV0IHByb3BzID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgICBmb3IgKGxldCBrIGluIHByb3BzKSB7XG4gICAgICAgICAgICBsZXQgcHJvcCA9IHByb3BzW2tdO1xuICAgICAgICAgICAgaWYgKHByb3AuYXR0ck5hbWUgPT09IGF0dHIpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3Byb3AubmFtZV0gPSBnZXRWYWx1ZShwcm9wLCBuZXdWYWwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBsaXN0ZW5lciBmb3Igbm9kZSdzIHByb3BlcnR5IGNoYW5nZXMuXG4gICAgICogQG1ldGhvZCBvYnNlcnZlUHJvcGVydHlcbiAgICAgKiBAbWVtYmVyb2YgRE5BLk1JWElOUy5Qcm9wZXJ0aWVzTWl4aW5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wTmFtZSBUaGUgcHJvcGVydHkgbmFtZSB0byBvYnNlcnZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBmaXJlLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggYGNhbmNlbGAgbWV0aG9kLlxuICAgICAqL1xuICAgIG9ic2VydmVQcm9wZXJ0eShwcm9wTmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllc1twcm9wTmFtZV0ub2JzZXJ2ZShjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGxpc3RlbmVyIGZvciBub2RlJ3MgcHJvcGVydHkgY2hhbmdlcy5cbiAgICAgKiBAbWV0aG9kIHVub2JzZXJ2ZVByb3BlcnR5XG4gICAgICogQG1lbWJlcm9mIEROQS5NSVhJTlMuUHJvcGVydGllc01peGluXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcE5hbWUgVGhlIHByb3BlcnR5IG5hbWUgdG8gdW5vYnNlcnZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byByZW1vdmUuXG4gICAgICovXG4gICAgdW5vYnNlcnZlUHJvcGVydHkocHJvcE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMucHJvcGVydGllc1twcm9wTmFtZV0udW5vYnNlcnZlKGNhbGxiYWNrKTtcbiAgICB9XG59O1xuIiwiY29uc3QgRUxFTV9QUk9UTyA9IEVsZW1lbnQucHJvdG90eXBlO1xuXG5leHBvcnQgY29uc3QgbWF0Y2hlcyA9IEVMRU1fUFJPVE8ubWF0Y2hlcyB8fFxuICAgIEVMRU1fUFJPVE8ubWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgRUxFTV9QUk9UTy5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBFTEVNX1BST1RPLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgRUxFTV9QUk9UTy5vTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgRUxFTV9QUk9UTy53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG4iLCJpbXBvcnQgeyBpc1N0cmluZywgaXNGdW5jdGlvbiB9IGZyb20gJy4uL2xpYi90eXBlb2YuanMnO1xuaW1wb3J0IHsgbWF0Y2hlcyB9IGZyb20gJy4uL3BvbHlmaWxscy9tYXRjaGVzLmpzJztcbmltcG9ydCB7IGRpc3BhdGNoIH0gZnJvbSAnLi4vbGliL2Rpc3BhdGNoLmpzJztcblxuY29uc3QgU1BMSVRfU0VMRUNUT1IgPSAvKFteXFxzXSspKC4qKT8vO1xuXG4vKipcbiAqIFNpbXBsZSBDdXN0b20gQ29tcG9uZW50IHdpdGggZXZlbnRzIGRlbGVnYXRpb24sXG4gKiBJdCBhbHNvIGltcGxlbWVudCBhIGBkaXNwYXRjaEV2ZW50YCB3cmFwcGVyIG5hbWVkIGB0cmlnZ2VyYC5cbiAqIEBtaXhpbiBFdmVudHNNaXhpblxuICogQG1lbWJlcm9mIEROQS5NSVhJTlMuXG4gKiBAc3RhdGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiAvLyBteS1jb21wb25lbnQuanNcbiAqIGltcG9ydCB7IEJhc2VDb21wb25lbnQgfSBmcm9tICdAZG5hanMvY29yZSc7XG4gKiBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAqICAgZ2V0IGV2ZW50cygpIHtcbiAqICAgICByZXR1cm4ge1xuICogICAgICAgJ2NsaWNrIGJ1dHRvbic6ICdvbkJ1dHRvbkNsaWNrJ1xuICogICAgIH1cbiAqICAgfVxuICogICBvbkJ1dHRvbkNsaWNrKCkge1xuICogICAgIGNvbnNvbGUubG9nKCdidXR0b24gY2xpY2tlZCcpO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqIGBgYGpzXG4gKiAvLyBhcHAuanNcbiAqIGltcG9ydCB7IGRlZmluZSB9IGZyb20gJ0BkbmFqcy9jb3JlJztcbiAqIGltcG9ydCB7IE15Q29tcG9uZW50IH0gZnJvbSAnLi9teS1jb21wb25lbnQuanMnO1xuICogZGVmaW5lKCdteS1jb21wb25lbnQnLCBNeUNvbXBvbmVudCk7XG4gKiB2YXIgZWxlbWVudCA9IG5ldyBNeUNvbXBvbmVudCgpO1xuICogdmFyIGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICogYnV0dG9uLmlubmVyVGV4dCA9ICdDbGljayBtZSc7XG4gKiBlbGVtZW50LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gKiBidXR0b24uY2xpY2soKTsgLy8gbG9ncyBcImJ1dHRvbiBjbGlja2VkXCJcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgRXZlbnRzTWl4aW4gPSAoU3VwZXJDbGFzcykgPT4gY2xhc3MgZXh0ZW5kcyBTdXBlckNsYXNzIHtcbiAgICAvKipcbiAgICAgKiBBdHRhY2ggYW5kIGRlbGVnYXRlIGV2ZW50cyB0byB0aGUgY29tcG9uZW50LlxuICAgICAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgRE5BLk1JWElOUy5FdmVudHNNaXhpblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBiaW5kIGV2ZW50c1xuICAgICAgICBsZXQgZXZlbnRzID0gdGhpcy5ldmVudHMgfHwge307XG4gICAgICAgIGZvciAobGV0IGsgaW4gZXZlbnRzKSB7XG4gICAgICAgICAgICBsZXQgY2FsbGJhY2sgPSBpc1N0cmluZyhldmVudHNba10pID9cbiAgICAgICAgICAgICAgICB0aGlzW2V2ZW50c1trXV0gOlxuICAgICAgICAgICAgICAgIGV2ZW50c1trXTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIGxldCBydWxlID0gay5tYXRjaChTUExJVF9TRUxFQ1RPUik7XG4gICAgICAgICAgICAgICAgbGV0IGV2TmFtZSA9IHJ1bGVbMV07XG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdG9yID0gKHJ1bGVbMl0gfHwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZShldk5hbWUsIHNlbGVjdG9yLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZOYW1lLCAoZXYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZXYsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2FsbGJhY2sgZm9yIGV2ZW50LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGVnYXRlIGV2ZW50cyB0byB0aGUgY29tcG9uZW50IGRlc2NlbmRlbnRzLlxuICAgICAqIEBtZXRob2QgZGVsZWdhdGVcbiAgICAgKiBAbWVtYmVyb2YgRE5BLk1JWElOUy5FdmVudHNNaXhpblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZGVsZWdhdGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIEEgQ1NTIHNlbGVjdG9yIGZvciBkZXNjZW5kZW50cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gZmlyZSB3aGVuIHRoZSBldmVudCBmaXJlcy5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZShldk5hbWUsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldk5hbWUsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMuY2FsbCh0YXJnZXQsIHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGV2ZW50LCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBOb2RlLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50YCB3cmFwcGVyLlxuICAgICAqIEBtZXRob2QgdHJpZ2dlclxuICAgICAqIEBtZW1iZXJvZiBETkEuTUlYSU5TLkV2ZW50c01peGluXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZOYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBmaXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEEgc2V0IG9mIGN1c3RvbSBkYXRhIHRvIHBhc3MgdG8gdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYnViYmxlcyBTaG91bGQgdGhlIGV2ZW50IGJ1YmJsZSB0aHJvdyB0aGUgRE9NIHRyZWUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjYW5jZWxhYmxlIENhbiBiZSB0aGUgZXZlbnQgY2FuY2VsIGJ5IGEgY2FsbGJhY2suXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBldmVudCBwcm9wYWdhdGlvbiBoYXMgbm90IGJlIHN0b3BwZWQuXG4gICAgICovXG4gICAgdHJpZ2dlcihldk5hbWUsIGRhdGEsIGJ1YmJsZXMgPSB0cnVlLCBjYW5jZWxhYmxlID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2godGhpcywgZXZOYW1lLCBkYXRhLCBidWJibGVzLCBjYW5jZWxhYmxlKTtcbiAgICB9XG59O1xuIiwiY29uc3Qgcm9vdERvYyA9IGRvY3VtZW50O1xuLyoqXG4gKiBDcmVhdGUgYW5kIGF0dGFjaCBhIHN0eWxlIGVsZW1lbnQgZm9yIGEgY29tcG9uZW50LlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIEEgY29tcG9uZW50IGluc3RhbmNlLlxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9IFRoZSBjcmVhdGVkIHN0eWxlIGVsZW1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdHlsZShub2RlKSB7XG4gICAgbGV0IGRvYyA9IG5vZGUub3duZXJEb2N1bWVudCB8fCByb290RG9jO1xuICAgIGxldCBzdHlsZUVsZW0gPSBkb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZUVsZW0udHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgc3R5bGVFbGVtLnNldEF0dHJpYnV0ZSgnaWQnLCBgc3R5bGUtJHtub2RlLmlzfWApO1xuICAgIGxldCBoZWFkID0gZG9jLmhlYWQ7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoaGVhZC5maXJzdEVsZW1lbnRDaGlsZCkge1xuICAgICAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW0sIGhlYWQuZmlyc3RFbGVtZW50Q2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlRWxlbTtcbn1cbiIsImltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSAnLi4vbGliL3R5cGVvZi5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTdHlsZSB9IGZyb20gJy4uL2xpYi9zdHlsZS5qcyc7XG5cbi8qKlxuICogU2ltcGxlIEN1c3RvbSBDb21wb25lbnQgd2l0aCBjc3Mgc3R5bGUgaGFuZGxpbmcgdXNpbmcgdGhlIGBjc3NgIHByb3BlcnR5LlxuICogQG1peGluIFN0eWxlTWl4aW5cbiAqIEBtZW1iZXJvZiBETkEuTUlYSU5TXG4gKiBAc3RhdGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiAvLyBteS1jb21wb25lbnQuanNcbiAqIGltcG9ydCB7IEJhc2VDb21wb25lbnQgfSBmcm9tICdAZG5hanMvY29yZSc7XG4gKiBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAqICAgZ2V0IGNzcygpIHtcbiAqICAgICByZXR1cm4gJy5teS1jb21wb25lbnQgcCB7IGNvbG9yOiByZWQ7IH0nXG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICogYGBganNcbiAqIC8vIGFwcC5qc1xuICogaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSAnQGRuYWpzL2NvcmUnO1xuICogaW1wb3J0IHsgTXlDb21wb25lbnQgfSBmcm9tICcuL215LWNvbXBvbmVudC5qcyc7XG4gKiBkZWZpbmUoJ215LWNvbXBvbmVudCcsIE15Q29tcG9uZW50KTtcbiAqIHZhciBlbGVtZW50ID0gbmV3IE15Q29tcG9uZW50KCk7XG4gKiB2YXIgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAqIHAuaW5uZXJUZXh0ID0gJ1BhcmFncmFwaCc7XG4gKiBlbGVtZW50LmFwcGVuZENoaWxkKHApOyAvLyB0ZXh0IGluc2lkZSBgcGAgZ2V0cyB0aGUgcmVkIGNvbG9yXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IFN0eWxlTWl4aW4gPSAoU3VwZXJDbGFzcykgPT4gY2xhc3MgZXh0ZW5kcyBTdXBlckNsYXNzIHtcbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIGFuIGluc3RhbmNlIG9mIHRoZSBlbGVtZW50IGlzIGNyZWF0ZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5zdHlsZUVsZW0pIHtcbiAgICAgICAgICAgIGxldCBDdHIgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN0ciwgJ3N0eWxlRWxlbScsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogY3JlYXRlU3R5bGUodGhpcyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUNTUygpO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgICB0aGlzLm5vZGUuY2xhc3NMaXN0LmFkZCh0aGlzLmlzKTtcbiAgICB9XG5cbiAgICB1cGRhdGVDU1MoKSB7XG4gICAgICAgIGxldCBzdHlsZSA9IHRoaXMuY3NzO1xuICAgICAgICBpZiAoaXNTdHJpbmcoc3R5bGUpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnN0eWxlRWxlbS50ZXh0Q29udGVudCA9IHN0eWxlO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsImltcG9ydCB7IGlzVW5kZWZpbmVkLCBpc0Z1bmN0aW9uLCBpc1N0cmluZyB9IGZyb20gJy4uL2xpYi90eXBlb2YuanMnO1xuXG4vKipcbiAqIFNpbXBsZSBDdXN0b20gQ29tcG9uZW50IHdpdGggdGVtcGxhdGUgaGFuZGxpbmcgdXNpbmcgdGhlIGB0ZW1wbGF0ZWAgcHJvcGVydHkuXG4gKiBAbWVtYmVyb2YgRE5BLk1JWElOU1xuICogQG1peGluIFRlbXBsYXRlTWl4aW5cbiAqIEBzdGF0aWNcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBTdXBlckNsYXNzIFRoZSBjbGFzcyB0byBleHRlbmQuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGV4dGVuZGVkIGNsYXNzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogLy8gbXktY29tcG9uZW50LmpzXG4gKiBpbXBvcnQgeyBCYXNlQ29tcG9uZW50IH0gZnJvbSAnQGRuYWpzL2NvcmUnO1xuICogZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gKiAgIGdldCB0ZW1wbGF0ZSgpIHtcbiAqICAgICByZXR1cm4gYDxoMT4ke3RoaXMubmFtZX08L2gxPmA7XG4gKiAgIH1cbiAqICAgZ2V0IG5hbWUoKSB7XG4gKiAgICAgcmV0dXJuICdOZXd0b24nO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqIGBgYGpzXG4gKiAvLyBhcHAuanNcbiAqIGltcG9ydCB7IGRlZmluZSB9IGZyb20gJ0BkbmFqcy9jb3JlJztcbiAqIGltcG9ydCB7IE15Q29tcG9uZW50IH0gZnJvbSAnLi9teS1jb21wb25lbnQuanMnO1xuICogZGVmaW5lKCdteS1jb21wb25lbnQnLCBNeUNvbXBvbmVudCk7XG4gKiB2YXIgZWxlbWVudCA9IG5ldyBNeUNvbXBvbmVudCgpO1xuICogY29uc29sZS5sb2coZWxlbWVudC5pbm5lckhUTUwpOyAvLyBsb2dzIFwiPGgxPk5ld3RvbjwvaDE+XCJcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgVGVtcGxhdGVNaXhpbiA9IChTdXBlckNsYXNzKSA9PiBjbGFzcyBleHRlbmRzIFN1cGVyQ2xhc3Mge1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gYXV0b1JlbmRlciBTaG91bGQgdGhlIGNvbXBvbmVudCByZS1yZW5kZXIgb24gcHJvcGVydGllcyBjaGFuZ2VzLlxuICAgICAqIEBuYW1lIGF1dG9SZW5kZXJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAbWVtYmVyb2YgRE5BLk1JWElOUy5UZW1wbGF0ZU1peGluXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZ2V0IGF1dG9SZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggcHJvcGVydGllcyBvYnNlcnZlcnMgaW4gb3JkZXIgdG8gdXBkYXRlIGNoaWxkcmVuLlxuICAgICAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgRE5BLk1JWElOUy5UZW1wbGF0ZU1peGluXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmICh0aGlzLmF1dG9SZW5kZXIgJiYgIWlzVW5kZWZpbmVkKHRoaXMudGVtcGxhdGUpKSB7XG4gICAgICAgICAgICBsZXQgcHJvcHMgPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrIGluIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW2tdLm9ic2VydmUoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdGhlIGNvbXBvbmVudCB3aGVuIGNvbm5lY3RlZC5cbiAgICAgKiBAbWV0aG9kIGNvbm5lY3RlZENhbGxiYWNrXG4gICAgICogQG1lbWJlcm9mIEROQS5NSVhJTlMuVGVtcGxhdGVNaXhpblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMudGVtcGxhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBDb21wb25lbnQgY2hpbGQgbm9kZXMuXG4gICAgICogQG1ldGhvZCByZW5kZXJcbiAgICAgKiBAbWVtYmVyb2YgRE5BLk1JWElOUy5UZW1wbGF0ZU1peGluXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gdHBsIEEgdGVtcGxhdGUgdG8gdXNlIGluc3RlYWQgb2YgYHRoaXMudGVtcGxhdGVgLlxuICAgICAqXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBXaWxsIHRocm93IGlmIHRoZSB0ZW1wbGF0ZSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgcmVuZGVyKHRwbCkge1xuICAgICAgICB0cGwgPSB0cGwgfHwgdGhpcy50ZW1wbGF0ZTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odHBsKSkge1xuICAgICAgICAgICAgdHBsLmNhbGwodGhpcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcodHBsKSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlLmlubmVySFRNTCA9IHRwbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdGVtcGxhdGUgcHJvcGVydHkuJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLXJlc3QtcGFyYW1zICovXG5leHBvcnQgY29uc3QgcmVkdWNlID0gQXJyYXkucHJvdG90eXBlLnJlZHVjZSB8fCBmdW5jdGlvbihjYWxsYmFjayAvKiwgaW5pdGlhbFZhbHVlKi8gKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGxldCB0ID0gdGhpcztcbiAgICBsZXQgbGVuID0gdC5sZW5ndGg7XG4gICAgbGV0IGsgPSAwO1xuICAgIGxldCB2YWx1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB2YWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAoayA8IGxlbiAmJiAhKGsgaW4gdCkpIHtcbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHRbaysrXTtcbiAgICB9XG4gICAgZm9yICg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICBpZiAoayBpbiB0KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKHZhbHVlLCB0W2tdLCBrLCB0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuIiwiLyoqXG4gKiBAYXV0aG9yIEp1c3RpbiBGYWduYW5pXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qdXN0aW5mYWduYW5pL21peHdpdGguanNcbiAqL1xuaW1wb3J0IHsgcmVkdWNlIH0gZnJvbSAnLi4vcG9seWZpbGxzL3JlZHVjZS5qcyc7XG5cbi8qKlxuICogTWl4IGEgY2xhc3Mgd2l0aCBhIG1peGluLlxuICogQG1ldGhvZCBtaXgoLi4uKS53aXRoKC4uLilcbiAqIEBtZW1iZXJvZiEgRE5BLlxuICogQHN0YXRpY1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cGVyQ2xhc3MgVGhlIGNsYXNzIHRvIGV4dGVuZC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG1peGVkIGNsYXNzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogLy8gbXktc3VwZXIuanNcbiAqIGV4cG9ydCBjbGFzcyBNeVN1cGVyQ2xhc3Mge1xuICogICAgIGNvbnN0cnVjdG9yKCkge1xuICogICAgICAgICAvLyBkbyBzb21ldGhpbmdcbiAqICAgICB9XG4gKiB9XG4gKiBgYGBcbiAqIGBgYGpzXG4gKiAvLyBtaXhpbi5qc1xuICogZXhwb3J0IGNvbnN0IE1peGluID0gKHN1cGVyQ2xhc3MpID0+IGNsYXNzIGV4dGVuZCBzdXBlckNsYXNzIHtcbiAqICAgICBjb25zdHJ1Y3RvcigpIHtcbiAqICAgICAgICAgc3VwZXIoKTtcbiAqICAgICAgICAgLy8gZG8gc29tZXRoaW5nIGVsc2VcbiAqICAgICB9XG4gKiB9O1xuICogYGBgXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgbWl4IH0gZnJvbSAnQGRuYWpzL2NvcmUnO1xuICogaW1wb3J0IHsgTXlTdXBlckNsYXNzIH0gZnJvbSAnLi9teS1zdXBlci5qcyc7XG4gKiBpbXBvcnQgeyBNaXhpbiB9IGZyb20gJy4vbWl4aW4uanMnO1xuICpcbiAqIGV4cG9ydCBjbGFzcyBNaXhlZENsYXNzIGV4dGVuZHMgbWl4KE15U3VwZXJDbGFzcykud2l0aChNaXhpbikge1xuICogICAgIC4uLlxuICogfVxuICogYGBgXG4gKi9cblxuLyoqXG4gKiBBIE1peGluIGhlbHBlciBjbGFzcy5cbiAqIEBpZ25vcmVcbiAqL1xuY2xhc3MgTWl4aW4ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG1peGFibGUgY2xhc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJDbGFzcyBUaGUgY2xhc3MgdG8gZXh0ZW5kLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN1cGVyY2xhc3MpIHtcbiAgICAgICAgc3VwZXJjbGFzcyA9IHN1cGVyY2xhc3MgfHwgY2xhc3Mge307XG4gICAgICAgIHRoaXMuc3VwZXJjbGFzcyA9IHN1cGVyY2xhc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1peCB0aGUgc3VwZXIgY2xhc3Mgd2l0aCBhIGxpc3Qgb2YgbWl4aW5zLlxuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IG1peGlucyAqTiogbWl4aW4gZnVuY3Rpb25zLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgZXh0ZW5kZWQgY2xhc3MuXG4gICAgICovXG4gICAgd2l0aCgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGxldCBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICByZXR1cm4gcmVkdWNlLmNhbGwoYXJncywgKGMsIG1peGluKSA9PiBtaXhpbihjKSwgdGhpcy5zdXBlcmNsYXNzKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgTWl4aW4gaW5zdGFuY2UuXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjb25zdCBtaXggPSAoc3VwZXJDbGFzcykgPT4gbmV3IE1peGluKHN1cGVyQ2xhc3MpO1xuIiwiaW1wb3J0IHsgcmVnaXN0cnkgfSBmcm9tICcuL3JlZ2lzdHJ5LmpzJztcbmltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSAnLi90eXBlb2YuanMnO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgbm9kZSBpcyBhbHJlYWR5IGluc3RhbnRpYXRlZCBIVE1MRWxlbWVudCBmb3IgcHJvZ3JhbW1hdGljYWxseSBgY29uc3RydWN0b3JgIGNhbGxzLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgVGhlIG5vZGUgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUaGUgbm9kZSBzaG91bGQgYmUgaW5zdGFudGlhdGVkLlxuICovXG5mdW5jdGlvbiBpc05ldyhub2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICFpc1N0cmluZyhub2RlLm91dGVySFRNTCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG4vKipcbiAqIFNoaW0gb3JpZ2luYWwgRWxlbWVudCBjb25zdHJ1Y3RvcnMgaW4gb3JkZXIgdG8gYmUgdXNlZCB3aXRoIGBuZXdgLlxuICogQG1ldGhvZCBzaGltXG4gKiBAbWVtYmVyb2YhIEROQS5cbiAqIEBzdGF0aWNcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBPcmlnaW5hbCBUaGUgb3JpZ2luYWwgY29uc3RydWN0b3IgdG8gc2hpbS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hpbW1lZCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIC8vIHNoaW0gYXVkaW8gZWxlbWVudFxuICogaW1wb3J0IHsgc2hpbSB9IGZyb20gJ0BkbmFqcy9jb3JlJztcbiAqXG4gKiBjbGFzcyBNeUF1ZGlvIGV4dGVuZHMgc2hpbShIVE1MQXVkaW9FbGVtZW50KSB7XG4gKiAgICAgLi4uXG4gKiB9XG4gKlxuICogbGV0IGF1ZGlvID0gbmV3IE15QXVkaW8oKTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hpbShPcmlnaW5hbCkge1xuICAgIGNsYXNzIFBvbHlmaWxsZWQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIGlmICghaXNOZXcodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkZXNjID0gcmVnaXN0cnkuZ2V0RGVzY3JpcHRvcih0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIGxldCBjb25maWcgPSBkZXNjLmNvbmZpZztcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHRhZ25hbWUgb2YgdGhlIGNvbnN0cnVjdG9yIGFuZCBjcmVhdGUgYSBuZXcgZWxlbWVudCB3aXRoIGl0XG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgY29uZmlnLmV4dGVuZHMgPyBjb25maWcuZXh0ZW5kcyA6IGRlc2MuaXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlbGVtZW50Ll9fcHJvdG9fXyA9IGRlc2MuQ3RyLnByb3RvdHlwZTtcbiAgICAgICAgICAgIGlmIChjb25maWcuZXh0ZW5kcykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdpcycsIGRlc2MuaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2xvbmUgdGhlIHByb3RvdHlwZSBvdmVycmlkaW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICBQb2x5ZmlsbGVkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT3JpZ2luYWwucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogUG9seWZpbGxlZCxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBQb2x5ZmlsbGVkO1xufVxuIiwiaW1wb3J0ICogYXMgRE9NX0hFTFBFUlMgZnJvbSAnLi9saWIvZG9tLmpzJztcbmltcG9ydCB7IENvbXBvbmVudE1peGluIH0gZnJvbSAnLi9taXhpbnMvY29tcG9uZW50LmpzJztcbmltcG9ydCB7IFByb3BlcnRpZXNNaXhpbiB9IGZyb20gJy4vbWl4aW5zL3Byb3BlcnRpZXMtY29tcG9uZW50LmpzJztcbmltcG9ydCB7IEV2ZW50c01peGluIH0gZnJvbSAnLi9taXhpbnMvZXZlbnRzLWNvbXBvbmVudC5qcyc7XG5pbXBvcnQgeyBTdHlsZU1peGluIH0gZnJvbSAnLi9taXhpbnMvc3R5bGUtY29tcG9uZW50LmpzJztcbmltcG9ydCB7IFRlbXBsYXRlTWl4aW4gfSBmcm9tICcuL21peGlucy90ZW1wbGF0ZS1jb21wb25lbnQuanMnO1xuXG4vKipcbiAqIEEgc2V0IG9mIERPTSBoZWxwZXJzIGZvciBjYWxsYmFja3MgdHJpZ2dlciB3aGVuIEN1c3RvbSBFbGVtZW50c1xuICogYXJlIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuXG4gKiBAbmFtZSBET01cbiAqIEBuYW1lc3BhY2UgRE9NXG4gKiBAbWVtYmVyb2YhIEROQS5cbiAqIEBzdGF0aWNcbiAqL1xuZXhwb3J0IGNvbnN0IERPTSA9IERPTV9IRUxQRVJTO1xuLyoqXG4gKiBBIHNldCBvZiBjb3JlIG1peGlucy5cbiAqIEBuYW1lIE1JWElOU1xuICogQG5hbWVzcGFjZSBNSVhJTlNcbiAqIEBtZW1iZXJvZiEgRE5BLlxuICogQHN0YXRpY1xuICovXG5leHBvcnQgY29uc3QgTUlYSU5TID0ge1xuICAgIENvbXBvbmVudE1peGluLFxuICAgIFByb3BlcnRpZXNNaXhpbixcbiAgICBFdmVudHNNaXhpbixcbiAgICBTdHlsZU1peGluLFxuICAgIFRlbXBsYXRlTWl4aW4sXG59O1xuZXhwb3J0IHsgbWl4IH0gZnJvbSAnLi9saWIvbWl4aW5zLmpzJztcbmV4cG9ydCB7IHByb3AgfSBmcm9tICcuL2xpYi9wcm9wZXJ0eS5qcyc7XG5leHBvcnQgeyBzaGltIH0gZnJvbSAnLi9saWIvc2hpbS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9zeW1ib2xzLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL3R5cGVvZi5qcyc7XG4iXSwibmFtZXMiOlsiaXNGdW5jdGlvbiIsIm9iaiIsImlzU3RyaW5nIiwiaXNPYmplY3QiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpc1VuZGVmaW5lZCIsImlzQXJyYXkiLCJBcnJheSIsInJlZ2lzdHJ5IiwibmFtZSIsIkN0ciIsImNvbmZpZyIsImNvbXBvbmVudHMiLCJ0b0xvd2VyQ2FzZSIsImsiLCJkZXNjIiwiZ2V0RGVzY3JpcHRvciIsIkNPTVBPTkVOVF9TWU1CT0wiLCJnZXRDb21wb25lbnQiLCJlbGVtZW50IiwiZnVsbCIsIm5vZGUiLCJub2RlVHlwZSIsIk5vZGUiLCJFTEVNRU5UX05PREUiLCJnZXRBdHRyaWJ1dGUiLCJ0YWdOYW1lIiwiZ2V0IiwiQ29tcG9uZW50TWl4aW4iLCJTdXBlckNsYXNzIiwiY29ubmVjdGVkQ2FsbGJhY2siLCJkaXNjb25uZWN0ZWRDYWxsYmFjayIsImF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayIsImxvY2FsTmFtZSIsIkN1c3RvbUV2ZW50IiwiZXYiLCJzZWxmIiwiZXgiLCJldmVudCIsInBhcmFtcyIsInVuZGVmaW5lZCIsImV2dCIsImRvY3VtZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0Q3VzdG9tRXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImRldGFpbCIsImRpc3BhdGNoIiwiZXZOYW1lIiwiZGF0YSIsIlR5cGVFcnJvciIsImRpc3BhdGNoRXZlbnQiLCJkZWZpbmUiLCJkZWZpbmVQcm9wZXJ0eSIsIlByb3BlcnR5IiwiY3RycyIsIl8iLCJ2YWxpZGF0b3IiLCJfc2V0dGVyIiwidmFsIiwiZ2V0dGVyRm4iLCJ2YWx1ZSIsInNldHRlckZuIiwidmFsaWRhdGVUeXBlIiwib2xkVmFsdWUiLCJjaGFuZ2VkIiwic2NvcGUiLCJpcyIsIm9ic2VydmUiLCJjYWxsYmFjayIsInB1c2giLCJ1bm9ic2VydmUiLCJpbyIsImluZGV4T2YiLCJzcGxpY2UiLCJuZXdWYWx1ZSIsImkiLCJsZW4iLCJsZW5ndGgiLCJjbGIiLCJhY2NlcHRzIiwibmFtZWQiLCJhdHRyUmVxdWVzdGVkIiwiYXR0ck5hbWUiLCJkZWZhdWx0IiwiaW5pdFZhbHVlIiwiZGVmYXVsdFZhbHVlIiwiZnJlZXplIiwiYXR0cmlidXRlIiwiZXZlbnROYW1lIiwiZ2V0dGVyIiwic2V0dGVyIiwidmFsaWRhdGUiLCJjb25zdHJ1Y3RvciIsImluaXQiLCJiaW5kIiwicHJvcCIsIlN0cmluZyIsIkJvb2xlYW4iLCJOdW1iZXIiLCJnZXRWYWx1ZSIsInByb3BlcnR5IiwiYXR0clZhbCIsIkpTT04iLCJwYXJzZSIsInNldEF0dHJpYnV0ZSIsImNvbnRleHQiLCJhdHRyIiwiY3VycmVudEF0dHJWYWx1ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIlByb3BlcnRpZXNNaXhpbiIsInByb3BzIiwicHJvcGVydGllcyIsInJlZHVjZSIsInJlcyIsInBhcnRpYWxQcm9wcyIsIm9ic2VydmVkIiwib2JzZXJ2ZWRBdHRyaWJ1dGVzIiwiaGFzQXR0cmlidXRlIiwib2xkVmFsIiwibmV3VmFsIiwib2JzZXJ2ZVByb3BlcnR5IiwicHJvcE5hbWUiLCJ1bm9ic2VydmVQcm9wZXJ0eSIsIkVMRU1fUFJPVE8iLCJFbGVtZW50IiwibWF0Y2hlcyIsIm1hdGNoZXNTZWxlY3RvciIsIm1vek1hdGNoZXNTZWxlY3RvciIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwib01hdGNoZXNTZWxlY3RvciIsIndlYmtpdE1hdGNoZXNTZWxlY3RvciIsIlNQTElUX1NFTEVDVE9SIiwiRXZlbnRzTWl4aW4iLCJldmVudHMiLCJydWxlIiwibWF0Y2giLCJzZWxlY3RvciIsInRyaW0iLCJkZWxlZ2F0ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJ0YXJnZXQiLCJwYXJlbnROb2RlIiwidHJpZ2dlciIsInJvb3REb2MiLCJjcmVhdGVTdHlsZSIsImRvYyIsIm93bmVyRG9jdW1lbnQiLCJzdHlsZUVsZW0iLCJjcmVhdGVFbGVtZW50IiwidHlwZSIsImhlYWQiLCJmaXJzdEVsZW1lbnRDaGlsZCIsImluc2VydEJlZm9yZSIsImFwcGVuZENoaWxkIiwiU3R5bGVNaXhpbiIsInVwZGF0ZUNTUyIsImNsYXNzTGlzdCIsImFkZCIsInN0eWxlIiwiY3NzIiwidGV4dENvbnRlbnQiLCJUZW1wbGF0ZU1peGluIiwiYXV0b1JlbmRlciIsInRlbXBsYXRlIiwicmVuZGVyIiwidHBsIiwiaW5uZXJIVE1MIiwidCIsImFyZ3VtZW50cyIsIk1peGluIiwic3VwZXJjbGFzcyIsIndpdGgiLCJhcmdzIiwic2xpY2UiLCJjIiwibWl4aW4iLCJtaXgiLCJzdXBlckNsYXNzIiwiaXNOZXciLCJvdXRlckhUTUwiLCJNSVhJTlMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7Ozs7QUFTQSxBQUFPLFNBQVNBLFVBQVQsQ0FBb0JDLEdBQXBCLEVBQXlCO1NBQ3JCLE9BQU9BLEdBQVAsS0FBZSxVQUF0Qjs7Ozs7Ozs7Ozs7QUFXSixBQUFPLFNBQVNDLFFBQVQsQ0FBa0JELEdBQWxCLEVBQXVCO1NBQ25CLE9BQU9BLEdBQVAsS0FBZSxRQUF0Qjs7Ozs7Ozs7Ozs7QUFXSixBQUFPLFNBQVNFLFFBQVQsQ0FB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"}